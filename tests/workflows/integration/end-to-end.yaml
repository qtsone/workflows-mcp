name: integration-end-to-end
description: |
  Integration test demonstrating common workflow patterns:
  1. Variable resolution across namespaces (inputs, metadata, blocks)
  2. Conditional execution based on results
  3. File operations with templates
  4. State management across phases
  5. Parallel execution where possible
  6. Block status detection
tags: [test, integration, end-to-end]

inputs:
  project_name:
    type: str
    default: "TestProject"
    description: "Project name for the workflow"

blocks:
  - id: init_state
    description: "Initialize workflow state"
    type: WriteJSONState
    inputs:
      path: "{{tmp}}/state.json"
      create_parents: true
      data:
        project: "{{inputs.project_name}}"
        phase: "init"
        workflow: "{{metadata.workflow_name}}"

  - id: gen_data1
    description: "Generate data in parallel"
    type: Shell
    inputs:
      command: printf "data1"
    depends_on: [init_state]

  - id: gen_data2
    description: "Generate data in parallel"
    type: Shell
    inputs:
      command: printf "data2"
    depends_on: [init_state]

  - id: update_state
    description: "Update state after parallel generation"
    type: MergeJSONState
    inputs:
      path: "{{tmp}}/state.json"
      updates:
        phase: "generation_complete"
        data1: "{{blocks.gen_data1.outputs.stdout | trim}}"
        data2: "{{blocks.gen_data2.outputs.stdout | trim}}"
    depends_on: [gen_data1, gen_data2]

  - id: render_report
    description: "Render report (depends on both data sources)"
    type: CreateFile
    inputs:
      path: "{{tmp}}/report.md"
      create_parents: true
      content: |
        {{render('
        # {{ project }}

        Workflow: {{ workflow }}
        Timestamp: {{ timestamp }}

        ## Data Streams
        - Stream 1: {{ data1 }}
        - Stream 2: {{ data2 }}

        ## Status
        Phase: {{ phase }}
        ', {
          'project': inputs.project_name,
          'workflow': metadata.workflow_name,
          'timestamp': metadata.started_at,
          'data1': blocks.gen_data1.outputs.stdout | trim,
          'data2': blocks.gen_data2.outputs.stdout | trim,
          'phase': 'report_generation'
        })}}
    depends_on: [update_state]

  - id: validate_success
    description: "Validate successful completion"
    type: Shell
    inputs:
      command: echo "validation_passed"
    condition: "{{blocks.gen_data1.succeeded and blocks.gen_data2.succeeded and blocks.render_report.succeeded}}"
    depends_on:
      - block: render_report
        required: true

  - id: validate_failure
    description: "Validate failure scenario"
    type: Shell
    inputs:
      command: echo "validation_failed"
    condition: "{{blocks.gen_data1.failed or blocks.gen_data2.failed or blocks.render_report.failed}}"
    depends_on:
      - block: render_report
        required: false

  - id: final_state
    description: "Finalize workflow state"
    type: MergeJSONState
    inputs:
      path: "{{tmp}}/state.json"
      updates:
        phase: "complete"
        validation_passed: "{{blocks.validate_success.succeeded}}"
    depends_on:
      - block: validate_success
        required: false
      - block: validate_failure
        required: false

  - id: read_final_state
    description: "Read final state"
    type: ReadJSONState
    inputs:
      path: "{{tmp}}/state.json"
    depends_on: [final_state]

  - id: read_report
    type: ReadFiles
    inputs:
      patterns: ["report.md"]
      base_path: "{{tmp}}"
      mode: full
    depends_on: [render_report]

  - id: cleanup
    description: "Cleanup test directory"
    type: Shell
    inputs:
      command: |
        [ -d "{{tmp}}" ] && rm -rf "{{tmp}}" || echo "Error: Test directory does not exist"
    depends_on: [read_final_state, read_report]

outputs:
  project_name:
    value: "{{inputs.project_name}}"
    type: str
  workflow_name:
    value: "{{metadata.workflow_name}}"
    type: str
  data1:
    value: "{{blocks.gen_data1.outputs.stdout}}"
    type: str
  data2:
    value: "{{blocks.gen_data2.outputs.stdout}}"
    type: str
  report_content:
    value: "{{blocks.read_report.content}}"
    type: str
  final_phase:
    value: "{{blocks.read_final_state.outputs.data.phase}}"
    type: str
  validation_passed:
    value: "{{blocks.validate_success.succeeded}}"
    type: bool
  all_blocks_succeeded:
    value: "{{ blocks.gen_data1.succeeded and blocks.gen_data2.succeeded and blocks.render_report.succeeded and blocks.validate_success.succeeded and blocks.cleanup.succeeded }}"
    type: bool
