name: ensure-tool
description: Ensure tool availability (validate + install if needed)
version: "1.0"
author: Workflows MCP Team
tags: [tools, core, validation, installation]

inputs:
  tool_name:
    type: str
    description: Tool name (e.g., "pytest", "ruff", "git")
    required: true

  tool_type:
    type: str
    description: Tool type ("python_package", "system_command", "node_package")
    required: true

  provider:
    type: str
    description: "Installation provider (default: auto-detect based on tool_type)"
    default: ""
    required: false

  version:
    type: str
    description: Version constraint (e.g., ">=7.0.0", "~=7.4", "==7.4.3")
    default: ""
    required: false

  venv_path:
    type: str
    description: Virtual environment path (for Python tools)
    default: ""
    required: false

  auto_install:
    type: bool
    description: Automatically install if missing or version mismatch
    default: true
    required: false

  fail_if_missing:
    type: bool
    description: Fail workflow if tool unavailable and auto_install=false
    default: true
    required: false

  version_flag:
    type: str
    description: Command to check version (e.g., "--version")
    default: "--version"
    required: false

blocks:
  - id: validate_command
    type: Workflow
    inputs:
      workflow: validate-command
      inputs:
        command: "${inputs.tool_name}"
        version_flag: "${inputs.version_flag}"
        required_version: "${inputs.version}"

  # Step 2: Determine if installation needed
  - id: check_installation_needed
    type: Shell
    inputs:
      command: |
        # Installation needed if:
        # 1. Tool not found AND auto_install=true
        # 2. Tool found but doesn't meet constraints AND auto_install=true
        # Note: Python booleans convert to "True"/"False" (capitalized), not "true"/"false"
        if [ "${inputs.auto_install}" == "true" ]; then
          # Note: validate_command.outputs.found is now a boolean (true/false as string)
          if [ "${blocks.validate_command.outputs.found}" == "false" ]; then
            exit 0  # Exit 0 = installation needed
          elif [ "${blocks.validate_command.outputs.found}" == "true" ] && [ -n "${inputs.version}" ] && [ "${blocks.validate_command.outputs.meets_constraints}" == "false" ]; then
            exit 0  # Exit 0 = installation needed (found but wrong version)
          else
            exit 1  # Exit 1 = no installation needed
          fi
        else
          exit 1  # Exit 1 = no installation needed (auto_install disabled)
        fi
      timeout: 5
      
    depends_on:
      - validate_command

  # Step 3: Detect platform for provider selection
  - id: detect_platform
    type: Shell
    inputs:
      command: |
        case "$(uname -s)" in
          Darwin*) echo "macos" ;;
          Linux*)  echo "linux" ;;
          CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
          *) echo "unknown" ;;
        esac
      timeout: 5
      

  # Step 4: Select installation provider
  - id: select_provider
    type: Shell
    inputs:
      command: |
        EXPLICIT_PROVIDER="${inputs.provider}"
        TOOL_TYPE="${inputs.tool_type}"
        PLATFORM="${blocks.detect_platform.outputs.stdout}"
        VENV_PATH="${inputs.venv_path}"

        # Strip trailing whitespace from PLATFORM (stdout includes newline)
        PLATFORM=$(echo "$PLATFORM" | tr -d '\n')

        # 1. Use explicit provider if specified
        if [ -n "$EXPLICIT_PROVIDER" ]; then
          echo "$EXPLICIT_PROVIDER"
          exit 0
        fi

        # 2. Python packages
        if [ "$TOOL_TYPE" = "python_package" ]; then
          if [ -n "$VENV_PATH" ]; then
            # Virtual environment: check for uv, fallback to pip
            if command -v uv >/dev/null 2>&1; then
              echo "uv"
            else
              echo "pip"
            fi
          else
            # System installation: use platform package manager
            case "$PLATFORM" in
              macos) echo "brew" ;;
              linux) echo "apt" ;;
              *) echo "pip" ;;
            esac
          fi
          exit 0
        fi

        # 3. System commands
        if [ "$TOOL_TYPE" = "system_command" ]; then
          case "$PLATFORM" in
            macos) echo "brew" ;;
            linux) echo "apt" ;;
            windows) echo "choco" ;;
            *) echo "manual" ;;
          esac
          exit 0
        fi

        # 4. Node packages
        if [ "$TOOL_TYPE" = "node_package" ]; then
          echo "npm"
          exit 0
        fi

        # Fallback
        echo "manual"
      timeout: 5
      
    depends_on:
      - detect_platform

  # Step 5: Install via pip (if provider is pip and installation needed)
  - id: install_via_pip
    type: Shell
    inputs:
      command: |
        TOOL="${inputs.tool_name}"
        VERSION="${inputs.version}"
        VENV="${inputs.venv_path}"

        # Build pip command
        if [ -n "$VENV" ] && [ -f "$VENV/bin/pip" ]; then
          PIP="$VENV/bin/pip"
        else
          PIP="pip"
        fi

        # Build package spec
        if [ -n "$VERSION" ]; then
          # Remove constraint operators for pip install
          VERSION_SPEC=$(echo "$VERSION" | sed 's/>=//;s/>//;s/<=//;s/<//;s/==//;s/~=//')
          PACKAGE_SPEC="$TOOL>=$VERSION_SPEC"
        else
          PACKAGE_SPEC="$TOOL"
        fi

        # Install package
        echo "Installing $PACKAGE_SPEC using pip..."
        $PIP install "$PACKAGE_SPEC" --upgrade
      working_dir: "."
      timeout: 300
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0 and ${blocks.select_provider.outputs.stdout} == 'pip'"
    depends_on:
      - check_installation_needed
      - select_provider

  # Step 6: Install via uv (if provider is uv and installation needed)
  - id: install_via_uv
    type: Shell
    inputs:
      command: |
        TOOL="${inputs.tool_name}"
        VERSION="${inputs.version}"
        VENV="${inputs.venv_path}"

        # Determine uv command
        if command -v uv >/dev/null 2>&1; then
          UV="uv"
        else
          echo "Error: uv not found"
          exit 1
        fi

        # Build package spec
        if [ -n "$VERSION" ]; then
          VERSION_SPEC=$(echo "$VERSION" | sed 's/>=//;s/>//;s/<=//;s/<//;s/==//;s/~=//')
          PACKAGE_SPEC="$TOOL>=$VERSION_SPEC"
        else
          PACKAGE_SPEC="$TOOL"
        fi

        # Install using uv pip
        if [ -n "$VENV" ]; then
          echo "Installing $PACKAGE_SPEC using uv pip into $VENV..."
          $UV pip install --python "$VENV/bin/python" "$PACKAGE_SPEC"
        else
          echo "Installing $PACKAGE_SPEC using uv pip..."
          $UV pip install "$PACKAGE_SPEC"
        fi
      working_dir: "."
      timeout: 300
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0 and ${blocks.select_provider.outputs.stdout} == 'uv'"
    depends_on:
      - check_installation_needed
      - select_provider

  # Step 7: Install via brew (if provider is brew and installation needed)
  - id: install_via_brew
    type: Shell
    inputs:
      command: |
        TOOL="${inputs.tool_name}"

        if command -v brew >/dev/null 2>&1; then
          echo "Installing $TOOL using Homebrew..."
          brew install "$TOOL"
        else
          echo "Error: Homebrew not found"
          exit 1
        fi
      timeout: 600
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0 and ${blocks.select_provider.outputs.stdout} == 'brew'"
    depends_on:
      - check_installation_needed
      - select_provider

  # Step 8: Validate installation was successful
  - id: validate_installation
    type: Workflow
    inputs:
      workflow: validate-command
      inputs:
        command: "${inputs.tool_name}"
        version_flag: "${inputs.version_flag}"
        required_version: "${inputs.version}"
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0"
    depends_on:
      - install_via_pip
      - install_via_uv
      - install_via_brew

  # Step 9: Determine action taken
  - id: determine_action
    type: Shell
    inputs:
      command: |
        # Determine action based on initial state
        # Note: validate_command.outputs.found is a boolean (True/False as string)
        if [ "${blocks.validate_command.outputs.found}" = "False" ]; then
          echo "installed"
        else
          echo "upgraded"
        fi
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0"
    depends_on:
      - check_installation_needed
      - validate_command

  # Fallback action for when installation not needed
  - id: determine_action_no_install
    type: Shell
    inputs:
      command: echo "already_available"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} != 0"
    depends_on:
      - check_installation_needed
      - validate_command

  # Step 10: Check if tool is now available (after installation)
  - id: check_final_availability_installed
    type: Shell
    inputs:
      command: echo "${blocks.validate_installation.outputs.found}"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0"
    depends_on:
      - determine_action
      - validate_installation

  # Check final availability (no installation needed)
  - id: check_final_availability_existing
    type: Shell
    inputs:
      command: echo "${blocks.validate_command.outputs.found}"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} != 0"
    depends_on:
      - determine_action_no_install

  # Step 11: Get final version (after installation)
  - id: get_final_version_installed
    type: Shell
    inputs:
      command: echo "${blocks.validate_installation.outputs.version}"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0"
    depends_on:
      - determine_action
      - validate_installation

  # Get final version (no installation needed)
  - id: get_final_version_existing
    type: Shell
    inputs:
      command: echo "${blocks.validate_command.outputs.version}"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} != 0"
    depends_on:
      - determine_action_no_install

  # Step 12: Get final path (after installation)
  - id: get_final_path_installed
    type: Shell
    inputs:
      command: echo "${blocks.validate_installation.outputs.path}"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} == 0"
    depends_on:
      - determine_action
      - validate_installation

  # Get final path (no installation needed)
  - id: get_final_path_existing
    type: Shell
    inputs:
      command: echo "${blocks.validate_command.outputs.path}"
      timeout: 5
      
    condition: "${blocks.check_installation_needed.outputs.exit_code} != 0"
    depends_on:
      - determine_action_no_install

  # Step 13: Consolidate outputs for summary
  - id: consolidate_action
    type: Shell
    inputs:
      command: |
        # Return action from whichever path was taken
        ACTION_INSTALLED="${blocks.determine_action.outputs.stdout}"
        ACTION_EXISTING="${blocks.determine_action_no_install.outputs.stdout}"
        if [ -n "$ACTION_INSTALLED" ]; then
          echo "$ACTION_INSTALLED"
        else
          echo "$ACTION_EXISTING"
        fi
      timeout: 5
      
    depends_on:
      - determine_action
      - determine_action_no_install

  - id: consolidate_availability
    type: Shell
    inputs:
      command: |
        AVAIL_INSTALLED="${blocks.check_final_availability_installed.outputs.stdout}"
        AVAIL_EXISTING="${blocks.check_final_availability_existing.outputs.stdout}"
        if [ -n "$AVAIL_INSTALLED" ]; then
          echo "$AVAIL_INSTALLED"
        else
          echo "$AVAIL_EXISTING"
        fi
      timeout: 5
      
    depends_on:
      - check_final_availability_installed
      - check_final_availability_existing

  - id: consolidate_version
    type: Shell
    inputs:
      command: |
        VER_INSTALLED="${blocks.get_final_version_installed.outputs.stdout}"
        VER_EXISTING="${blocks.get_final_version_existing.outputs.stdout}"
        if [ -n "$VER_INSTALLED" ]; then
          echo "$VER_INSTALLED"
        else
          echo "$VER_EXISTING"
        fi
      timeout: 5
      
    depends_on:
      - get_final_version_installed
      - get_final_version_existing

  - id: consolidate_path
    type: Shell
    inputs:
      command: |
        PATH_INSTALLED="${blocks.get_final_path_installed.outputs.stdout}"
        PATH_EXISTING="${blocks.get_final_path_existing.outputs.stdout}"
        if [ -n "$PATH_INSTALLED" ]; then
          echo "$PATH_INSTALLED"
        else
          echo "$PATH_EXISTING"
        fi
      timeout: 5
      
    depends_on:
      - get_final_path_installed
      - get_final_path_existing

  # Step 14: Generate summary
  - id: ensure_summary
    type: Shell
    inputs:
      command: |
        printf "Ensure Tool Summary:\n"
        printf "- Tool: ${inputs.tool_name}\n"
        printf "- Type: ${inputs.tool_type}\n"
        printf "- Provider: ${blocks.select_provider.outputs.stdout}\n"
        printf "- Action: ${blocks.consolidate_action.outputs.stdout}\n"
        printf "- Available: ${blocks.consolidate_availability.outputs.stdout}\n"
        printf "- Version: ${blocks.consolidate_version.outputs.stdout}\n"
        printf "- Path: ${blocks.consolidate_path.outputs.stdout}"
    depends_on:
      - select_provider
      - consolidate_action
      - consolidate_availability
      - consolidate_version
      - consolidate_path

outputs:
  available: "${blocks.consolidate_availability.outputs.stdout}"
  installed_by_workflow: "${blocks.check_installation_needed.outputs.exit_code} == 0"
  version: "${blocks.consolidate_version.outputs.stdout}"
  provider_used: "${blocks.select_provider.outputs.stdout}"
  tool_path: "${blocks.consolidate_path.outputs.stdout}"
  action_taken: "${blocks.consolidate_action.outputs.stdout}"
  validation_output: "${blocks.validate_command.outputs.summary}"
  summary: "${blocks.ensure_summary.outputs.stdout}"
