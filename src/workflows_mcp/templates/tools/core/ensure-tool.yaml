name: ensure-tool
description: Ensure tool availability (validate + install if needed)
version: "1.0"
author: Workflows MCP Team
tags: [tools, core, validation, installation]
inputs:
  tool_name:
    type: str
    description: Tool name (e.g., "pytest", "ruff", "git")
    required: true
  tool_type:
    type: str
    description: Tool type ("python_package", "system_command", "node_package")
    required: true
  provider:
    type: str
    description: "Installation provider (default: auto-detect based on tool_type)"
    default: ""
    required: false
  version:
    type: str
    description: Version constraint (e.g., ">=7.0.0", "~=7.4", "==7.4.3")
    default: ""
    required: false
  venv_path:
    type: str
    description: Virtual environment path (for Python tools)
    default: ""
    required: false
  auto_install:
    type: bool
    description: Automatically install if missing or version mismatch
    default: true
    required: false
  fail_if_missing:
    type: bool
    description: Fail workflow if tool unavailable and auto_install=false
    default: true
    required: false
  version_flag:
    type: str
    description: Command to check version (e.g., "--version")
    default: "--version"
    required: false
blocks:
  - id: validate_command
    type: Workflow
    inputs:
      workflow: validate-command
      inputs:
        command: "{{inputs.tool_name}}"
        version_flag: "{{inputs.version_flag}}"
        required_version: "{{inputs.version}}"
  # Step 2: Determine if installation needed
  - id: check_installation_needed
    type: Shell
    inputs:
      command: |
        # Installation needed if:
        # 1. Tool not found AND auto_install=true
        # 2. Tool found but doesn't meet constraints AND auto_install=true
        # Note: Python booleans convert to "True"/"False" (capitalized), not "true"/"false"
        if [ "{{inputs.auto_install}}" == "true" ]; then
          # Note: validate_command.outputs.found is now a boolean (true/false as string)
          if [ "{{blocks.validate_command.outputs.found}}" == "false" ]; then
            exit 0  # Exit 0 = installation needed
          elif [ "{{blocks.validate_command.outputs.found}}" == "true" ] && [ -n "{{inputs.version}}" ] && [ "{{blocks.validate_command.outputs.meets_constraints}}" == "false" ]; then
            exit 0  # Exit 0 = installation needed (found but wrong version)
          else
            exit 1  # Exit 1 = no installation needed
          fi
        else
          exit 1  # Exit 1 = no installation needed (auto_install disabled)
        fi
      timeout: 5
    depends_on:
      - validate_command
  # Step 3: Detect platform for provider selection
  - id: detect_platform
    type: Shell
    inputs:
      command: |
        case "$(uname -s)" in
          Darwin*) echo "macos" ;;
          Linux*)  echo "linux" ;;
          CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
          *) echo "unknown" ;;
        esac
      timeout: 5
  # Step 4: Select installation provider
  - id: select_provider
    type: Shell
    inputs:
      command: |
        EXPLICIT_PROVIDER="{{inputs.provider}}"
        TOOL_TYPE="{{inputs.tool_type}}"
        PLATFORM="{{blocks.detect_platform.outputs.stdout}}"
        VENV_PATH="{{inputs.venv_path}}"

        # Strip trailing whitespace from PLATFORM (stdout includes newline)
        PLATFORM=$(echo "$PLATFORM" | tr -d '\n')

        # 1. Use explicit provider if specified
        if [ -n "$EXPLICIT_PROVIDER" ]; then
          echo "$EXPLICIT_PROVIDER"
          exit 0
        fi

        # 2. Python packages
        if [ "$TOOL_TYPE" = "python_package" ]; then
          if [ -n "$VENV_PATH" ]; then
            # Virtual environment: check for uv, fallback to pip
            if command -v uv >/dev/null 2>&1; then
              echo "uv"
            else
              echo "pip"
            fi
          else
            # System installation: use platform package manager
            case "$PLATFORM" in
              macos) echo "brew" ;;
              linux) echo "apt" ;;
              *) echo "pip" ;;
            esac
          fi
          exit 0
        fi

        # 3. System commands
        if [ "$TOOL_TYPE" = "system_command" ]; then
          case "$PLATFORM" in
            macos) echo "brew" ;;
            linux) echo "apt" ;;
            windows) echo "choco" ;;
            *) echo "manual" ;;
          esac
          exit 0
        fi

        # 4. Node packages
        if [ "$TOOL_TYPE" = "node_package" ]; then
          echo "npm"
          exit 0
        fi

        # Fallback
        echo "manual"
      timeout: 5
    depends_on:
      - detect_platform
  # Step 5: Install via pip (if provider is pip and installation needed)
  - id: install_via_pip
    type: Shell
    inputs:
      command: |
        TOOL="{{inputs.tool_name}}"
        VERSION="{{inputs.version}}"
        VENV="{{inputs.venv_path}}"

        # Build pip command
        if [ -n "$VENV" ] && [ -f "$VENV/bin/pip" ]; then
          PIP="$VENV/bin/pip"
        else
          PIP="pip"
        fi

        # Build package spec
        if [ -n "$VERSION" ]; then
          # Remove constraint operators for pip install
          VERSION_SPEC=$(echo "$VERSION" | sed 's/>=//;s/>//;s/<=//;s/<//;s/==//;s/~=//')
          PACKAGE_SPEC="$TOOL>=$VERSION_SPEC"
        else
          PACKAGE_SPEC="$TOOL"
        fi

        # Install package
        echo "Installing $PACKAGE_SPEC using pip..."
        $PIP install "$PACKAGE_SPEC" --upgrade
      working_dir: "."
      timeout: 300
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0 and {{blocks.select_provider.outputs.stdout}} == 'pip'"
    depends_on:
      - check_installation_needed
      - select_provider
  # Step 6: Install via uv (if provider is uv and installation needed)
  - id: install_via_uv
    type: Shell
    inputs:
      command: |
        TOOL="{{inputs.tool_name}}"
        VERSION="{{inputs.version}}"
        VENV="{{inputs.venv_path}}"

        # Determine uv command
        if command -v uv >/dev/null 2>&1; then
          UV="uv"
        else
          echo "Error: uv not found"
          exit 1
        fi

        # Build package spec
        if [ -n "$VERSION" ]; then
          VERSION_SPEC=$(echo "$VERSION" | sed 's/>=//;s/>//;s/<=//;s/<//;s/==//;s/~=//')
          PACKAGE_SPEC="$TOOL>=$VERSION_SPEC"
        else
          PACKAGE_SPEC="$TOOL"
        fi

        # Install using uv pip
        if [ -n "$VENV" ]; then
          echo "Installing $PACKAGE_SPEC using uv pip into $VENV..."
          $UV pip install --python "$VENV/bin/python" "$PACKAGE_SPEC"
        else
          echo "Installing $PACKAGE_SPEC using uv pip..."
          $UV pip install "$PACKAGE_SPEC"
        fi
      working_dir: "."
      timeout: 300
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0 and {{blocks.select_provider.outputs.stdout}} == 'uv'"
    depends_on:
      - check_installation_needed
      - select_provider
  # Step 7: Install via brew (if provider is brew and installation needed)
  - id: install_via_brew
    type: Shell
    inputs:
      command: |
        TOOL="{{inputs.tool_name}}"

        if command -v brew >/dev/null 2>&1; then
          echo "Installing $TOOL using Homebrew..."
          brew install "$TOOL"
        else
          echo "Error: Homebrew not found"
          exit 1
        fi
      timeout: 600
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0 and {{blocks.select_provider.outputs.stdout}} == 'brew'"
    depends_on:
      - check_installation_needed
      - select_provider
  # Step 8: Validate installation was successful
  - id: validate_installation
    type: Workflow
    inputs:
      workflow: validate-command
      inputs:
        command: "{{inputs.tool_name}}"
        version_flag: "{{inputs.version_flag}}"
        required_version: "{{inputs.version}}"
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0"
    depends_on:
      - install_via_pip
      - install_via_uv
      - install_via_brew
  # Step 9: Determine action taken
  - id: determine_action
    type: Shell
    inputs:
      command: |
        # Determine action based on initial state
        # Note: validate_command.outputs.found is a boolean (True/False as string)
        if [ "{{blocks.validate_command.outputs.found}}" = "False" ]; then
          echo "installed"
        else
          echo "upgraded"
        fi
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0"
    depends_on:
      - check_installation_needed
      - validate_command
  # Fallback action for when installation not needed
  - id: determine_action_no_install
    type: Shell
    inputs:
      command: echo "already_available"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} != 0"
    depends_on:
      - check_installation_needed
      - validate_command
  # Step 10: Check if tool is now available (after installation)
  - id: check_final_availability_installed
    type: Shell
    inputs:
      command: echo "{{blocks.validate_installation.outputs.found}}"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0"
    depends_on:
      - determine_action
      - validate_installation
  # Check final availability (no installation needed)
  - id: check_final_availability_existing
    type: Shell
    inputs:
      command: echo "{{blocks.validate_command.outputs.found}}"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} != 0"
    depends_on:
      - determine_action_no_install
  # Step 11: Get final version (after installation)
  - id: get_final_version_installed
    type: Shell
    inputs:
      command: echo "{{blocks.validate_installation.outputs.version}}"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0"
    depends_on:
      - determine_action
      - validate_installation
  # Get final version (no installation needed)
  - id: get_final_version_existing
    type: Shell
    inputs:
      command: echo "{{blocks.validate_command.outputs.version}}"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} != 0"
    depends_on:
      - determine_action_no_install
  # Step 12: Get final path (after installation)
  - id: get_final_path_installed
    type: Shell
    inputs:
      command: echo "{{blocks.validate_installation.outputs.path}}"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} == 0"
    depends_on:
      - determine_action
      - validate_installation
  # Get final path (no installation needed)
  - id: get_final_path_existing
    type: Shell
    inputs:
      command: echo "{{blocks.validate_command.outputs.path}}"
      timeout: 5
    condition: "{{blocks.check_installation_needed.outputs.exit_code}} != 0"
    depends_on:
      - determine_action_no_install
  # Step 13: Consolidate outputs for summary
  - id: consolidate_action
    type: Shell
    inputs:
      command: |
        # Return action from whichever path was taken
        ACTION_INSTALLED="{{blocks.determine_action.outputs.stdout}}"
        ACTION_EXISTING="{{blocks.determine_action_no_install.outputs.stdout}}"
        if [ -n "$ACTION_INSTALLED" ]; then
          echo "$ACTION_INSTALLED"
        else
          echo "$ACTION_EXISTING"
        fi
      timeout: 5
    depends_on:
      - determine_action
      - determine_action_no_install
  - id: consolidate_availability
    type: Shell
    inputs:
      command: |
        AVAIL_INSTALLED="{{blocks.check_final_availability_installed.outputs.stdout}}"
        AVAIL_EXISTING="{{blocks.check_final_availability_existing.outputs.stdout}}"
        if [ -n "$AVAIL_INSTALLED" ]; then
          echo "$AVAIL_INSTALLED"
        else
          echo "$AVAIL_EXISTING"
        fi
      timeout: 5
    depends_on:
      - check_final_availability_installed
      - check_final_availability_existing
  - id: consolidate_version
    type: Shell
    inputs:
      command: |
        VER_INSTALLED="{{blocks.get_final_version_installed.outputs.stdout}}"
        VER_EXISTING="{{blocks.get_final_version_existing.outputs.stdout}}"
        if [ -n "$VER_INSTALLED" ]; then
          echo "$VER_INSTALLED"
        else
          echo "$VER_EXISTING"
        fi
      timeout: 5
    depends_on:
      - get_final_version_installed
      - get_final_version_existing
  - id: consolidate_path
    type: Shell
    inputs:
      command: |
        PATH_INSTALLED="{{blocks.get_final_path_installed.outputs.stdout}}"
        PATH_EXISTING="{{blocks.get_final_path_existing.outputs.stdout}}"
        if [ -n "$PATH_INSTALLED" ]; then
          echo "$PATH_INSTALLED"
        else
          echo "$PATH_EXISTING"
        fi
      timeout: 5
    depends_on:
      - get_final_path_installed
      - get_final_path_existing
  # Step 14: Generate summary
  - id: ensure_summary
    type: Shell
    inputs:
      command: |
        printf "Ensure Tool Summary:\n"
        printf "- Tool: {{inputs.tool_name}}\n"
        printf "- Type: {{inputs.tool_type}}\n"
        printf "- Provider: {{blocks.select_provider.outputs.stdout}}\n"
        printf "- Action: {{blocks.consolidate_action.outputs.stdout}}\n"
        printf "- Available: {{blocks.consolidate_availability.outputs.stdout}}\n"
        printf "- Version: {{blocks.consolidate_version.outputs.stdout}}\n"
        printf "- Path: {{blocks.consolidate_path.outputs.stdout}}"
    depends_on:
      - select_provider
      - consolidate_action
      - consolidate_availability
      - consolidate_version
      - consolidate_path
outputs:
  available:
    value: "{{blocks.consolidate_availability.outputs.stdout}}"
  installed_by_workflow:
    value: "{{blocks.check_installation_needed.outputs.exit_code}} == 0"
  version:
    value: "{{blocks.consolidate_version.outputs.stdout}}"
  provider_used:
    value: "{{blocks.select_provider.outputs.stdout}}"
  tool_path:
    value: "{{blocks.consolidate_path.outputs.stdout}}"
  action_taken:
    value: "{{blocks.consolidate_action.outputs.stdout}}"
  validation_output:
    value: "{{blocks.validate_command.outputs.summary}}"
  summary:
    value: "{{blocks.ensure_summary.outputs.stdout}}"
