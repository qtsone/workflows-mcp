name: check-version
description: Check if a command is available in PATH and validate version constraints
version: "2.0"
author: Workflows MCP Team
tags: [tools, validation, command, version, core]

inputs:
  tool_name:
    type: str
    description: Command name to validate (e.g., "pytest", "git", "ruff")
    required: true

  pattern:
    type: str
    description: Regex pattern to extract version (e.g., '(\d+\.\d+\.\d+)')
    default: '(\d+\.\d+\.\d+)'
    required: false

  version:
    type: str
    description: Version constraint (e.g., ">=7.0.0", "~=7.4", "==7.4.3")
    default: ""
    required: false

blocks:
  - id: check_command
    description: Check if command exists and get its path
    type: Shell
    inputs:
      command: |
        if command -v ${inputs.tool_name} >/dev/null 2>&1; then
          command -v ${inputs.tool_name} > "$SCRATCH/path.txt"
          exit 0
        else
          echo "Command not found: ${inputs.tool_name}"
          exit 1
        fi
      timeout: 5
    outputs:
      path:
        type: str
        description: Full path to the command if found
        path: "$SCRATCH/path.txt"

  # Try multiple common version flags to get version
  - id: get_version
    type: Shell
    inputs:
      command: |
        # Try common version flags in order: --version, -version, version, -V, -v
        for flag in --version -version version -V -v; do
          if output=$(${inputs.tool_name} $flag 2>&1); then
            version=$(echo "$output" | grep -oE "${inputs.pattern}" | head -n1)
            if [ -n "$version" ]; then
              echo "$version" > "$SCRATCH/version.txt"
              exit 0
            fi
          fi
        done
        echo "unknown" > "$SCRATCH/version.txt"
      timeout: 10
    outputs:
      version:
        type: str
        description: Extracted version of the command
        path: "$SCRATCH/version.txt"
    depends_on:
      - block: check_command
        required: false

  # Validate version constraint using Python for clean comparison
  - id: validate_version
    type: Shell
    inputs:
      command: |
        python3 -c '
        import sys
        import re

        version = "${blocks.get_version.outputs.version}".strip()
        constraint = "${inputs.version}".strip()

        # Skip if no version or unknown
        if not version or version == "unknown":
            sys.exit(0)

        # Skip if no constraint
        if not constraint:
            sys.exit(0)

        def parse_version(v):
            parts = re.findall(r"\d+", v)
            return tuple(int(p) for p in parts[:3])

        # Parse constraint operator and version
        operators = {">=": "ge", ">": "gt", "<=": "le", "<": "lt", "==": "eq", "~=": "compatible"}
        op_match = re.match(r"^(>=|>|<=|<|==|~=)(.+)$", constraint)

        if op_match:
            op, req_ver = op_match.groups()
        else:
            op, req_ver = "==", constraint

        try:
            current = parse_version(version)
            required = parse_version(req_ver)
        except:
            print("Invalid version format")
            sys.exit(1)

        # Version comparison
        if op == "~=":
            # Compatible release: same major.minor
            result = current[:2] == required[:2]
        elif op == ">=":
            result = current >= required
        elif op == ">":
            result = current > required
        elif op == "<=":
            result = current <= required
        elif op == "<":
            result = current < required
        elif op == "==":
            result = current == required
        else:
            result = False

        sys.exit(0 if result else 1)
        '
      timeout: 5

    condition: "${inputs.version} != '' and ${blocks.get_version.outputs.version} != 'unknown'"
    depends_on:
      - get_version

outputs:
  found: "${blocks.check_command.succeeded}"
  path: "${blocks.check_command.outputs.path}"
  version: "${blocks.get_version.outputs.version}"
  meets_constraints: "${blocks.validate_version.succeeded}"
