name: multi-level-composition
description: Demonstrates 3-level workflow composition with variable passing and output propagation
version: "1.0"
author: Workflows MCP Team
tags: [example, composition, multi-level, advanced, tutorial]
inputs:
  project_name:
    type: str
    description: Project name for demonstration
    default: "demo-project"

  base_path:
    type: str
    description: Base working directory
    default: "/tmp/workflow-demo"

  run_full_pipeline:
    type: bool
    description: Run complete pipeline or just setup
    default: true

blocks:
  # Level 1: Initialize project structure
  - id: init_message
    type: EchoBlock
    inputs:
      message: "Starting multi-level composition demo for ${inputs.project_name}"

  # Level 2: Create feature branch (calls Git workflow)
  - id: create_branch
    type: Workflow
    inputs:
      workflow: "git-checkout-branch"
      inputs:
        branch_name: "feature/${inputs.project_name}-demo"
        base_branch: "main"
        working_dir: "."
        fetch_first: false
        push_to_remote: false
    depends_on:
      - init_message

  # Level 2: Generate project README (calls File workflow)
  - id: generate_readme
    type: Workflow
    inputs:
      workflow: "generate-readme"
      inputs:
        project_name: "${inputs.project_name}"
        description: "Multi-level composition demonstration project"
        author: "Workflows MCP"
        version: "1.0.0"
        template_path: "${inputs.base_path}/README.template.md"
        output_path: "${inputs.base_path}/README.md"
        create_template_if_missing: true
    depends_on:
      - init_message

  # Get composition statuses
  - id: get_branch_status
    type: Shell
    inputs:
      command: "test '${blocks.create_branch.succeeded}' = 'true' && echo 'Created' || echo 'Failed'"
      timeout: 5

    depends_on:
      - create_branch

  - id: get_readme_status
    type: Shell
    inputs:
      command: "test '${blocks.generate_readme.succeeded}' = 'true' && echo 'Generated' || echo 'Failed'"
      timeout: 5

    depends_on:
      - generate_readme

  # Level 2: Show composition results
  - id: composition_status
    type: EchoBlock
    inputs:
      message: |
        Level 2 Composition Results:
        - Branch: ${blocks.create_branch.outputs.branch_name} (${blocks.get_branch_status.outputs.stdout})
        - README: ${blocks.generate_readme.readme_path} (${blocks.get_readme_status.outputs.stdout})
    depends_on:
      - get_branch_status
      - get_readme_status

  # Level 3: Run CI pipeline (calls CI workflow which calls Python workflows)
  - id: run_ci_pipeline
    type: Workflow
    inputs:
      workflow: "python-ci-pipeline"
      inputs:
        project_path: "."
        python_version: "3.12"
        skip_setup: true
        coverage_threshold: 75
        strict_linting: false
    depends_on:
      - composition_status
    condition: "${inputs.run_full_pipeline} and ${blocks.create_branch.succeeded}"

  # Level 3: Conditional deployment
  - id: deploy_if_tests_pass
    type: Workflow
    inputs:
      workflow: "conditional-deploy"
      inputs:
        environment: "dev"
        deploy_path: "${inputs.base_path}/deploy"
        run_tests_first: false
        build_artifacts: false
    depends_on:
      - run_ci_pipeline
    condition: "${inputs.run_full_pipeline} and ${blocks.run_ci_pipeline.succeeded}"

  # Get final summary displays
  - id: get_git_branch_display
    type: Shell
    inputs:
      command: "test '${blocks.create_branch.succeeded}' = 'true' && echo '✓ ${blocks.create_branch.outputs.branch_name}' || echo '✗ Failed'"
      timeout: 5

    depends_on:
      - create_branch

  - id: get_readme_display
    type: Shell
    inputs:
      command: "test '${blocks.generate_readme.succeeded}' = 'true' && echo '✓ Generated' || echo '✗ Failed'"
      timeout: 5

    depends_on:
      - generate_readme

  - id: get_ci_pipeline_display_passed
    type: Shell
    inputs:
      command: "echo '✓ Passed'"
      timeout: 5

    condition: "${inputs.run_full_pipeline} and ${blocks.run_ci_pipeline.succeeded}"
    depends_on:
      - run_ci_pipeline

  - id: get_ci_pipeline_display_failed
    type: Shell
    inputs:
      command: "echo '✗ Failed'"
      timeout: 5

    condition: "${inputs.run_full_pipeline} and not ${blocks.run_ci_pipeline.succeeded}"
    depends_on:
      - run_ci_pipeline

  - id: get_ci_pipeline_display_skipped
    type: Shell
    inputs:
      command: "echo '⊘ Skipped'"
      timeout: 5

    condition: "not ${inputs.run_full_pipeline}"
    depends_on:
      - run_ci_pipeline

  - id: get_ci_pipeline_display
    type: Shell
    inputs:
      command: |
        STATUS_PASSED="${blocks.get_ci_pipeline_display_passed.outputs.stdout}"
        STATUS_FAILED="${blocks.get_ci_pipeline_display_failed.outputs.stdout}"
        STATUS_SKIPPED="${blocks.get_ci_pipeline_display_skipped.outputs.stdout}"
        if [ -n "$STATUS_PASSED" ]; then
          echo "$STATUS_PASSED"
        elif [ -n "$STATUS_FAILED" ]; then
          echo "$STATUS_FAILED"
        else
          echo "$STATUS_SKIPPED"
        fi
      timeout: 5

    depends_on:
      - get_ci_pipeline_display_passed
      - get_ci_pipeline_display_failed
      - get_ci_pipeline_display_skipped

  - id: get_deployment_display
    type: Shell
    inputs:
      command: |
        if [ "${inputs.run_full_pipeline}" = "true" ]; then
          if [ "${blocks.deploy_if_tests_pass.deployed}" = "true" ]; then
            echo "✓ Deployed to ${blocks.deploy_if_tests_pass.environment}"
          else
            echo '✗ Failed'
          fi
        else
          echo '⊘ Skipped'
        fi
      timeout: 5

    depends_on:
      - deploy_if_tests_pass

  - id: get_workflows_count
    type: Shell
    inputs:
      command: "test '${inputs.run_full_pipeline}' = 'true' && echo '5' || echo '3'"
      timeout: 5

    depends_on:
      - deploy_if_tests_pass

  - id: get_overall_status_success
    type: Shell
    inputs:
      command: "echo '✓ SUCCESS'"
      timeout: 5

    condition: "${blocks.create_branch.succeeded} and ${blocks.generate_readme.succeeded} and (not ${inputs.run_full_pipeline} or (${blocks.run_ci_pipeline.succeeded} and ${blocks.deploy_if_tests_pass.deployed}))"
    depends_on:
      - get_ci_pipeline_display
      - get_deployment_display

  - id: get_overall_status_partial
    type: Shell
    inputs:
      command: "echo '✗ PARTIAL SUCCESS'"
      timeout: 5

    condition: "not (${blocks.create_branch.succeeded} and ${blocks.generate_readme.succeeded} and (not ${inputs.run_full_pipeline} or (${blocks.run_ci_pipeline.succeeded} and ${blocks.deploy_if_tests_pass.deployed})))"
    depends_on:
      - get_ci_pipeline_display
      - get_deployment_display

  - id: get_overall_status
    type: Shell
    inputs:
      command: |
        STATUS_SUCCESS="${blocks.get_overall_status_success.outputs.stdout}"
        STATUS_PARTIAL="${blocks.get_overall_status_partial.outputs.stdout}"
        if [ -n "$STATUS_SUCCESS" ]; then
          echo "$STATUS_SUCCESS"
        else
          echo "$STATUS_PARTIAL"
        fi
      timeout: 5

    depends_on:
      - get_overall_status_success
      - get_overall_status_partial

  # Final summary across all composition levels
  - id: final_summary
    type: EchoBlock
    inputs:
      message: |
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        Multi-Level Composition Demo Complete
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        Project: ${inputs.project_name}
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        Level 1 (Direct Blocks):
          - Initialization: ✓ Complete

        Level 2 (Workflow Composition):
          - Git Branch: ${blocks.get_git_branch_display.outputs.stdout}
          - README: ${blocks.get_readme_display.outputs.stdout}

        Level 3 (Nested Composition):
          - CI Pipeline: ${blocks.get_ci_pipeline_display.outputs.stdout}
          - Deployment: ${blocks.get_deployment_display.outputs.stdout}
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        Composition Depth: 3 levels
        Workflows Executed: ${blocks.get_workflows_count.outputs.stdout} workflows
        Overall Status: ${blocks.get_overall_status.outputs.stdout}
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    depends_on:
      - get_git_branch_display
      - get_readme_display
      - get_ci_pipeline_display
      - get_deployment_display
      - get_workflows_count
      - get_overall_status

outputs:
  success: "${blocks.create_branch.succeeded} and ${blocks.generate_readme.succeeded}"
  project_name: "${inputs.project_name}"

  # Level 2 outputs
  branch_created: "${blocks.create_branch.succeeded}"
  branch_name: "${blocks.create_branch.outputs.branch_name}"
  readme_generated: "${blocks.generate_readme.succeeded}"
  readme_path: "${blocks.generate_readme.readme_path}"

  # Level 3 outputs (if executed)
  pipeline_executed: "${inputs.run_full_pipeline}"
  pipeline_passed: "${blocks.run_ci_pipeline.succeeded}"
  deployed: "${blocks.deploy_if_tests_pass.deployed}"
  deployment_env: "${blocks.deploy_if_tests_pass.environment}"

  # Summary
  summary: "${blocks.final_summary.outputs.echoed}"
  composition_levels: "3"
  workflows_executed: "${blocks.get_workflows_count.outputs.stdout}"
