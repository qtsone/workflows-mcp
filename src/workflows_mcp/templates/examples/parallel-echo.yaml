# Parallel Echo Workflow (Diamond Pattern)
#
# Demonstrates parallel execution capabilities:
# - Diamond DAG pattern: start → (parallel_a, parallel_b) → final
# - Parallel block execution (parallel_a and parallel_b run simultaneously)
# - Multiple dependencies (final depends on both parallel blocks)
# - Wave detection and concurrent execution
# - Efficient resource utilization through parallelism
#
# Execution flow:
#   Wave 1: start_block (executes alone)
#   Wave 2: parallel_a, parallel_b (execute simultaneously)
#   Wave 3: final_merge (waits for both parallel blocks)
#
# Usage:
#   execute_workflow("parallel-echo")

name: parallel-echo
description: Diamond pattern workflow demonstrating parallel execution
version: "1.0"
author: Workflows MCP Team
tags: [example, tutorial, parallel, diamond, concurrency, waves]
# Starting message input
inputs:
  start_message:
    type: str
    description: Initial message to branch from
    default: "Start of parallel workflow"

blocks:
  # Initial block - single entry point
  - id: start_block
    type: EchoBlock
    inputs:
      message: "${inputs.start_message}"
      delay_ms: 100
    # No dependencies - executes in Wave 1

  # Parallel branch A - depends only on start_block
  - id: parallel_a
    type: EchoBlock
    inputs:
      message: "Branch A: ${blocks.start_block.outputs.echoed}"
      delay_ms: 200 # Simulates different execution times
    depends_on:
      - start_block
    # Executes in Wave 2 (parallel with parallel_b)

  # Parallel branch B - depends only on start_block
  - id: parallel_b
    type: EchoBlock
    inputs:
      message: "Branch B: ${blocks.start_block.outputs.echoed}"
      delay_ms: 150 # Different delay from parallel_a
    depends_on:
      - start_block
    # Executes in Wave 2 (parallel with parallel_a)

  # Final merge block - depends on BOTH parallel blocks
  - id: final_merge
    type: EchoBlock
    inputs:
      # Combines outputs from both parallel branches
      message: "Merged: ${blocks.parallel_a.outputs.echoed} + ${blocks.parallel_b.outputs.echoed}"
      delay_ms: 100
    depends_on:
      - parallel_a # Must wait for branch A
      - parallel_b # Must wait for branch B
    # Executes in Wave 3 (after both branches complete)

# Outputs from all stages
outputs:
  start_output: "${blocks.start_block.outputs.echoed}"
  branch_a_output: "${blocks.parallel_a.outputs.echoed}"
  branch_b_output: "${blocks.parallel_b.outputs.echoed}"
  final_output: "${blocks.final_merge.outputs.echoed}"
  # Total execution time should be less than sum of all delays
  # due to parallel execution
  merge_time_ms: "${blocks.final_merge.metadata.execution_time_ms}"
