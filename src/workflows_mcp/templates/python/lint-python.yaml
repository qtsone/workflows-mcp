name: lint-python
description: Run comprehensive Python code quality checks (ruff, mypy, formatting) (supports auto-install)
version: "1.0"
author: Workflows MCP Team
tags: [python, linting, ruff, mypy, code-quality, static-analysis]

inputs:
  working_dir:
    type: str
    description: Project directory to lint
    default: "."

  src_path:
    type: str
    description: Source code directory or file path
    default: "src/"

  strict_mode:
    type: bool
    description: Enable strict type checking (mypy --strict)
    default: false

  fix_issues:
    type: bool
    description: Auto-fix issues where possible (ruff --fix and ruff format)
    default: false

  skip_mypy:
    type: bool
    description: Skip mypy type checking
    default: false

  venv_path:
    type: str
    description: Virtual environment path (will use {{inputs.venv_path}}/bin/ruff and {{inputs.venv_path}}/bin/mypy if available)
    default: ""

  auto_install:
    type: bool
    description: Automatically install ruff and mypy if not found
    default: true

blocks:
  # Ensure ruff is installed (only if auto_install is enabled)
  - id: ensure_ruff
    type: Workflow
    inputs:
      workflow: ensure-tool
      inputs:
        tool_name: ruff
        tool_type: python_package
        version: ""
        venv_path: "{{inputs.venv_path}}"
        auto_install: true
    condition: "{{inputs.auto_install}}"

  # Ensure mypy is installed (only if auto_install is enabled and skip_mypy is false)
  - id: ensure_mypy
    type: Workflow
    inputs:
      workflow: ensure-tool
      inputs:
        tool_name: mypy
        tool_type: python_package
        version: ""
        venv_path: "{{inputs.venv_path}}"
        auto_install: true
    condition: "{{inputs.auto_install}} and not {{inputs.skip_mypy}}"

  # Build ruff command
  - id: build_ruff_command
    type: Shell
    inputs:
      command: |
        # Determine ruff executable path (prefer venv if available)
        if [ -n "{{inputs.venv_path}}" ] && [ -f "{{inputs.venv_path}}/bin/ruff" ]; then
          RUFF="{{inputs.venv_path}}/bin/ruff"
        else
          RUFF="ruff"
        fi

        # Build command with options
        CMD="$RUFF check"
        if [ "{{inputs.fix_issues}}" = "true" ]; then
          CMD="$CMD --fix"
        fi
        CMD="$CMD {{inputs.src_path}}"
        echo "$CMD"
      timeout: 5

  # Run ruff linting
  - id: run_ruff
    type: Shell
    inputs:
      command: "{{blocks.build_ruff_command.outputs.stdout}}"
      working_dir: "{{inputs.working_dir}}"
      timeout: 300
      
    depends_on:
      - build_ruff_command

  # Build mypy command
  - id: build_mypy_command
    type: Shell
    inputs:
      command: |
        # Determine mypy executable path (prefer venv if available)
        if [ -n "{{inputs.venv_path}}" ] && [ -f "{{inputs.venv_path}}/bin/mypy" ]; then
          MYPY="{{inputs.venv_path}}/bin/mypy"
        else
          MYPY="mypy"
        fi

        # Build command with options
        CMD="$MYPY"
        if [ "{{inputs.strict_mode}}" = "true" ]; then
          CMD="$CMD --strict"
        fi
        CMD="$CMD {{inputs.src_path}}"
        echo "$CMD"
      timeout: 5
    depends_on:
      - run_ruff

  # Run mypy type checking
  - id: run_mypy
    type: Shell
    inputs:
      command: "{{blocks.build_mypy_command.outputs.stdout}}"
      working_dir: "{{inputs.working_dir}}"
      timeout: 300
      
    depends_on:
      - build_mypy_command
    condition: "not {{inputs.skip_mypy}}"

  # Check or fix formatting with ruff format
  - id: check_format
    type: Shell
    inputs:
      command: |
        # Determine ruff executable path (prefer venv if available)
        if [ -n "{{inputs.venv_path}}" ] && [ -f "{{inputs.venv_path}}/bin/ruff" ]; then
          RUFF="{{inputs.venv_path}}/bin/ruff"
        else
          RUFF="ruff"
        fi

        # Apply fixes or just check based on fix_issues flag
        if [ "{{inputs.fix_issues}}" = "true" ]; then
          $RUFF format {{inputs.src_path}}
        else
          $RUFF format --check {{inputs.src_path}}
        fi
      working_dir: "{{inputs.working_dir}}"
      timeout: 300
      
    depends_on:
      - run_ruff

  # Determine result statuses
  - id: get_ruff_status
    type: Shell
    inputs:
      command: "test {{blocks.run_ruff.outputs.exit_code}} -eq 0 && echo '✓ PASSED' || echo '✗ FAILED'"
      timeout: 5
      
    depends_on:
      - run_ruff

  - id: get_mypy_status
    type: Shell
    inputs:
      command: "test {{blocks.run_mypy.outputs.exit_code}} -eq 0 && echo '✓ PASSED' || echo '✗ FAILED'"
      timeout: 5
      
    depends_on:
      - run_mypy
    condition: "not {{inputs.skip_mypy}}"

  - id: get_format_status
    type: Shell
    inputs:
      command: "test {{blocks.check_format.outputs.exit_code}} -eq 0 && echo '✓ PASSED' || echo '✗ FAILED'"
      timeout: 5
      
    depends_on:
      - check_format

  # Generate mypy status display
  - id: get_mypy_display
    type: Shell
    inputs:
      command: |
        if [ "{{inputs.skip_mypy}}" = "true" ]; then
          echo '⊘ SKIPPED'
        else
          test {{blocks.run_mypy.outputs.exit_code}} -eq 0 && echo '✓ PASSED' || echo '✗ FAILED'
        fi
      timeout: 5
      
    depends_on:
      - get_mypy_status

  - id: get_overall_status
    type: Shell
    inputs:
      command: |
        if [ {{blocks.run_ruff.outputs.exit_code}} -eq 0 ] && \
           ([ "{{inputs.skip_mypy}}" = "true" ] || [ {{blocks.run_mypy.outputs.exit_code}} -eq 0 ]) && \
           [ {{blocks.check_format.outputs.exit_code}} -eq 0 ]; then
          echo '✓ ALL PASSED'
        else
          echo '✗ ISSUES FOUND'
        fi
      timeout: 5
      
    depends_on:
      - get_ruff_status
      - get_mypy_display
      - get_format_status

  # Aggregate results
  - id: aggregate_results
    type: Shell
    inputs:
      command: |
        printf "Code Quality Results:\n"
        printf "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
        printf "Ruff Linting:  {{blocks.get_ruff_status.outputs.stdout}}\n"
        printf "Mypy:          {{blocks.get_mypy_display.outputs.stdout}}\n"
        printf "Formatting:    {{blocks.get_format_status.outputs.stdout}}\n"
        printf "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
        printf "Overall: {{blocks.get_overall_status.outputs.stdout}}"
    depends_on:
      - get_overall_status

outputs:
  # Individual tool results
  ruff_passed: "{{blocks.run_ruff.outputs.exit_code}} == 0"
  ruff_output: "{{blocks.run_ruff.outputs.stdout}}"
  ruff_errors: "{{blocks.run_ruff.outputs.stderr}}"

  mypy_passed: "{{inputs.skip_mypy}} or {{blocks.run_mypy.outputs.exit_code}} == 0"
  mypy_output: "{{blocks.run_mypy.outputs.stdout}}"
  mypy_errors: "{{blocks.run_mypy.outputs.stderr}}"

  format_passed: "{{blocks.check_format.outputs.exit_code}} == 0"
  format_output: "{{blocks.check_format.outputs.stdout}}"

  # Overall status
  all_passed: "{{blocks.run_ruff.outputs.exit_code}} == 0 and ({{inputs.skip_mypy}} or {{blocks.run_mypy.outputs.exit_code}} == 0) and {{blocks.check_format.outputs.exit_code}} == 0"
  summary: "{{blocks.aggregate_results.outputs.stdout}}"

  # Execution metadata
  total_execution_time_ms: "{{blocks.aggregate_results.metadata.execution_time_ms}}"
