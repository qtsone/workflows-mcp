# TDD Phase 2: Architecture & Design
#
# Designs system architecture, defines modules, plans test strategy.
#
# This phase transforms the technical specification from Phase 1 into a concrete
# system architecture with well-defined modules, interfaces, and test strategy.
# It enforces architectural thinking before implementation begins.
#
# Philosophy: Know HOW to build before writing code.
#
# Key Activities:
# 1. Read technical specification from Phase 1
# 2. Design high-level system architecture
# 3. Define data models and schemas
# 4. Identify modules and their responsibilities
# 5. Define module interfaces and APIs
# 6. Plan comprehensive test strategy (unit, integration, E2E)
# 7. Document architecture decisions
# 8. Checkpoint review for architecture approval
#
# State Management:
# - Verifies Phase 1 complete before starting
# - Stores module list, architecture decisions
# - Updates state with Phase 2 completion
# - Enables resumability and progress tracking
#
# Interactive Pauses:
# - LLM designs system architecture
# - LLM defines data models
# - LLM identifies modules
# - LLM defines module interfaces
# - LLM plans test strategy
# - Final checkpoint for approval
#
# Usage:
#   execute_workflow("tdd-phase2-architecture", {
#     "project_path": "/path/to/project"
#   })
#
# Output:
#   - ARCHITECTURE.md created in project root
#   - State updated with module list and phase completion
#   - Ready to proceed to Phase 3 (Scaffolding)

name: tdd-phase2-architecture
description: TDD Phase 2 - Design system architecture, define modules, plan test strategy
version: "1.0"
author: MCP Workflows Team
tags: [tdd, architecture, design, modules, setup, phase2]

inputs:
  project_path:
    type: str
    description: Path to project root directory
    default: "."
    required: false

  state_file:
    type: str
    description: Path to TDD state file (JSON) relative to project_path
    default: ".tdd-state.json"
    required: false

  spec_path:
    type: str
    description: Path to technical specification from Phase 1
    default: "TECHNICAL_SPEC.md"
    required: false

  architecture_output_path:
    type: str
    description: Path for architecture document output
    default: "ARCHITECTURE.md"
    required: false

blocks:
  - id: read_state
    type: ReadJSONState
    inputs:
      path: "${inputs.project_path}/${inputs.state_file}"

  - id: validate_phase1_complete
    type: Shell
    inputs:
      command: |
        STATE_FOUND="${blocks.read_state.outputs.found}"
        if [ "$STATE_FOUND" != "true" ]; then
          echo "❌ ERROR: TDD state file not found"
          echo "Please complete Phase 1 (Analysis) first"
          exit 1
        fi

        # Check if phase1 is in completed phases (would need to parse JSON)
        # For now, check if state file exists and has content
        echo "✅ TDD state found - proceeding with Phase 2"
        exit 0
      timeout: 10
    depends_on:
      - read_state

  - id: validate_spec_exists
    type: Shell
    inputs:
      command: |
        if [ ! -f "${inputs.project_path}/${inputs.spec_path}" ]; then
          echo "❌ ERROR: Technical specification not found at: ${inputs.project_path}/${inputs.spec_path}"
          echo "Please complete Phase 1 (Analysis) to generate technical specification"
          exit 1
        else
          echo "✅ Technical specification found: ${inputs.project_path}/${inputs.spec_path}"
          exit 0
        fi
      timeout: 10
    depends_on:
      - validate_phase1_complete

  - id: design_architecture
    type: Prompt
    inputs:
      prompt: |
        === PHASE 2: SYSTEM ARCHITECTURE DESIGN ===

        Read and analyze the Technical Specification at: @${inputs.project_path}/${inputs.spec_path}

        Task: Design the high-level system architecture.

        Create an architectural design covering:

        1. **System Overview**
           - High-level architecture pattern (monolith, microservices, layered, etc)
           - Key architectural components and their interactions
           - Technology stack recommendations

        2. **Architecture Diagram** (text/ASCII representation)
           - Component relationships
           - Data flow
           - External integrations

        3. **Architectural Patterns**
           - Design patterns to be used (MVC, Repository, Factory, etc)
           - Rationale for pattern selection

        4. **Scalability & Performance**
           - How the architecture supports scalability requirements
           - Performance considerations

        5. **Security Architecture**
           - Authentication/authorization approach
           - Data protection strategy
           - Security boundaries

        Provide a comprehensive architectural design document.
    depends_on:
      - validate_spec_exists

  - id: define_data_models
    type: Prompt
    inputs:
      prompt: |
        === DEFINE DATA MODELS & SCHEMAS ===

        Based on the requirements and architecture design:
        ${blocks.design_architecture.response}

        Task: Define all data models and schemas needed for the system.

        For each data model, specify:
        1. **Model Name** (e.g., User, Task, Project)
        2. **Fields** with types (string, integer, boolean, etc)
        3. **Relationships** (one-to-many, many-to-many)
        4. **Constraints** (required, unique, validation rules)
        5. **Indexes** (for query performance)

        Example format:
        ```
        Model: User
        Fields:
          - id: UUID (primary key)
          - email: string (unique, required, email format)
          - password_hash: string (required)
          - created_at: datetime (auto)
        Relationships:
          - has_many: Task
        Constraints:
          - email must be unique
          - password min 8 chars
        Indexes:
          - email (unique index)
        ```

        Define ALL data models needed for the system.
    depends_on:
      - design_architecture

  - id: identify_modules
    type: Prompt
    inputs:
      prompt: |
        === IDENTIFY MODULES & RESPONSIBILITIES ===

        Architecture:
        ${blocks.design_architecture.response}

        Data Models:
        ${blocks.define_data_models.response}

        Task: Identify all modules/components and their responsibilities.

        For each module, specify:
        1. **Module Name** (e.g., user_service, auth_service, task_repository)
        2. **Responsibility** (single responsibility principle)
        3. **Dependencies** (what other modules it depends on)
        4. **Complexity** (simple/moderate/complex)

        Example format:
        ```
        Module: user_service
        Responsibility: User account management (create, update, delete, authenticate)
        Dependencies: user_repository, email_service, password_hasher
        Complexity: moderate
        ```

        Important:
        - Each module should have ONE clear responsibility
        - Minimize inter-module dependencies
        - List modules in dependency order (foundational first)

        Provide a complete list of ALL modules needed.
        
        Respond with 'yes' or 'no'
    depends_on:
      - define_data_models

  - id: define_interfaces
    type: Prompt
    inputs:
      prompt: |
        === DEFINE MODULE INTERFACES & APIs ===

        Modules identified:
        ${blocks.identify_modules.response}

        Task: Define the interface/API for each module.

        For each module, specify:
        1. **Public Functions/Methods**
           - Function signature (name, parameters, return type)
           - Purpose and behavior
           - Error conditions

        2. **Input Validation**
           - What validation is performed
           - Error handling strategy

        3. **Side Effects**
           - Database operations
           - External API calls
           - File system operations

        Example format:
        ```
        Module: user_service

        def create_user(email: str, password: str) -> User:
            """
            Create new user account.

            Args:
                email: Valid email address (validated)
                password: Min 8 chars (validated)

            Returns:
                User object with generated ID

            Raises:
                ValidationError: Invalid email or password
                DuplicateError: Email already exists

            Side Effects:
                - Creates database record
                - Sends welcome email
            """
        ```

        Define interfaces for ALL modules.
    depends_on:
      - identify_modules

  - id: plan_test_strategy
    type: Prompt
    inputs:
      prompt: |
        === PLAN COMPREHENSIVE TEST STRATEGY ===

        System architecture and modules:
        ${blocks.identify_modules.response}

        Task: Plan a comprehensive test strategy covering unit, integration, and E2E tests.

        Structure:

        1. **Unit Testing Strategy**
           - What to test at unit level (per module)
           - Mocking strategy (dependencies to mock)
           - Coverage goals (80%+ per module)
           - Test framework and tools

        2. **Integration Testing Strategy**
           - What to test at integration level (module interactions)
           - Test database strategy (fixtures, factories)
           - Integration test scope
           - Coverage goals

        3. **E2E Testing Strategy**
           - User workflows to test end-to-end
           - Test data setup strategy
           - External dependencies (mocked or real)
           - Success criteria

        4. **Test Organization**
           - Directory structure (tests/, conftest.py, fixtures)
           - Naming conventions
           - Test execution order

        5. **Quality Gates**
           - Minimum coverage percentage (80%)
           - Required test types before deployment
           - Performance test requirements

        Provide a complete test strategy document.
        
        Respond with 'yes' or 'no'
    depends_on:
      - define_interfaces

  - id: document_architecture
    type: Prompt
    inputs:
      prompt: |
        === CREATE ARCHITECTURE DOCUMENT ===

        Combine all architectural design work into a comprehensive document:

        1. Architecture Design:
        ${blocks.design_architecture.response}

        2. Data Models:
        ${blocks.define_data_models.response}

        3. Modules:
        ${blocks.identify_modules.response}

        4. Interfaces:
        ${blocks.define_interfaces.response}

        5. Test Strategy:
        ${blocks.plan_test_strategy.response}

        Create a well-structured architecture document with these sections:

        # System Architecture

        ## 1. Overview
        [High-level architecture description and diagram]

        ## 2. Architecture Patterns
        [Design patterns and rationale]

        ## 3. Data Models
        [Complete data model definitions]

        ## 4. Module Design
        [Module responsibilities and dependencies]

        ## 5. Module Interfaces
        [API definitions for each module]

        ## 6. Test Strategy
        [Comprehensive test planning]

        ## 7. Architecture Decisions (ADRs)
        [Key decisions and rationale]

        ## 8. Deployment Architecture
        [How the system will be deployed]

        ## 9. Non-Functional Requirements
        [Performance, security, scalability]

        Provide the COMPLETE architecture document content.
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
    depends_on:
      - plan_test_strategy

  - id: create_architecture_file
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/${inputs.architecture_output_path}"
      content: "${blocks.document_architecture.response}"
      encoding: "utf-8"
    depends_on:
      - document_architecture

  - id: extract_modules
    type: Shell
    inputs:
      command: |
        ARCH_FILE="${inputs.project_path}/${inputs.architecture_output_path}"

        if [ ! -f "$ARCH_FILE" ]; then
          echo "0" > "$SCRATCH/module_count.txt"
          echo "" > "$SCRATCH/modules_list.txt"
          exit 1
        fi

        # Count modules by looking for "Module:" lines in the document
        MODULE_COUNT=$(grep -c "^Module:" "$ARCH_FILE" || echo "0")

        # Extract module names
        MODULES=$(grep "^Module:" "$ARCH_FILE" | sed 's/Module: //' | tr '\n' ',' | sed 's/,$//')

        echo "$MODULE_COUNT" > "$SCRATCH/module_count.txt"
        echo "$MODULES" > "$SCRATCH/modules_list.txt"
        echo "✅ Identified $MODULE_COUNT modules"
      timeout: 30
    outputs:
      module_count:
        type: int
        path: "$SCRATCH/module_count.txt"
        description: "Number of modules identified in architecture"
      modules_list:
        type: str
        path: "$SCRATCH/modules_list.txt"
        description: "Comma-separated list of module names"
    depends_on:
      - create_architecture_file

  - id: update_state_phase2_complete
    type: Shell
    inputs:
      command: |
        # Parse module data
        MODULE_COUNT="${blocks.extract_modules.outputs.module_count}"
        MODULES_LIST="${blocks.extract_modules.outputs.modules_list}"

        # Create Python script to update state
        cat > /tmp/update_tdd_state_phase2.py << 'PYTHON_SCRIPT'
        import json
        import sys
        from pathlib import Path
        from datetime import datetime

        # Get arguments
        state_file = Path(sys.argv[1])
        arch_path = sys.argv[2]
        module_count = int(sys.argv[3]) if sys.argv[3] else 0
        modules_list = sys.argv[4] if len(sys.argv) > 4 else ""

        # Read existing state
        if state_file.exists():
            state = json.loads(state_file.read_text())
        else:
            state = {}

        # Update state for Phase 2 completion
        if 'phases_completed' not in state:
            state['phases_completed'] = []
        if 'phase2' not in state['phases_completed']:
            state['phases_completed'].append('phase2')

        state['current_phase'] = 'phase2_complete'
        state['phase2'] = {
            'architecture_path': arch_path,
            'module_count': module_count,
            'modules': modules_list.split(',') if modules_list else [],
            'completed_at': datetime.now().isoformat(),
            'test_strategy_defined': True
        }

        # Also store modules at root level for Phase 4 iteration
        state['modules'] = modules_list.split(',') if modules_list else []
        state['completed_modules'] = []

        # Write back
        state_file.parent.mkdir(parents=True, exist_ok=True)
        state_file.write_text(json.dumps(state, indent=2) + '\n')

        print(f'✅ Phase 2 complete: {module_count} modules defined')
        print(f'   Architecture: {arch_path}')
        PYTHON_SCRIPT

        # Run the Python script
        python3 /tmp/update_tdd_state_phase2.py \
          "${inputs.project_path}/${inputs.state_file}" \
          "${inputs.architecture_output_path}" \
          "$MODULE_COUNT" \
          "$MODULES_LIST"
      timeout: 30
    depends_on:
      - extract_modules

  - id: checkpoint_review
    type: Prompt
    inputs:
      prompt: |
        === PHASE 2 ARCHITECTURE COMPLETE ===

        Architecture document created:
        - Path: ${inputs.project_path}/${inputs.architecture_output_path}
        - Modules identified: ${blocks.extract_modules.outputs.module_count}
        - Test strategy defined: Yes

        Review checkpoint:
        1. Is the architecture sound and scalable?
        2. Are all modules clearly defined with single responsibilities?
        3. Are module interfaces well-defined?
        4. Is the test strategy comprehensive?
        5. Are architectural decisions documented?

        Approve to proceed to Phase 3 (Scaffolding)?
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
      operation: "approve_phase2_complete"
      details:
        architecture_path: "${inputs.project_path}/${inputs.architecture_output_path}"
        module_info: "${blocks.extract_modules.outputs.modules_list}"
        state_updated: "true"
    depends_on:
      - update_state_phase2_complete

  - id: completion_summary
    type: Shell
    inputs:
      command: |
        echo "╔════════════════════════════════════════════════════════════════╗"
        echo "║           TDD PHASE 2: ARCHITECTURE COMPLETE                  ║"
        echo "╚════════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Phase 2 Results:"
        echo "  ✅ System architecture designed"
        echo "  ✅ Data models defined"
        echo "  ✅ Modules identified and scoped"
        echo "  ✅ Module interfaces defined"
        echo "  ✅ Test strategy planned"
        echo "  ✅ Architecture document created"
        echo ""
        echo "Output:"
        echo "  📐 Architecture: ${inputs.project_path}/${inputs.architecture_output_path}"
        echo "  🧩 Modules: ${blocks.extract_modules.outputs.modules_list}"
        echo "  💾 State File: ${inputs.project_path}/${inputs.state_file}"
        echo ""
        echo "Next Phase: Scaffolding (Phase 3)"
        echo "  Run: execute_workflow('tdd-phase3-scaffolding', {'project_path': '${inputs.project_path}'})"
        echo ""
        echo "Checkpoint Approved: ${blocks.checkpoint_review.outputs.response == 'yes'}"
      timeout: 10
    depends_on:
      - checkpoint_review

outputs:
  phase_complete: "${blocks.checkpoint_review.outputs.response == 'yes'}"
  architecture_path: "${inputs.project_path}/${inputs.architecture_output_path}"
  modules: "${blocks.extract_modules.outputs.modules_list}"
  module_count: "${blocks.extract_modules.outputs.module_count}"
  test_strategy_defined: "true"
  checkpoint_approved: "${blocks.checkpoint_review.outputs.response == 'yes'}"

  # State tracking
  state_file_path: "${inputs.project_path}/${inputs.state_file}"

  # Architecture outputs
  system_architecture: "${blocks.design_architecture.response}"
  data_models: "${blocks.define_data_models.response}"
  module_definitions: "${blocks.identify_modules.response}"
  module_interfaces: "${blocks.define_interfaces.response}"
  test_strategy: "${blocks.plan_test_strategy.response}"

  # Summary
  summary: "${blocks.completion_summary.outputs.stdout}"

  # Next phase readiness
  ready_for_phase3: "${blocks.checkpoint_review.outputs.response == 'yes'}"
