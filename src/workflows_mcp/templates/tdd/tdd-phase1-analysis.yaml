# TDD Phase 1: Analysis & Specification
#
# Parses PRD requirements, identifies ambiguities, creates technical specification.
#
# This phase transforms a Product Requirements Document (PRD) into a clear,
# unambiguous technical specification that can guide implementation. It enforces
# thorough upfront analysis to prevent implementation drift and missed requirements.
#
# Philosophy: Understand WHAT to build before HOW to build it.
#
# Key Activities:
# 1. Read and parse PRD document
# 2. Identify ambiguities, gaps, and unclear requirements
# 3. Request clarifications through interactive prompts
# 4. Define measurable success criteria for each requirement
# 5. Identify technical constraints (performance, security, compatibility)
# 6. Create comprehensive technical specification document
# 7. Checkpoint review for stakeholder approval
#
# State Management:
# - Initializes .tdd-state.json if doesn't exist
# - Stores requirements list, ambiguities resolved, and phase completion
# - Enables resumability and progress tracking
#
# Interactive Pauses:
# - LLM identifies ambiguities in PRD
# - Confirm if clarification needed (loop if yes)
# - LLM defines success criteria
# - LLM identifies constraints
# - LLM writes technical specification
# - Final checkpoint for approval
#
# Usage:
#   execute_workflow("tdd-phase1-analysis", {
#     "project_path": "/path/to/project",
#     "prd_path": "PRD.md"
#   })
#
# Output:
#   - TECHNICAL_SPEC.md created in project root
#   - State updated with requirements count and phase completion
#   - Ready to proceed to Phase 2 (Architecture & Design)

name: tdd-phase1-analysis
description: TDD Phase 1 - Parse PRD, resolve ambiguities, create technical specification
version: "1.0"
author: MCP Workflows Team
tags: [tdd, analysis, specification, requirements, setup, phase1]

inputs:
  project_path:
    type: str
    description: Path to project root directory
    default: "."
    required: false

  state_file:
    type: str
    description: Path to TDD state file (JSON) relative to project_path
    default: ".tdd-state.json"
    required: false

  prd_path:
    type: str
    description: Path to PRD document relative to project_path
    default: "PRD.md"
    required: false

  spec_output_path:
    type: str
    description: Path for technical specification output relative to project_path
    default: "TECHNICAL_SPEC.md"
    required: false

blocks:
  - id: read_initial_state
    type: ReadJSONState
    inputs:
      path: "${inputs.project_path}/${inputs.state_file}"

  - id: initialize_state
    type: WriteJSONState
    inputs:
      path: "${inputs.project_path}/${inputs.state_file}"
      state:
        workflow_version: "1.0"
        created_at: ""
        current_phase: "phase1_started"
        phases_completed: []
    depends_on:
      - read_initial_state
    condition: "not ${blocks.read_initial_state.outputs.found}"

  - id: validate_prd_exists
    type: Shell
    inputs:
      command: |
        if [ ! -f "${inputs.project_path}/${inputs.prd_path}" ]; then
          echo "❌ ERROR: PRD not found at: ${inputs.project_path}/${inputs.prd_path}"
          echo "Please create a PRD document before running Phase 1 analysis."
          exit 1
        else
          echo "✅ PRD found: ${inputs.project_path}/${inputs.prd_path}"
          exit 0
        fi
      timeout: 10
    depends_on:
      - read_initial_state

  - id: identify_ambiguities
    type: Prompt
    inputs:
      prompt: |
        === PHASE 1: REQUIREMENTS ANALYSIS ===

        Read and analyze the PRD document at: @${inputs.project_path}/${inputs.prd_path}

        Task: Analyze this PRD and identify ALL ambiguities, gaps, and unclear requirements.

        For each ambiguity, provide:
        1. Section/requirement reference
        2. What is ambiguous or unclear
        3. What information is needed to resolve it
        4. Impact if not clarified (low/medium/high)

        Format your response as a structured list of ambiguities.
        If the PRD is clear and complete, respond with: "NO_AMBIGUITIES"
        
        Respond with 'yes' or 'no'
    depends_on:
      - validate_prd_exists

  - id: check_clarifications_needed
    type: Shell
    inputs:
      command: |
        RESPONSE="${blocks.identify_ambiguities.outputs.response}"

        if echo "$RESPONSE" | grep -q "NO_AMBIGUITIES"; then
          echo "false" > "$SCRATCH/clarifications_needed.txt"
          echo "✅ No ambiguities identified - PRD is clear"
        else
          echo "true" > "$SCRATCH/clarifications_needed.txt"
          echo "⚠️  Ambiguities identified - clarifications required"
        fi
      timeout: 10
    outputs:
      clarifications_needed:
        type: bool
        path: "$SCRATCH/clarifications_needed.txt"
        description: "Whether clarifications are needed for PRD ambiguities"
    depends_on:
      - identify_ambiguities

  - id: confirm_need_clarification
    type: Prompt
    inputs:
      prompt: |
        Ambiguities identified in PRD:
        ${blocks.identify_ambiguities.outputs.response}

        Do you need to provide clarifications before proceeding?
        
        Respond with 'yes' or 'no'
      operation: "request_prd_clarifications"
      details:
        ambiguities: "${blocks.identify_ambiguities.outputs.response}"
        prd_path: "${inputs.project_path}/${inputs.prd_path}"
    depends_on:
      - check_clarifications_needed
    condition: "${blocks.check_clarifications_needed.outputs.clarifications_needed}"

  - id: get_clarifications
    type: Prompt
    inputs:
      prompt: |
        Please provide clarifications for the identified ambiguities:

        ${blocks.identify_ambiguities.outputs.response}

        For each ambiguity, provide clear answers and additional context.
        This will be incorporated into the technical specification.
    depends_on:
      - confirm_need_clarification
    condition: "${blocks.check_clarifications_needed.outputs.clarifications_needed}"

  - id: define_success_criteria
    type: Prompt
    inputs:
      prompt: |
        === DEFINE SUCCESS CRITERIA ===

        Read the PRD document at: @${inputs.project_path}/${inputs.prd_path}

        For each major requirement in the PRD, define MEASURABLE success criteria.

        Success criteria should be:
        1. Specific and measurable (numbers, metrics, behavior)
        2. Testable (can be verified with a test)
        3. Complete (covers all aspects of the requirement)

        Example format:
        - Requirement: User authentication
          Success Criteria:
          * Users can register with email/password
          * Password must be 8+ characters with special characters
          * Failed login attempts locked after 5 tries
          * Session expires after 24 hours of inactivity

        Provide success criteria for ALL requirements.
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
    depends_on:
      - check_clarifications_needed

  - id: identify_constraints
    type: Prompt
    inputs:
      prompt: |
        === IDENTIFY TECHNICAL CONSTRAINTS ===

        Based on the PRD, identify all technical constraints:

        1. Performance constraints (response times, throughput, concurrency)
        2. Security constraints (authentication, authorization, data protection)
        3. Compatibility constraints (browsers, platforms, APIs)
        4. Scalability constraints (users, data volume, growth)
        5. Operational constraints (deployment, monitoring, maintenance)
        6. Compliance constraints (GDPR, HIPAA, industry standards)

        For each constraint, specify:
        - Category (performance/security/compatibility/etc)
        - Specific requirement (e.g., "API response < 200ms for 95th percentile")
        - Rationale (why this constraint exists)
        - Priority (must-have / should-have / nice-to-have)
    depends_on:
      - define_success_criteria

  - id: write_technical_spec
    type: Prompt
    inputs:
      prompt: |
        === CREATE TECHNICAL SPECIFICATION ===

        Write a comprehensive technical specification document incorporating:

        1. PRD Summary
        Reference the PRD at: @${inputs.project_path}/${inputs.prd_path}

        2. Ambiguities Identified and Clarifications
        ${blocks.identify_ambiguities.outputs.response}

        3. Success Criteria
        ${blocks.define_success_criteria.outputs.response}

        4. Technical Constraints
        ${blocks.identify_constraints.outputs.response}

        Structure the specification as follows:

        # Technical Specification

        ## 1. Overview
        [Summary of what we're building and why]

        ## 2. Requirements
        [Detailed requirements with unique IDs (REQ-001, REQ-002, etc)]

        ## 3. Success Criteria
        [Measurable criteria for each requirement]

        ## 4. Technical Constraints
        [Performance, security, compatibility, etc]

        ## 5. Assumptions & Dependencies
        [What we're assuming and what we depend on]

        ## 6. Out of Scope
        [Explicitly what we're NOT building]

        ## 7. Open Questions
        [Any remaining uncertainties to be resolved in Phase 2]

        Provide the COMPLETE technical specification content.
        
        Respond with 'yes' or 'no'
    depends_on:
      - identify_constraints

  - id: create_spec_file
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/${inputs.spec_output_path}"
      content: "${blocks.write_technical_spec.outputs.response}"
      encoding: "utf-8"
    depends_on:
      - write_technical_spec

  - id: count_requirements
    type: Shell
    inputs:
      command: |
        # Count requirements by looking for REQ- prefixed IDs in the spec
        SPEC_FILE="${inputs.project_path}/${inputs.spec_output_path}"

        if [ ! -f "$SPEC_FILE" ]; then
          echo "0" > "$SCRATCH/requirements_count.txt"
          exit 1
        fi

        # Count unique REQ-XXX identifiers
        COUNT=$(grep -o 'REQ-[0-9]\+' "$SPEC_FILE" | sort -u | wc -l | tr -d ' ')

        echo "$COUNT" > "$SCRATCH/requirements_count.txt"
        echo "✅ Identified $COUNT unique requirements"
      timeout: 30
    outputs:
      requirements_count:
        type: int
        path: "$SCRATCH/requirements_count.txt"
        description: "Number of unique requirements identified in technical specification"
    depends_on:
      - create_spec_file

  - id: extract_requirements
    type: Shell
    inputs:
      command: |
        SPEC_FILE="${inputs.project_path}/${inputs.spec_output_path}"

        # Extract all REQ-XXX identifiers
        REQUIREMENTS=$(grep -o 'REQ-[0-9]\+' "$SPEC_FILE" | sort -u | tr '\n' ',' | sed 's/,$//')

        echo "$REQUIREMENTS" > "$SCRATCH/requirements_list.txt"
      timeout: 30
    outputs:
      requirements_list:
        type: str
        path: "$SCRATCH/requirements_list.txt"
        description: "Comma-separated list of requirement identifiers"
    depends_on:
      - count_requirements

  - id: update_state_phase1_complete
    type: Shell
    inputs:
      command: |
        # Parse requirements count
        REQ_COUNT="${blocks.count_requirements.outputs.requirements_count}"
        REQ_LIST="${blocks.extract_requirements.outputs.requirements_list}"

        # Create Python script to update state
        cat > /tmp/update_tdd_state_phase1.py << 'PYTHON_SCRIPT'
        import json
        import sys
        from pathlib import Path
        from datetime import datetime

        # Get arguments
        state_file = Path(sys.argv[1])
        spec_path = sys.argv[2]
        req_count = int(sys.argv[3]) if sys.argv[3] else 0
        req_list = sys.argv[4] if len(sys.argv) > 4 else ""

        # Read existing state
        if state_file.exists():
            state = json.loads(state_file.read_text())
        else:
            state = {}

        # Update state for Phase 1 completion
        if 'phases_completed' not in state:
            state['phases_completed'] = []
        if 'phase1' not in state['phases_completed']:
            state['phases_completed'].append('phase1')

        state['current_phase'] = 'phase1_complete'
        state['phase1'] = {
            'technical_spec_path': spec_path,
            'requirements_count': req_count,
            'requirements_list': req_list.split(',') if req_list else [],
            'completed_at': datetime.now().isoformat(),
            'ambiguities_resolved': True
        }

        # Write back
        state_file.parent.mkdir(parents=True, exist_ok=True)
        state_file.write_text(json.dumps(state, indent=2) + '\n')

        print(f'✅ Phase 1 complete: {req_count} requirements identified')
        print(f'   Technical spec: {spec_path}')
        PYTHON_SCRIPT

        # Run the Python script
        python3 /tmp/update_tdd_state_phase1.py \
          "${inputs.project_path}/${inputs.state_file}" \
          "${inputs.spec_output_path}" \
          "$REQ_COUNT" \
          "$REQ_LIST"
      timeout: 30
    depends_on:
      - extract_requirements

  - id: checkpoint_review
    type: Prompt
    inputs:
      prompt: |
        === PHASE 1 ANALYSIS COMPLETE ===

        Technical Specification created:
        - Path: ${inputs.project_path}/${inputs.spec_output_path}
        - Requirements identified: ${blocks.count_requirements.outputs.requirements_count}
        - Ambiguities resolved: Yes

        Review checkpoint:
        1. Are all requirements clearly defined?
        2. Are success criteria measurable?
        3. Are constraints identified?
        4. Are assumptions documented?

        Approve to proceed to Phase 2 (Architecture & Design)?
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
      operation: "approve_phase1_complete"
      details:
        spec_path: "${inputs.project_path}/${inputs.spec_output_path}"
        requirements_count: "${blocks.count_requirements.outputs.requirements_count}"
        state_updated: "true"
    depends_on:
      - update_state_phase1_complete

  - id: completion_summary
    type: Shell
    inputs:
      command: |
        echo "╔════════════════════════════════════════════════════════════════╗"
        echo "║              TDD PHASE 1: ANALYSIS COMPLETE                   ║"
        echo "╚════════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Phase 1 Results:"
        echo "  ✅ PRD analyzed and parsed"
        echo "  ✅ Ambiguities identified and resolved"
        echo "  ✅ Success criteria defined"
        echo "  ✅ Technical constraints documented"
        echo "  ✅ Technical specification created"
        echo ""
        echo "Output:"
        echo "  📄 Technical Spec: ${inputs.project_path}/${inputs.spec_output_path}"
        echo "  📊 Requirements: ${blocks.count_requirements.outputs.requirements_count}"
        echo "  💾 State File: ${inputs.project_path}/${inputs.state_file}"
        echo ""
        echo "Next Phase: Architecture & Design (Phase 2)"
        echo "  Run: execute_workflow('tdd-phase2-architecture', {'project_path': '${inputs.project_path}'})"
        echo ""
        echo "Checkpoint Approved: ${blocks.checkpoint_review.outputs.response == 'yes'}"
      timeout: 10
    depends_on:
      - checkpoint_review

outputs:
  phase_complete: "${blocks.checkpoint_review.outputs.response == 'yes'}"
  technical_spec_path: "${inputs.project_path}/${inputs.spec_output_path}"
  requirements_count: "${blocks.count_requirements.outputs.requirements_count}"
  ambiguities_resolved: "true"
  checkpoint_approved: "${blocks.checkpoint_review.outputs.response == 'yes'}"

  # State tracking
  state_file_path: "${inputs.project_path}/${inputs.state_file}"
  state_initialized: "${blocks.read_initial_state.outputs.found} or ${blocks.initialize_state.succeeded}"

  # Analysis outputs
  ambiguities_identified: "${blocks.identify_ambiguities.outputs.response}"
  clarifications_provided: "${blocks.get_clarifications.outputs.response}"
  success_criteria: "${blocks.define_success_criteria.outputs.response}"
  constraints: "${blocks.identify_constraints.outputs.response}"

  # Summary
  summary: "${blocks.completion_summary.outputs.stdout}"

  # Next phase readiness
  ready_for_phase2: "${blocks.checkpoint_review.outputs.response == 'yes'}"
