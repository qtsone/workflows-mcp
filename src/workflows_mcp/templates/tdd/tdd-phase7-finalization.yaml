# TDD Phase 7: Finalization & Documentation
#
# Generates comprehensive documentation and prepares the project for deployment.
#
# This phase transforms a complete, tested application into a deployment-ready
# product with professional documentation covering deployment, usage, operations,
# and API specifications. It ensures knowledge transfer and operational readiness.
#
# Philosophy: Production readiness requires complete documentation.
#
# Key Activities:
# 1. Read state and verify Phase 6 complete
# 2. Generate deployment guide (installation, configuration, startup)
# 3. Create user documentation (getting started, features, troubleshooting)
# 4. Generate API documentation (endpoints, schemas, examples)
# 5. Create operations runbook (monitoring, incidents, maintenance)
# 6. Update README.md with project overview
# 7. Create initial CHANGELOG.md
# 8. Package application (verify config, generate requirements)
# 9. Create deployment checklist
# 10. Update state as project complete
# 11. Final completion checkpoint
#
# State Management:
# - Reads Phase 6 completion status
# - Stores documentation paths and completion status
# - Sets project_complete to true
# - Updates phase to phase7_complete
#
# Interactive Pauses:
# - LLM generates deployment guide
# - LLM generates user guide
# - LLM generates API documentation
# - LLM generates operations runbook
# - LLM updates README.md
# - Final completion checkpoint
#
# Usage:
#   execute_workflow("tdd-phase7-finalization", {
#     "project_path": "/path/to/project",
#     "project_name": "my-project",
#     "version": "1.0.0"
#   })
#
# Output:
#   - docs/DEPLOYMENT.md - Complete deployment guide
#   - docs/USER_GUIDE.md - User documentation
#   - docs/API.md - API documentation
#   - docs/RUNBOOK.md - Operations runbook
#   - README.md - Updated project overview
#   - CHANGELOG.md - Initial changelog
#   - docs/DEPLOYMENT_CHECKLIST.md - Deployment checklist
#   - State updated with project_complete = true

name: tdd-phase7-finalization
description: TDD Phase 7 - Generate deployment documentation and finalize project for production readiness
version: "1.0"
author: MCP Workflows Team
tags: [tdd, finalization, documentation, deployment, production, phase7]
inputs:
  project_path:
    type: str
    description: Path to project root directory
    default: "."
    required: false
  state_file:
    type: str
    description: Path to TDD state file (JSON)
    default: ".tdd-state.json"
    required: false
  project_name:
    type: str
    description: Project name
    required: true
  version:
    type: str
    description: Project version
    default: "1.0.0"
    required: false
  author:
    type: str
    description: Author name or organization
    default: "Development Team"
    required: false
  python_version:
    type: str
    description: Python version requirement
    default: "3.12+"
    required: false
  coverage_threshold:
    type: num
    description: Code coverage threshold from Phase 6
    default: 80
    required: false
blocks:
  - id: read_state
    type: ReadJSONState
    inputs:
      path: "{{inputs.project_path}}/{{inputs.state_file}}"
  - id: validate_phase6_complete
    type: Shell
    inputs:
      command: |
        STATE='{{blocks.read_state.state}}'

        # Check if Phase 6 is in completed phases
        if echo "$STATE" | grep -q '"phase6_complete"'; then
          echo "✅ Phase 6 complete - ready for finalization"

          # Extract Phase 6 metrics
          TOTAL_TESTS=$(echo "$STATE" | grep -o '"total_tests"[[:space:]]*:[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' | head -1)
          COVERAGE=$(echo "$STATE" | grep -o '"overall_coverage"[[:space:]]*:[[:space:]]*[0-9.]\+' | grep -o '[0-9.]\+' | head -1)

          echo "$TOTAL_TESTS" > "{{tmp}}/test_count.txt"
          echo "$COVERAGE" > "{{tmp}}/coverage.txt"
          exit 0
        else
          echo "❌ ERROR: Phase 6 not complete. Complete validation testing first."
          echo "Current phase: {{blocks.read_state.state.current_phase}}"
          exit 1
        fi
      timeout: 10
    outputs:
      test_count:
        type: num
        path: "{{tmp}}/test_count.txt"
        description: "Total number of tests from Phase 6"
        required: false
      coverage:
        type: num
        path: "{{tmp}}/coverage.txt"
        description: "Test coverage percentage from Phase 6"
        required: false
    depends_on:
      - read_state
  - id: create_docs_directory
    type: Shell
    inputs:
      command: |
        cd "{{inputs.project_path}}"
        mkdir -p docs
        echo "✅ Created docs/ directory"
      timeout: 10
    depends_on:
      - validate_phase6_complete
  - id: request_deployment_guide
    type: Prompt
    inputs:
      prompt: |
        === GENERATE DEPLOYMENT GUIDE ===

        Generate comprehensive deployment guide for {{inputs.project_name}} v{{inputs.version}}.

        Include the following sections in markdown format:

        # Deployment Guide - {{inputs.project_name}}

        ## 1. System Requirements
        - Operating system compatibility
        - Python version: {{inputs.python_version}}
        - Hardware requirements (CPU, RAM, disk)
        - Network requirements

        ## 2. Installation Steps
        - Step-by-step installation procedure
        - Dependency installation (pip, uv, or poetry)
        - Virtual environment setup
        - Configuration file creation

        ## 3. Configuration
        - Environment variables and their purposes
        - Configuration file locations and formats
        - Security considerations (secrets, keys)
        - Database configuration (if applicable)

        ## 4. Service Management
        - How to start services
        - How to stop services gracefully
        - Health check procedures
        - Log file locations and rotation

        ## 5. Database Setup (if applicable)
        - Database initialization
        - Migration procedures
        - Backup and restore procedures

        ## 6. Troubleshooting
        - Common deployment issues and solutions
        - Log analysis tips
        - Debugging procedures
        - Support contact information

        ## 7. Rollback Procedures
        - How to rollback to previous version
        - Data migration rollback
        - Verification after rollback

        Provide the COMPLETE deployment guide content as markdown.

        Respond with 'yes' or 'no'
    depends_on:
      - create_docs_directory
  - id: write_deployment_guide
    type: CreateFile
    inputs:
      path: "{{inputs.project_path}}/docs/DEPLOYMENT.md"
      content: "{{blocks.request_deployment_guide.response}}"
      encoding: "utf-8"
    depends_on:
      - request_deployment_guide
  - id: request_user_guide
    type: Prompt
    inputs:
      prompt: |
        === GENERATE USER GUIDE ===

        Generate comprehensive user guide for {{inputs.project_name}} v{{inputs.version}}.

        Include the following sections in markdown format:

        # User Guide - {{inputs.project_name}}

        ## 1. Getting Started
        - Overview of {{inputs.project_name}}
        - Key features and benefits
        - Prerequisites
        - Quick start guide

        ## 2. Core Features
        - Feature descriptions with examples
        - Screenshots or CLI examples
        - Step-by-step usage instructions
        - Configuration options

        ## 3. Common Workflows
        - Typical use cases and workflows
        - Best practices
        - Tips and tricks
        - Performance optimization

        ## 4. Troubleshooting
        - Common issues and solutions
        - Error messages and meanings
        - How to get help
        - FAQ section

        ## 5. Advanced Usage
        - Advanced features and configurations
        - Integration with other tools
        - Customization options
        - API usage (if applicable)

        ## 6. Support
        - How to report bugs
        - Feature requests
        - Community resources
        - Contact information

        Provide the COMPLETE user guide content as markdown.

        Respond with 'yes' or 'no'
    depends_on:
      - write_deployment_guide
  - id: write_user_guide
    type: CreateFile
    inputs:
      path: "{{inputs.project_path}}/docs/USER_GUIDE.md"
      content: "{{blocks.request_user_guide.response}}"
      encoding: "utf-8"
    depends_on:
      - request_user_guide
  - id: request_api_docs
    type: Prompt
    inputs:
      prompt: |
        === GENERATE API DOCUMENTATION ===

        Generate comprehensive API documentation for {{inputs.project_name}} v{{inputs.version}}.

        Include the following sections in markdown format:

        # API Documentation - {{inputs.project_name}}

        ## 1. Overview
        - API purpose and capabilities
        - Base URL and versioning
        - Authentication requirements
        - Rate limiting (if applicable)

        ## 2. Authentication
        - Authentication methods (API keys, OAuth, JWT)
        - How to obtain credentials
        - Authentication examples
        - Security best practices

        ## 3. Endpoints

        For each endpoint, document:
        - HTTP method and path
        - Description and purpose
        - Request parameters (path, query, body)
        - Request schema with types
        - Response schema with types
        - Status codes and meanings
        - Example requests (curl, Python, JavaScript)
        - Example responses

        ## 4. Error Handling
        - Error response format
        - Common error codes and meanings
        - Troubleshooting errors

        ## 5. Code Examples
        - Complete working examples in multiple languages
        - Common integration patterns
        - SDK usage (if available)

        ## 6. API Reference
        - Data models and schemas
        - Enumerations and constants
        - Pagination and filtering
        - Sorting and searching

        Provide the COMPLETE API documentation content as markdown.
        If this project has no API, provide a brief explanation and skip API-specific sections.

        Respond with 'yes' or 'no'

        Respond with 'yes' or 'no'

        Respond with 'yes' or 'no'
    depends_on:
      - write_user_guide
  - id: write_api_docs
    type: CreateFile
    inputs:
      path: "{{inputs.project_path}}/docs/API.md"
      content: "{{blocks.request_api_docs.response}}"
      encoding: "utf-8"
    depends_on:
      - request_api_docs
  - id: request_runbook
    type: Prompt
    inputs:
      prompt: |
        === GENERATE OPERATIONS RUNBOOK ===

        Generate comprehensive operations runbook for {{inputs.project_name}} v{{inputs.version}}.

        Include the following sections in markdown format:

        # Operations Runbook - {{inputs.project_name}}

        ## 1. Monitoring Guidelines
        - Key metrics to monitor
        - Monitoring tools and dashboards
        - Alert thresholds and criteria
        - Health check endpoints

        ## 2. Alert Response Procedures

        For each alert type:
        - Alert description and severity
        - Potential causes
        - Diagnostic steps
        - Resolution procedures
        - Escalation path

        ## 3. Common Issues and Solutions
        - Issue symptoms
        - Root cause analysis steps
        - Resolution procedures
        - Prevention measures

        ## 4. Performance Tuning
        - Performance baseline metrics
        - Tuning parameters and recommendations
        - Optimization strategies
        - Capacity planning guidelines

        ## 5. Backup and Restore
        - Backup schedule and procedures
        - Backup verification
        - Restore procedures
        - Disaster recovery plan

        ## 6. Incident Response Playbook
        - Incident severity levels
        - Response procedures for each severity
        - Communication protocols
        - Post-incident review process

        ## 7. Maintenance Procedures
        - Regular maintenance tasks
        - Upgrade procedures
        - Database maintenance
        - Log rotation and cleanup

        ## 8. On-Call Resources
        - Contact information
        - System access credentials locations
        - Escalation paths
        - Emergency procedures

        Provide the COMPLETE operations runbook content as markdown.

        Respond with 'yes' or 'no'
    depends_on:
      - write_api_docs
  - id: write_runbook
    type: CreateFile
    inputs:
      path: "{{inputs.project_path}}/docs/RUNBOOK.md"
      content: "{{blocks.request_runbook.response}}"
      encoding: "utf-8"
    depends_on:
      - request_runbook
  - id: request_readme_update
    type: Prompt
    inputs:
      prompt: |
        === UPDATE README.md ===

        Create comprehensive README.md for {{inputs.project_name}} v{{inputs.version}}.

        Structure as follows:

        # {{inputs.project_name}}

        **Version:** {{inputs.version}}
        **Author:** {{inputs.author}}

        ## Overview
        [Brief project description - what it does and why it exists]

        ## Features
        - Feature 1
        - Feature 2
        - Feature 3
        [List key features with brief descriptions]

        ## Quick Start

        ```bash
        # Installation
        pip install {{inputs.project_name}}

        # Basic usage
        {{inputs.project_name}} --help
        ```

        ## Installation

        ### Requirements
        - Python {{inputs.python_version}}
        - [Other requirements]

        ### Install from PyPI
        ```bash
        pip install {{inputs.project_name}}
        ```

        ### Install from Source
        ```bash
        git clone https://github.com/yourorg/{{inputs.project_name}}.git
        cd {{inputs.project_name}}
        pip install -e .
        ```

        ## Usage

        [Basic usage examples with code snippets]

        ## Documentation

        - [User Guide](docs/USER_GUIDE.md) - Complete user documentation
        - [API Documentation](docs/API.md) - API reference
        - [Deployment Guide](docs/DEPLOYMENT.md) - Deployment instructions
        - [Operations Runbook](docs/RUNBOOK.md) - Operations guide

        ## Development

        ### Running Tests
        ```bash
        pytest tests/ --cov={{inputs.project_name}}
        ```

        Coverage: {{inputs.coverage_threshold}}%+ required

        ### Code Quality
        ```bash
        ruff check src/
        mypy src/
        ```

        ## Contributing

        [Contributing guidelines]

        ## License

        [License information]

        ## Support

        [How to get help]

        Provide the COMPLETE README.md content as markdown.

        Respond with 'yes' or 'no'

        Respond with 'yes' or 'no'

        Respond with 'yes' or 'no'
    depends_on:
      - write_runbook
  - id: write_readme
    type: CreateFile
    inputs:
      path: "{{inputs.project_path}}/README.md"
      content: "{{blocks.request_readme_update.response}}"
      encoding: "utf-8"
    depends_on:
      - request_readme_update
  - id: extract_requirements_list
    type: Shell
    inputs:
      command: |
        STATE='{{blocks.read_state.state}}'

        # Try to extract requirements list from Phase 1
        REQ_LIST=$(echo "$STATE" | grep -o '"requirements_list"[[:space:]]*:[[:space:]]*\[[^]]*\]' | head -1)

        if [ -n "$REQ_LIST" ]; then
          echo "Requirements from Phase 1:"
          echo "$REQ_LIST"
        else
          echo "No requirements list found in state"
        fi

        # Extract module count from Phase 4
        MODULE_COUNT=$(echo "$STATE" | grep -o '"modules"[[:space:]]*:[[:space:]]*\[[^]]*\]' | grep -o '\[' | wc -l)
        echo "$MODULE_COUNT" > "{{tmp}}/module_count.txt"
      timeout: 10
    outputs:
      module_count:
        type: num
        path: "{{tmp}}/module_count.txt"
        description: "Number of modules from Phase 4"
    depends_on:
      - validate_phase6_complete
  - id: create_changelog
    type: Shell
    inputs:
      command: |
        cat > "{{inputs.project_path}}/CHANGELOG.md" << 'EOF'
        # Changelog

        All notable changes to {{inputs.project_name}} will be documented in this file.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
        and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        ## [{{inputs.version}}] - $(date +%Y-%m-%d)

        ### Added
        - Initial release of {{inputs.project_name}}
        - Core functionality implemented with TDD methodology
        - Comprehensive test suite with {{inputs.coverage_threshold}}%+ coverage
        - Complete documentation suite:
          - User Guide
          - API Documentation
          - Deployment Guide
          - Operations Runbook
        - Production-ready quality gates passed

        ### Features
        - All PRD requirements implemented and tested
        - $(echo "{{blocks.validate_phase6_complete.stdout}}" | grep test_count | cut -d= -f2) automated tests
        - $(echo "{{blocks.validate_phase6_complete.stdout}}" | grep coverage | cut -d= -f2)% code coverage
        - Security scanning passed
        - Performance validation completed

        ### Technical
        - Python {{inputs.python_version}} compatible
        - Test-Driven Development methodology
        - Continuous integration ready
        - Production deployment ready

        EOF

        echo "✅ CHANGELOG.md created"
      timeout: 30
    depends_on:
      - write_readme
  - id: verify_project_config
    type: Shell
    inputs:
      command: |
        cd "{{inputs.project_path}}"

        # Check if pyproject.toml exists
        if [ -f pyproject.toml ]; then
          echo "✅ pyproject.toml found"

          # Verify project name
          if grep -q "name.*{{inputs.project_name}}" pyproject.toml; then
            echo "✅ Project name matches in pyproject.toml"
          else
            echo "⚠️  WARNING: Project name mismatch in pyproject.toml"
          fi

          # Verify version
          if grep -q "version.*{{inputs.version}}" pyproject.toml; then
            echo "✅ Version matches in pyproject.toml"
          else
            echo "⚠️  WARNING: Version mismatch in pyproject.toml"
          fi
        else
          echo "⚠️  WARNING: pyproject.toml not found"
        fi

        # Check if setup.py exists (legacy)
        if [ -f setup.py ]; then
          echo "ℹ️  setup.py found (legacy)"
        fi

        echo "true" > "{{tmp}}/config_verified.txt"
      timeout: 30
    outputs:
      config_verified:
        type: bool
        path: "{{tmp}}/config_verified.txt"
        description: "Whether project configuration is verified"
    depends_on:
      - create_changelog
  - id: generate_requirements
    type: Shell
    inputs:
      command: |
        cd "{{inputs.project_path}}"

        # Generate requirements.txt for deployment
        if command -v uv &> /dev/null; then
          echo "Using uv to generate requirements.txt..."
          uv pip compile pyproject.toml -o requirements.txt 2>/dev/null || {
            echo "⚠️  uv compile failed, trying alternative"
            if [ -f pyproject.toml ]; then
              echo "# Generated from pyproject.toml" > requirements.txt
              echo "# Install with: pip install -r requirements.txt" >> requirements.txt
            fi
          }
        elif command -v pip-compile &> /dev/null; then
          echo "Using pip-compile to generate requirements.txt..."
          pip-compile pyproject.toml -o requirements.txt 2>/dev/null || {
            echo "⚠️  pip-compile failed"
          }
        else
          echo "⚠️  Neither uv nor pip-compile available"
          echo "# Install dependencies from pyproject.toml" > requirements.txt
          echo "# Use: pip install -e ." >> requirements.txt
        fi

        if [ -f requirements.txt ]; then
          echo "✅ requirements.txt generated for deployment"
          echo "true" > "{{tmp}}/requirements_generated.txt"
        else
          echo "⚠️  requirements.txt not generated"
          echo "false" > "{{tmp}}/requirements_generated.txt"
        fi
      timeout: 60
    outputs:
      requirements_generated:
        type: bool
        path: "{{tmp}}/requirements_generated.txt"
        description: "Whether requirements.txt was successfully generated"
    depends_on:
      - verify_project_config
  - id: create_deployment_checklist
    type: Shell
    inputs:
      command: |
        # Extract metrics from state
        TOTAL_TESTS="{{blocks.validate_phase6_complete.outputs.test_count}}"
        COVERAGE="{{blocks.validate_phase6_complete.outputs.coverage}}"

        cat > "{{inputs.project_path}}/docs/DEPLOYMENT_CHECKLIST.md" << EOF
        # Deployment Checklist for {{inputs.project_name}} v{{inputs.version}}

        **Generated:** $(date -Iseconds)

        ## Pre-Deployment Verification

        ### Quality Assurance
        - [ ] All tests passing (${TOTAL_TESTS:-N/A} tests)
        - [ ] Code coverage ≥ {{inputs.coverage_threshold}}% (actual: ${COVERAGE:-N/A}%)
        - [ ] All quality gates passed
        - [ ] Security scan clean (no vulnerabilities)
        - [ ] Performance testing completed
        - [ ] Documentation reviewed and complete

        ### Code Review
        - [ ] Code reviewed by team members
        - [ ] All PR comments addressed
        - [ ] No TODOs or FIXMEs in production code
        - [ ] Code follows style guidelines

        ### Configuration
        - [ ] All environment variables documented
        - [ ] Configuration files reviewed
        - [ ] Secrets management configured
        - [ ] Database connection strings verified

        ## Deployment Steps

        ### 1. Backup
        - [ ] Backup production data (if applicable)
        - [ ] Backup current deployment
        - [ ] Verify backup integrity
        - [ ] Document backup location and timestamp

        ### 2. Staging Deployment
        - [ ] Review DEPLOYMENT.md guide
        - [ ] Verify system requirements met
        - [ ] Deploy to staging environment
        - [ ] Run smoke tests on staging
        - [ ] Verify all features functional
        - [ ] Check logs for errors

        ### 3. Production Deployment
        - [ ] Schedule deployment window
        - [ ] Notify stakeholders of deployment
        - [ ] Deploy to production
        - [ ] Verify health checks pass
        - [ ] Monitor logs for errors
        - [ ] Run production smoke tests
        - [ ] Verify core functionality
        - [ ] Monitor performance metrics

        ### 4. Post-Deployment Validation
        - [ ] Application accessible
        - [ ] Core features functional
        - [ ] API endpoints responding correctly
        - [ ] Database connectivity verified
        - [ ] Performance within acceptable range
        - [ ] No error spikes in logs
        - [ ] Monitoring dashboards operational
        - [ ] Alerts configured and working

        ### 5. Documentation
        - [ ] Document deployment timestamp
        - [ ] Document any issues encountered
        - [ ] Update runbook if needed
        - [ ] Notify team of successful deployment

        ## Rollback Plan

        If deployment fails or critical issues are discovered:

        ### 1. Immediate Actions
        - [ ] Trigger rollback procedure (see DEPLOYMENT.md)
        - [ ] Notify stakeholders of rollback
        - [ ] Stop accepting new traffic (if possible)

        ### 2. Rollback Execution
        - [ ] Restore previous version
        - [ ] Rollback database migrations (if applicable)
        - [ ] Verify rollback successful
        - [ ] Run smoke tests on rolled-back version
        - [ ] Check logs for rollback errors

        ### 3. Post-Rollback
        - [ ] Investigate failure root cause
        - [ ] Document incident and lessons learned
        - [ ] Create tickets for fixes
        - [ ] Plan corrective deployment
        - [ ] Update deployment procedures if needed

        ## Monitoring and Alerts

        ### During Deployment
        - [ ] Monitor error rates
        - [ ] Monitor response times
        - [ ] Monitor resource utilization (CPU, memory, disk)
        - [ ] Monitor database connections
        - [ ] Watch for alert triggers

        ### Post-Deployment (24-48 hours)
        - [ ] Continued monitoring of error rates
        - [ ] Performance trend analysis
        - [ ] User feedback collection
        - [ ] Resource utilization trends
        - [ ] Alert frequency analysis

        ## Sign-Off

        - **Deployed By:** ___________________
        - **Deployment Date/Time:** ___________________
        - **Verified By:** ___________________
        - **Verification Date/Time:** ___________________
        - **Deployment Status:** ☐ Success ☐ Partial ☐ Rollback
        - **Notes:** ___________________

        EOF

        echo "✅ Deployment checklist created: {{inputs.project_path}}/docs/DEPLOYMENT_CHECKLIST.md"
      timeout: 30
    depends_on:
      - generate_requirements
  - id: update_state_phase7
    type: Shell
    inputs:
      command: |
        # Create Python script to update state
        cat > /tmp/update_phase7_state.py << 'PYTHON_SCRIPT'
        import json
        import sys
        from pathlib import Path
        from datetime import datetime

        # Get arguments
        state_file = Path(sys.argv[1])
        project_name = sys.argv[2]
        version = sys.argv[3]

        # Read existing state
        state = json.loads(state_file.read_text())

        # Ensure required keys exist
        if 'phases_completed' not in state:
            state['phases_completed'] = []

        # Add phase7_complete to completed phases
        if 'phase7_complete' not in state['phases_completed']:
            state['phases_completed'].append('phase7_complete')

        # Update phase7 metrics
        state['phase7'] = {
            'documentation_complete': True,
            'deployment_guide': 'docs/DEPLOYMENT.md',
            'user_guide': 'docs/USER_GUIDE.md',
            'api_docs': 'docs/API.md',
            'runbook': 'docs/RUNBOOK.md',
            'changelog': 'CHANGELOG.md',
            'readme_updated': True,
            'deployment_checklist': 'docs/DEPLOYMENT_CHECKLIST.md',
            'package_verified': True,
            'requirements_generated': True,
            'ready_for_deployment': True,
            'completed_at': datetime.now().isoformat()
        }

        # Mark project as complete
        state['current_phase'] = 'phase7_complete'
        state['project_complete'] = True
        state['project_info'] = {
            'name': project_name,
            'version': version,
            'completion_date': datetime.now().isoformat()
        }

        # Write back
        state_file.write_text(json.dumps(state, indent=2) + '\n')

        print(f'✅ Phase 7 complete:')
        print(f'   Project: {project_name} v{version}')
        print(f'   Documentation: Complete')
        print(f'   Deployment: Ready')
        print(f'   Status: Production-ready')
        PYTHON_SCRIPT

        # Run the Python script
        python3 /tmp/update_phase7_state.py \
          "{{inputs.project_path}}/{{inputs.state_file}}" \
          "{{inputs.project_name}}" \
          "{{inputs.version}}"
      timeout: 30
    depends_on:
      - create_deployment_checklist
  - id: final_completion_checkpoint
    type: Prompt
    inputs:
      prompt: "╔═══════════════════════════════════════════════════════════╗\n║  \U0001F389 TDD PROJECT DEVELOPMENT COMPLETE! \U0001F389                  ║\n╚═══════════════════════════════════════════════════════════╝\n\nProject: {{inputs.project_name}} v{{inputs.version}}\nCompleted: $(date)\n\n\U0001F4CA Project Statistics:\n- Total tests: $(echo \"{{blocks.validate_phase6_complete.stdout}}\" | grep test_count | cut -d= -f2)\n- Test coverage: $(echo \"{{blocks.validate_phase6_complete.stdout}}\" | grep coverage | cut -d= -f2)%\n- Coverage threshold: {{inputs.coverage_threshold}}%\n\n\U0001F4DA Documentation Generated:\n- ✅ docs/DEPLOYMENT.md - Deployment guide\n- ✅ docs/USER_GUIDE.md - User documentation\n- ✅ docs/API.md - API documentation\n- ✅ docs/RUNBOOK.md - Operations runbook\n- ✅ docs/DEPLOYMENT_CHECKLIST.md - Deployment checklist\n- ✅ README.md - Project overview\n- ✅ CHANGELOG.md - Version history\n\n\U0001F4E6 Package Status:\n- ✅ Project configuration verified\n- ✅ Dependencies documented\n- ✅ Ready for deployment\n\n\U0001F680 Next Steps:\n1. Review all documentation in docs/\n2. Follow docs/DEPLOYMENT_CHECKLIST.md\n3. Deploy to staging environment\n4. Run final acceptance tests\n5. Deploy to production\n\nConfirm project completion and deployment readiness?\n\nRespond with 'yes' or 'no'\n\nRespond with 'yes' or 'no'\n"
      operation: "phase7_completion_checkpoint"
      details:
        project_name: "{{inputs.project_name}}"
        version: "{{inputs.version}}"
        documentation_complete: "true"
        deployment_ready: "true"
    depends_on:
      - update_state_phase7
  - id: final_summary
    type: Shell
    inputs:
      command: "# Extract metrics\nTOTAL_TESTS=\"{{blocks.validate_phase6_complete.outputs.test_count}}\"\nCOVERAGE=\"{{blocks.validate_phase6_complete.outputs.coverage}}\"\nMODULE_COUNT=\"{{blocks.extract_requirements_list.outputs.module_count}}\"\n\necho \"╔═══════════════════════════════════════════════════════════╗\"\necho \"║       TDD PHASE 7: FINALIZATION COMPLETE                 ║\"\necho \"╚═══════════════════════════════════════════════════════════╝\"\necho \"\"\necho \"Project: {{inputs.project_name}} v{{inputs.version}}\"\necho \"Author: {{inputs.author}}\"\necho \"Completion Date: $(date)\"\necho \"\"\necho \"\U0001F4CA Project Statistics:\"\necho \"  - Modules implemented: ${MODULE_COUNT:-N/A}\"\necho \"  - Total tests: ${TOTAL_TESTS:-N/A}\"\necho \"  - Test coverage: ${COVERAGE:-N/A}%\"\necho \"  - Quality gates: All passed ✅\"\necho \"\"\necho \"\U0001F4DA Documentation Generated:\"\necho \"  ✅ {{inputs.project_path}}/docs/DEPLOYMENT.md\"\necho \"  ✅ {{inputs.project_path}}/docs/USER_GUIDE.md\"\necho \"  ✅ {{inputs.project_path}}/docs/API.md\"\necho \"  ✅ {{inputs.project_path}}/docs/RUNBOOK.md\"\necho \"  ✅ {{inputs.project_path}}/docs/DEPLOYMENT_CHECKLIST.md\"\necho \"  ✅ {{inputs.project_path}}/README.md\"\necho \"  ✅ {{inputs.project_path}}/CHANGELOG.md\"\necho \"\"\necho \"\U0001F4E6 Package Status:\"\necho \"  - Configuration: $(echo \"{{blocks.verify_project_config.stdout}}\" | grep config_verified | cut -d= -f2)\"\necho \"  - Requirements: $(echo \"{{blocks.generate_requirements.stdout}}\" | grep requirements_generated | cut -d= -f2)\"\necho \"  - Deployment: Ready ✅\"\necho \"\"\necho \"\U0001F680 Deployment Instructions:\"\necho \"  1. Review: {{inputs.project_path}}/docs/DEPLOYMENT_CHECKLIST.md\"\necho \"  2. Follow: {{inputs.project_path}}/docs/DEPLOYMENT.md\"\necho \"  3. Monitor: {{inputs.project_path}}/docs/RUNBOOK.md\"\necho \"\"\necho \"✅ PROJECT READY FOR PRODUCTION DEPLOYMENT!\"\necho \"\"\necho \"State file: {{inputs.project_path}}/{{inputs.state_file}}\"\necho \"Project complete: true\"\n"
      timeout: 10
    depends_on:
      - final_completion_checkpoint
outputs:
  # Documentation paths
  deployment_guide_path:
    value: "{{inputs.project_path}}/docs/DEPLOYMENT.md"
  user_guide_path:
    value: "{{inputs.project_path}}/docs/USER_GUIDE.md"
  api_docs_path:
    value: "{{inputs.project_path}}/docs/API.md"
  runbook_path:
    value: "{{inputs.project_path}}/docs/RUNBOOK.md"
  changelog_path:
    value: "{{inputs.project_path}}/CHANGELOG.md"
  readme_path:
    value: "{{inputs.project_path}}/README.md"
  deployment_checklist_path:
    value: "{{inputs.project_path}}/docs/DEPLOYMENT_CHECKLIST.md"
  # Status indicators
  documentation_complete:
    value: "true"
  readme_updated:
    value: "true"
  package_created:
    value: "{{blocks.verify_project_config.outputs.config_verified}}"
  requirements_generated:
    value: "{{blocks.generate_requirements.outputs.requirements_generated}}"
  project_complete:
    value: "true"
  deployment_ready:
    value: "{{blocks.final_completion_checkpoint.outputs.response}} == 'yes'"
  # Project info
  project_name:
    value: "{{inputs.project_name}}"
  project_version:
    value: "{{inputs.version}}"
  project_author:
    value: "{{inputs.author}}"
  # Checkpoint
  completion_confirmed:
    value: "{{blocks.final_completion_checkpoint.outputs.response}} == 'yes'"
  # State
  state_updated:
    value: "{{blocks.update_state_phase7.succeeded}}"
  state_file_path:
    value: "{{inputs.project_path}}/{{inputs.state_file}}"
  # Summary
  summary:
    value: "{{blocks.final_summary.outputs.stdout}}"
