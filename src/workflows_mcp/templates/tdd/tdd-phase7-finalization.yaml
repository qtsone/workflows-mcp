# TDD Phase 7: Finalization & Documentation
#
# Generates comprehensive documentation and prepares the project for deployment.
#
# This phase transforms a complete, tested application into a deployment-ready
# product with professional documentation covering deployment, usage, operations,
# and API specifications. It ensures knowledge transfer and operational readiness.
#
# Philosophy: Production readiness requires complete documentation.
#
# Key Activities:
# 1. Read state and verify Phase 6 complete
# 2. Generate deployment guide (installation, configuration, startup)
# 3. Create user documentation (getting started, features, troubleshooting)
# 4. Generate API documentation (endpoints, schemas, examples)
# 5. Create operations runbook (monitoring, incidents, maintenance)
# 6. Update README.md with project overview
# 7. Create initial CHANGELOG.md
# 8. Package application (verify config, generate requirements)
# 9. Create deployment checklist
# 10. Update state as project complete
# 11. Final completion checkpoint
#
# State Management:
# - Reads Phase 6 completion status
# - Stores documentation paths and completion status
# - Sets project_complete to true
# - Updates phase to phase7_complete
#
# Interactive Pauses:
# - LLM generates deployment guide
# - LLM generates user guide
# - LLM generates API documentation
# - LLM generates operations runbook
# - LLM updates README.md
# - Final completion checkpoint
#
# Usage:
#   execute_workflow("tdd-phase7-finalization", {
#     "project_path": "/path/to/project",
#     "project_name": "my-project",
#     "version": "1.0.0"
#   })
#
# Output:
#   - docs/DEPLOYMENT.md - Complete deployment guide
#   - docs/USER_GUIDE.md - User documentation
#   - docs/API.md - API documentation
#   - docs/RUNBOOK.md - Operations runbook
#   - README.md - Updated project overview
#   - CHANGELOG.md - Initial changelog
#   - docs/DEPLOYMENT_CHECKLIST.md - Deployment checklist
#   - State updated with project_complete = true

name: tdd-phase7-finalization
description: TDD Phase 7 - Generate deployment documentation and finalize project for production readiness
version: "1.0"
author: MCP Workflows Team
tags: [tdd, finalization, documentation, deployment, production, phase7]

inputs:
  project_path:
    type: str
    description: Path to project root directory
    default: "."
    required: false

  state_file:
    type: str
    description: Path to TDD state file (JSON)
    default: ".tdd-state.json"
    required: false

  project_name:
    type: str
    description: Project name
    required: true

  version:
    type: str
    description: Project version
    default: "1.0.0"
    required: false

  author:
    type: str
    description: Author name or organization
    default: "Development Team"
    required: false

  python_version:
    type: str
    description: Python version requirement
    default: "3.12+"
    required: false

  coverage_threshold:
    type: int
    description: Code coverage threshold from Phase 6
    default: 80
    required: false

blocks:
  - id: read_state
    type: ReadJSONState
    inputs:
      path: "${inputs.project_path}/${inputs.state_file}"

  - id: validate_phase6_complete
    type: Shell
    inputs:
      command: |
        STATE='${blocks.read_state.state}'

        # Check if Phase 6 is in completed phases
        if echo "$STATE" | grep -q '"phase6_complete"'; then
          echo "✅ Phase 6 complete - ready for finalization"

          # Extract Phase 6 metrics
          TOTAL_TESTS=$(echo "$STATE" | grep -o '"total_tests"[[:space:]]*:[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' | head -1)
          COVERAGE=$(echo "$STATE" | grep -o '"overall_coverage"[[:space:]]*:[[:space:]]*[0-9.]\+' | grep -o '[0-9.]\+' | head -1)

          echo "$TOTAL_TESTS" > "$SCRATCH/test_count.txt"
          echo "$COVERAGE" > "$SCRATCH/coverage.txt"
          exit 0
        else
          echo "❌ ERROR: Phase 6 not complete. Complete validation testing first."
          echo "Current phase: ${blocks.read_state.state.current_phase}"
          exit 1
        fi
      timeout: 10
    outputs:
      test_count:
        type: int
        path: "$SCRATCH/test_count.txt"
        description: "Total number of tests from Phase 6"
        required: false
      coverage:
        type: float
        path: "$SCRATCH/coverage.txt"
        description: "Test coverage percentage from Phase 6"
        required: false
    depends_on:
      - read_state

  - id: create_docs_directory
    type: Shell
    inputs:
      command: |
        cd "${inputs.project_path}"
        mkdir -p docs
        echo "✅ Created docs/ directory"
      timeout: 10
    depends_on:
      - validate_phase6_complete

  - id: request_deployment_guide
    type: Prompt
    inputs:
      prompt: |
        === GENERATE DEPLOYMENT GUIDE ===

        Generate comprehensive deployment guide for ${inputs.project_name} v${inputs.version}.

        Include the following sections in markdown format:

        # Deployment Guide - ${inputs.project_name}

        ## 1. System Requirements
        - Operating system compatibility
        - Python version: ${inputs.python_version}
        - Hardware requirements (CPU, RAM, disk)
        - Network requirements

        ## 2. Installation Steps
        - Step-by-step installation procedure
        - Dependency installation (pip, uv, or poetry)
        - Virtual environment setup
        - Configuration file creation

        ## 3. Configuration
        - Environment variables and their purposes
        - Configuration file locations and formats
        - Security considerations (secrets, keys)
        - Database configuration (if applicable)

        ## 4. Service Management
        - How to start services
        - How to stop services gracefully
        - Health check procedures
        - Log file locations and rotation

        ## 5. Database Setup (if applicable)
        - Database initialization
        - Migration procedures
        - Backup and restore procedures

        ## 6. Troubleshooting
        - Common deployment issues and solutions
        - Log analysis tips
        - Debugging procedures
        - Support contact information

        ## 7. Rollback Procedures
        - How to rollback to previous version
        - Data migration rollback
        - Verification after rollback

        Provide the COMPLETE deployment guide content as markdown.
        
        Respond with 'yes' or 'no'
    depends_on:
      - create_docs_directory

  - id: write_deployment_guide
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/docs/DEPLOYMENT.md"
      content: "${blocks.request_deployment_guide.response}"
      encoding: "utf-8"
    depends_on:
      - request_deployment_guide

  - id: request_user_guide
    type: Prompt
    inputs:
      prompt: |
        === GENERATE USER GUIDE ===

        Generate comprehensive user guide for ${inputs.project_name} v${inputs.version}.

        Include the following sections in markdown format:

        # User Guide - ${inputs.project_name}

        ## 1. Getting Started
        - Overview of ${inputs.project_name}
        - Key features and benefits
        - Prerequisites
        - Quick start guide

        ## 2. Core Features
        - Feature descriptions with examples
        - Screenshots or CLI examples
        - Step-by-step usage instructions
        - Configuration options

        ## 3. Common Workflows
        - Typical use cases and workflows
        - Best practices
        - Tips and tricks
        - Performance optimization

        ## 4. Troubleshooting
        - Common issues and solutions
        - Error messages and meanings
        - How to get help
        - FAQ section

        ## 5. Advanced Usage
        - Advanced features and configurations
        - Integration with other tools
        - Customization options
        - API usage (if applicable)

        ## 6. Support
        - How to report bugs
        - Feature requests
        - Community resources
        - Contact information

        Provide the COMPLETE user guide content as markdown.
        
        Respond with 'yes' or 'no'
    depends_on:
      - write_deployment_guide

  - id: write_user_guide
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/docs/USER_GUIDE.md"
      content: "${blocks.request_user_guide.response}"
      encoding: "utf-8"
    depends_on:
      - request_user_guide

  - id: request_api_docs
    type: Prompt
    inputs:
      prompt: |
        === GENERATE API DOCUMENTATION ===

        Generate comprehensive API documentation for ${inputs.project_name} v${inputs.version}.

        Include the following sections in markdown format:

        # API Documentation - ${inputs.project_name}

        ## 1. Overview
        - API purpose and capabilities
        - Base URL and versioning
        - Authentication requirements
        - Rate limiting (if applicable)

        ## 2. Authentication
        - Authentication methods (API keys, OAuth, JWT)
        - How to obtain credentials
        - Authentication examples
        - Security best practices

        ## 3. Endpoints

        For each endpoint, document:
        - HTTP method and path
        - Description and purpose
        - Request parameters (path, query, body)
        - Request schema with types
        - Response schema with types
        - Status codes and meanings
        - Example requests (curl, Python, JavaScript)
        - Example responses

        ## 4. Error Handling
        - Error response format
        - Common error codes and meanings
        - Troubleshooting errors

        ## 5. Code Examples
        - Complete working examples in multiple languages
        - Common integration patterns
        - SDK usage (if available)

        ## 6. API Reference
        - Data models and schemas
        - Enumerations and constants
        - Pagination and filtering
        - Sorting and searching

        Provide the COMPLETE API documentation content as markdown.
        If this project has no API, provide a brief explanation and skip API-specific sections.
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
    depends_on:
      - write_user_guide

  - id: write_api_docs
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/docs/API.md"
      content: "${blocks.request_api_docs.response}"
      encoding: "utf-8"
    depends_on:
      - request_api_docs

  - id: request_runbook
    type: Prompt
    inputs:
      prompt: |
        === GENERATE OPERATIONS RUNBOOK ===

        Generate comprehensive operations runbook for ${inputs.project_name} v${inputs.version}.

        Include the following sections in markdown format:

        # Operations Runbook - ${inputs.project_name}

        ## 1. Monitoring Guidelines
        - Key metrics to monitor
        - Monitoring tools and dashboards
        - Alert thresholds and criteria
        - Health check endpoints

        ## 2. Alert Response Procedures

        For each alert type:
        - Alert description and severity
        - Potential causes
        - Diagnostic steps
        - Resolution procedures
        - Escalation path

        ## 3. Common Issues and Solutions
        - Issue symptoms
        - Root cause analysis steps
        - Resolution procedures
        - Prevention measures

        ## 4. Performance Tuning
        - Performance baseline metrics
        - Tuning parameters and recommendations
        - Optimization strategies
        - Capacity planning guidelines

        ## 5. Backup and Restore
        - Backup schedule and procedures
        - Backup verification
        - Restore procedures
        - Disaster recovery plan

        ## 6. Incident Response Playbook
        - Incident severity levels
        - Response procedures for each severity
        - Communication protocols
        - Post-incident review process

        ## 7. Maintenance Procedures
        - Regular maintenance tasks
        - Upgrade procedures
        - Database maintenance
        - Log rotation and cleanup

        ## 8. On-Call Resources
        - Contact information
        - System access credentials locations
        - Escalation paths
        - Emergency procedures

        Provide the COMPLETE operations runbook content as markdown.
        
        Respond with 'yes' or 'no'
    depends_on:
      - write_api_docs

  - id: write_runbook
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/docs/RUNBOOK.md"
      content: "${blocks.request_runbook.response}"
      encoding: "utf-8"
    depends_on:
      - request_runbook

  - id: request_readme_update
    type: Prompt
    inputs:
      prompt: |
        === UPDATE README.md ===

        Create comprehensive README.md for ${inputs.project_name} v${inputs.version}.

        Structure as follows:

        # ${inputs.project_name}

        **Version:** ${inputs.version}
        **Author:** ${inputs.author}

        ## Overview
        [Brief project description - what it does and why it exists]

        ## Features
        - Feature 1
        - Feature 2
        - Feature 3
        [List key features with brief descriptions]

        ## Quick Start

        ```bash
        # Installation
        pip install ${inputs.project_name}

        # Basic usage
        ${inputs.project_name} --help
        ```

        ## Installation

        ### Requirements
        - Python ${inputs.python_version}
        - [Other requirements]

        ### Install from PyPI
        ```bash
        pip install ${inputs.project_name}
        ```

        ### Install from Source
        ```bash
        git clone https://github.com/yourorg/${inputs.project_name}.git
        cd ${inputs.project_name}
        pip install -e .
        ```

        ## Usage

        [Basic usage examples with code snippets]

        ## Documentation

        - [User Guide](docs/USER_GUIDE.md) - Complete user documentation
        - [API Documentation](docs/API.md) - API reference
        - [Deployment Guide](docs/DEPLOYMENT.md) - Deployment instructions
        - [Operations Runbook](docs/RUNBOOK.md) - Operations guide

        ## Development

        ### Running Tests
        ```bash
        pytest tests/ --cov=${inputs.project_name}
        ```

        Coverage: ${inputs.coverage_threshold}%+ required

        ### Code Quality
        ```bash
        ruff check src/
        mypy src/
        ```

        ## Contributing

        [Contributing guidelines]

        ## License

        [License information]

        ## Support

        [How to get help]

        Provide the COMPLETE README.md content as markdown.
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
    depends_on:
      - write_runbook

  - id: write_readme
    type: CreateFile
    inputs:
      path: "${inputs.project_path}/README.md"
      content: "${blocks.request_readme_update.response}"
      encoding: "utf-8"
    depends_on:
      - request_readme_update

  - id: extract_requirements_list
    type: Shell
    inputs:
      command: |
        STATE='${blocks.read_state.state}'

        # Try to extract requirements list from Phase 1
        REQ_LIST=$(echo "$STATE" | grep -o '"requirements_list"[[:space:]]*:[[:space:]]*\[[^]]*\]' | head -1)

        if [ -n "$REQ_LIST" ]; then
          echo "Requirements from Phase 1:"
          echo "$REQ_LIST"
        else
          echo "No requirements list found in state"
        fi

        # Extract module count from Phase 4
        MODULE_COUNT=$(echo "$STATE" | grep -o '"modules"[[:space:]]*:[[:space:]]*\[[^]]*\]' | grep -o '\[' | wc -l)
        echo "$MODULE_COUNT" > "$SCRATCH/module_count.txt"
      timeout: 10
    outputs:
      module_count:
        type: int
        path: "$SCRATCH/module_count.txt"
        description: "Number of modules from Phase 4"
    depends_on:
      - validate_phase6_complete

  - id: create_changelog
    type: Shell
    inputs:
      command: |
        cat > "${inputs.project_path}/CHANGELOG.md" << 'EOF'
        # Changelog

        All notable changes to ${inputs.project_name} will be documented in this file.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
        and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        ## [${inputs.version}] - $(date +%Y-%m-%d)

        ### Added
        - Initial release of ${inputs.project_name}
        - Core functionality implemented with TDD methodology
        - Comprehensive test suite with ${inputs.coverage_threshold}%+ coverage
        - Complete documentation suite:
          - User Guide
          - API Documentation
          - Deployment Guide
          - Operations Runbook
        - Production-ready quality gates passed

        ### Features
        - All PRD requirements implemented and tested
        - ${blocks.validate_phase6_complete.stdout | grep test_count | cut -d= -f2} automated tests
        - ${blocks.validate_phase6_complete.stdout | grep coverage | cut -d= -f2}% code coverage
        - Security scanning passed
        - Performance validation completed

        ### Technical
        - Python ${inputs.python_version} compatible
        - Test-Driven Development methodology
        - Continuous integration ready
        - Production deployment ready

        EOF

        echo "✅ CHANGELOG.md created"
      timeout: 30
    depends_on:
      - write_readme

  - id: verify_project_config
    type: Shell
    inputs:
      command: |
        cd "${inputs.project_path}"

        # Check if pyproject.toml exists
        if [ -f pyproject.toml ]; then
          echo "✅ pyproject.toml found"

          # Verify project name
          if grep -q "name.*${inputs.project_name}" pyproject.toml; then
            echo "✅ Project name matches in pyproject.toml"
          else
            echo "⚠️  WARNING: Project name mismatch in pyproject.toml"
          fi

          # Verify version
          if grep -q "version.*${inputs.version}" pyproject.toml; then
            echo "✅ Version matches in pyproject.toml"
          else
            echo "⚠️  WARNING: Version mismatch in pyproject.toml"
          fi
        else
          echo "⚠️  WARNING: pyproject.toml not found"
        fi

        # Check if setup.py exists (legacy)
        if [ -f setup.py ]; then
          echo "ℹ️  setup.py found (legacy)"
        fi

        echo "true" > "$SCRATCH/config_verified.txt"
      timeout: 30
    outputs:
      config_verified:
        type: bool
        path: "$SCRATCH/config_verified.txt"
        description: "Whether project configuration is verified"
    depends_on:
      - create_changelog

  - id: generate_requirements
    type: Shell
    inputs:
      command: |
        cd "${inputs.project_path}"

        # Generate requirements.txt for deployment
        if command -v uv &> /dev/null; then
          echo "Using uv to generate requirements.txt..."
          uv pip compile pyproject.toml -o requirements.txt 2>/dev/null || {
            echo "⚠️  uv compile failed, trying alternative"
            if [ -f pyproject.toml ]; then
              echo "# Generated from pyproject.toml" > requirements.txt
              echo "# Install with: pip install -r requirements.txt" >> requirements.txt
            fi
          }
        elif command -v pip-compile &> /dev/null; then
          echo "Using pip-compile to generate requirements.txt..."
          pip-compile pyproject.toml -o requirements.txt 2>/dev/null || {
            echo "⚠️  pip-compile failed"
          }
        else
          echo "⚠️  Neither uv nor pip-compile available"
          echo "# Install dependencies from pyproject.toml" > requirements.txt
          echo "# Use: pip install -e ." >> requirements.txt
        fi

        if [ -f requirements.txt ]; then
          echo "✅ requirements.txt generated for deployment"
          echo "true" > "$SCRATCH/requirements_generated.txt"
        else
          echo "⚠️  requirements.txt not generated"
          echo "false" > "$SCRATCH/requirements_generated.txt"
        fi
      timeout: 60
      
    outputs:
      requirements_generated:
        type: bool
        path: "$SCRATCH/requirements_generated.txt"
        description: "Whether requirements.txt was successfully generated"
    depends_on:
      - verify_project_config

  - id: create_deployment_checklist
    type: Shell
    inputs:
      command: |
        # Extract metrics from state
        TOTAL_TESTS="${blocks.validate_phase6_complete.outputs.test_count}"
        COVERAGE="${blocks.validate_phase6_complete.outputs.coverage}"

        cat > "${inputs.project_path}/docs/DEPLOYMENT_CHECKLIST.md" << EOF
        # Deployment Checklist for ${inputs.project_name} v${inputs.version}

        **Generated:** $(date -Iseconds)

        ## Pre-Deployment Verification

        ### Quality Assurance
        - [ ] All tests passing (${TOTAL_TESTS:-N/A} tests)
        - [ ] Code coverage ≥ ${inputs.coverage_threshold}% (actual: ${COVERAGE:-N/A}%)
        - [ ] All quality gates passed
        - [ ] Security scan clean (no vulnerabilities)
        - [ ] Performance testing completed
        - [ ] Documentation reviewed and complete

        ### Code Review
        - [ ] Code reviewed by team members
        - [ ] All PR comments addressed
        - [ ] No TODOs or FIXMEs in production code
        - [ ] Code follows style guidelines

        ### Configuration
        - [ ] All environment variables documented
        - [ ] Configuration files reviewed
        - [ ] Secrets management configured
        - [ ] Database connection strings verified

        ## Deployment Steps

        ### 1. Backup
        - [ ] Backup production data (if applicable)
        - [ ] Backup current deployment
        - [ ] Verify backup integrity
        - [ ] Document backup location and timestamp

        ### 2. Staging Deployment
        - [ ] Review DEPLOYMENT.md guide
        - [ ] Verify system requirements met
        - [ ] Deploy to staging environment
        - [ ] Run smoke tests on staging
        - [ ] Verify all features functional
        - [ ] Check logs for errors

        ### 3. Production Deployment
        - [ ] Schedule deployment window
        - [ ] Notify stakeholders of deployment
        - [ ] Deploy to production
        - [ ] Verify health checks pass
        - [ ] Monitor logs for errors
        - [ ] Run production smoke tests
        - [ ] Verify core functionality
        - [ ] Monitor performance metrics

        ### 4. Post-Deployment Validation
        - [ ] Application accessible
        - [ ] Core features functional
        - [ ] API endpoints responding correctly
        - [ ] Database connectivity verified
        - [ ] Performance within acceptable range
        - [ ] No error spikes in logs
        - [ ] Monitoring dashboards operational
        - [ ] Alerts configured and working

        ### 5. Documentation
        - [ ] Document deployment timestamp
        - [ ] Document any issues encountered
        - [ ] Update runbook if needed
        - [ ] Notify team of successful deployment

        ## Rollback Plan

        If deployment fails or critical issues are discovered:

        ### 1. Immediate Actions
        - [ ] Trigger rollback procedure (see DEPLOYMENT.md)
        - [ ] Notify stakeholders of rollback
        - [ ] Stop accepting new traffic (if possible)

        ### 2. Rollback Execution
        - [ ] Restore previous version
        - [ ] Rollback database migrations (if applicable)
        - [ ] Verify rollback successful
        - [ ] Run smoke tests on rolled-back version
        - [ ] Check logs for rollback errors

        ### 3. Post-Rollback
        - [ ] Investigate failure root cause
        - [ ] Document incident and lessons learned
        - [ ] Create tickets for fixes
        - [ ] Plan corrective deployment
        - [ ] Update deployment procedures if needed

        ## Monitoring and Alerts

        ### During Deployment
        - [ ] Monitor error rates
        - [ ] Monitor response times
        - [ ] Monitor resource utilization (CPU, memory, disk)
        - [ ] Monitor database connections
        - [ ] Watch for alert triggers

        ### Post-Deployment (24-48 hours)
        - [ ] Continued monitoring of error rates
        - [ ] Performance trend analysis
        - [ ] User feedback collection
        - [ ] Resource utilization trends
        - [ ] Alert frequency analysis

        ## Sign-Off

        - **Deployed By:** ___________________
        - **Deployment Date/Time:** ___________________
        - **Verified By:** ___________________
        - **Verification Date/Time:** ___________________
        - **Deployment Status:** ☐ Success ☐ Partial ☐ Rollback
        - **Notes:** ___________________

        EOF

        echo "✅ Deployment checklist created: ${inputs.project_path}/docs/DEPLOYMENT_CHECKLIST.md"
      timeout: 30
    depends_on:
      - generate_requirements

  - id: update_state_phase7
    type: Shell
    inputs:
      command: |
        # Create Python script to update state
        cat > /tmp/update_phase7_state.py << 'PYTHON_SCRIPT'
        import json
        import sys
        from pathlib import Path
        from datetime import datetime

        # Get arguments
        state_file = Path(sys.argv[1])
        project_name = sys.argv[2]
        version = sys.argv[3]

        # Read existing state
        state = json.loads(state_file.read_text())

        # Ensure required keys exist
        if 'phases_completed' not in state:
            state['phases_completed'] = []

        # Add phase7_complete to completed phases
        if 'phase7_complete' not in state['phases_completed']:
            state['phases_completed'].append('phase7_complete')

        # Update phase7 metrics
        state['phase7'] = {
            'documentation_complete': True,
            'deployment_guide': 'docs/DEPLOYMENT.md',
            'user_guide': 'docs/USER_GUIDE.md',
            'api_docs': 'docs/API.md',
            'runbook': 'docs/RUNBOOK.md',
            'changelog': 'CHANGELOG.md',
            'readme_updated': True,
            'deployment_checklist': 'docs/DEPLOYMENT_CHECKLIST.md',
            'package_verified': True,
            'requirements_generated': True,
            'ready_for_deployment': True,
            'completed_at': datetime.now().isoformat()
        }

        # Mark project as complete
        state['current_phase'] = 'phase7_complete'
        state['project_complete'] = True
        state['project_info'] = {
            'name': project_name,
            'version': version,
            'completion_date': datetime.now().isoformat()
        }

        # Write back
        state_file.write_text(json.dumps(state, indent=2) + '\n')

        print(f'✅ Phase 7 complete:')
        print(f'   Project: {project_name} v{version}')
        print(f'   Documentation: Complete')
        print(f'   Deployment: Ready')
        print(f'   Status: Production-ready')
        PYTHON_SCRIPT

        # Run the Python script
        python3 /tmp/update_phase7_state.py \
          "${inputs.project_path}/${inputs.state_file}" \
          "${inputs.project_name}" \
          "${inputs.version}"
      timeout: 30
    depends_on:
      - create_deployment_checklist

  - id: final_completion_checkpoint
    type: Prompt
    inputs:
      prompt: |
        ╔═══════════════════════════════════════════════════════════╗
        ║  🎉 TDD PROJECT DEVELOPMENT COMPLETE! 🎉                  ║
        ╚═══════════════════════════════════════════════════════════╝

        Project: ${inputs.project_name} v${inputs.version}
        Completed: $(date)

        📊 Project Statistics:
        - Total tests: ${blocks.validate_phase6_complete.stdout | grep test_count | cut -d= -f2}
        - Test coverage: ${blocks.validate_phase6_complete.stdout | grep coverage | cut -d= -f2}%
        - Coverage threshold: ${inputs.coverage_threshold}%

        📚 Documentation Generated:
        - ✅ docs/DEPLOYMENT.md - Deployment guide
        - ✅ docs/USER_GUIDE.md - User documentation
        - ✅ docs/API.md - API documentation
        - ✅ docs/RUNBOOK.md - Operations runbook
        - ✅ docs/DEPLOYMENT_CHECKLIST.md - Deployment checklist
        - ✅ README.md - Project overview
        - ✅ CHANGELOG.md - Version history

        📦 Package Status:
        - ✅ Project configuration verified
        - ✅ Dependencies documented
        - ✅ Ready for deployment

        🚀 Next Steps:
        1. Review all documentation in docs/
        2. Follow docs/DEPLOYMENT_CHECKLIST.md
        3. Deploy to staging environment
        4. Run final acceptance tests
        5. Deploy to production

        Confirm project completion and deployment readiness?
        
        Respond with 'yes' or 'no'
        
        Respond with 'yes' or 'no'
      operation: "phase7_completion_checkpoint"
      details:
        project_name: "${inputs.project_name}"
        version: "${inputs.version}"
        documentation_complete: "true"
        deployment_ready: "true"
    depends_on:
      - update_state_phase7

  - id: final_summary
    type: Shell
    inputs:
      command: |
        # Extract metrics
        TOTAL_TESTS="${blocks.validate_phase6_complete.outputs.test_count}"
        COVERAGE="${blocks.validate_phase6_complete.outputs.coverage}"
        MODULE_COUNT="${blocks.extract_requirements_list.outputs.module_count}"

        echo "╔═══════════════════════════════════════════════════════════╗"
        echo "║       TDD PHASE 7: FINALIZATION COMPLETE                 ║"
        echo "╚═══════════════════════════════════════════════════════════╝"
        echo ""
        echo "Project: ${inputs.project_name} v${inputs.version}"
        echo "Author: ${inputs.author}"
        echo "Completion Date: $(date)"
        echo ""
        echo "📊 Project Statistics:"
        echo "  - Modules implemented: ${MODULE_COUNT:-N/A}"
        echo "  - Total tests: ${TOTAL_TESTS:-N/A}"
        echo "  - Test coverage: ${COVERAGE:-N/A}%"
        echo "  - Quality gates: All passed ✅"
        echo ""
        echo "📚 Documentation Generated:"
        echo "  ✅ ${inputs.project_path}/docs/DEPLOYMENT.md"
        echo "  ✅ ${inputs.project_path}/docs/USER_GUIDE.md"
        echo "  ✅ ${inputs.project_path}/docs/API.md"
        echo "  ✅ ${inputs.project_path}/docs/RUNBOOK.md"
        echo "  ✅ ${inputs.project_path}/docs/DEPLOYMENT_CHECKLIST.md"
        echo "  ✅ ${inputs.project_path}/README.md"
        echo "  ✅ ${inputs.project_path}/CHANGELOG.md"
        echo ""
        echo "📦 Package Status:"
        echo "  - Configuration: ${blocks.verify_project_config.stdout | grep config_verified | cut -d= -f2}"
        echo "  - Requirements: ${blocks.generate_requirements.stdout | grep requirements_generated | cut -d= -f2}"
        echo "  - Deployment: Ready ✅"
        echo ""
        echo "🚀 Deployment Instructions:"
        echo "  1. Review: ${inputs.project_path}/docs/DEPLOYMENT_CHECKLIST.md"
        echo "  2. Follow: ${inputs.project_path}/docs/DEPLOYMENT.md"
        echo "  3. Monitor: ${inputs.project_path}/docs/RUNBOOK.md"
        echo ""
        echo "✅ PROJECT READY FOR PRODUCTION DEPLOYMENT!"
        echo ""
        echo "State file: ${inputs.project_path}/${inputs.state_file}"
        echo "Project complete: true"
      timeout: 10
    depends_on:
      - final_completion_checkpoint

outputs:
  # Documentation paths
  deployment_guide_path: "${inputs.project_path}/docs/DEPLOYMENT.md"
  user_guide_path: "${inputs.project_path}/docs/USER_GUIDE.md"
  api_docs_path: "${inputs.project_path}/docs/API.md"
  runbook_path: "${inputs.project_path}/docs/RUNBOOK.md"
  changelog_path: "${inputs.project_path}/CHANGELOG.md"
  readme_path: "${inputs.project_path}/README.md"
  deployment_checklist_path: "${inputs.project_path}/docs/DEPLOYMENT_CHECKLIST.md"

  # Status indicators
  documentation_complete: "true"
  readme_updated: "true"
  package_created: "${blocks.verify_project_config.outputs.config_verified}"
  requirements_generated: "${blocks.generate_requirements.outputs.requirements_generated}"
  project_complete: "true"
  deployment_ready: "${blocks.final_completion_checkpoint.outputs.response == 'yes'}"

  # Project info
  project_name: "${inputs.project_name}"
  project_version: "${inputs.version}"
  project_author: "${inputs.author}"

  # Checkpoint
  completion_confirmed: "${blocks.final_completion_checkpoint.outputs.response == 'yes'}"

  # State
  state_updated: "${blocks.update_state_phase7.succeeded}"
  state_file_path: "${inputs.project_path}/${inputs.state_file}"

  # Summary
  summary: "${blocks.final_summary.outputs.stdout}"
