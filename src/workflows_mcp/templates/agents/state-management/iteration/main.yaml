name: agent-iteration
description: |
  Iteration tracking for agentic workflows.

  Provides loop tracking with automatic progress computation.
  Stores iteration state in the main state file under `iterations` key.

  Operations:
  - init: Initialize iteration counter for a task
  - advance: Increment counter and compute rate/progress
  - checkpoint: Save intermediate state for recovery
  - complete: Mark iteration as done, compute final stats
  - reset: Reset iteration counter to zero

  Auto-computed outputs:
  - progress_pct: Percentage complete (if total provided)
  - progress_str: "5/10 (50%)" or "5 (cap: 20)"
  - rate: Iterations per second
  - eta_seconds: Estimated seconds remaining (if total provided)
  - is_capped: True if current >= cap (safety limit reached)

  Example:
    # Initialize iteration
    - id: init_iter
      type: Workflow
      inputs:
        workflow: agent-iteration
        inputs:
          state_path: "{{state.path}}"
          task_id: "{{state.task_id}}"
          op: init
          total: 10
          cap: 20

    # In loop, advance
    - id: advance
      type: Workflow
      inputs:
        workflow: agent-iteration
        inputs:
          state_path: "{{state.path}}"
          task_id: "{{state.task_id}}"
          op: advance

tags: [agent, iteration, state-management, loop-tracking, progress]

inputs:
  state_path:
    type: str
    description: Path to the state file.
    required: true

  task_id:
    type: str
    description: Task ID this iteration belongs to.
    required: true

  op:
    type: str
    description: |
      Iteration operation to perform:
      - init: Initialize new iteration counter
      - advance: Increment counter and update stats
      - checkpoint: Save checkpoint data
      - complete: Mark iteration as complete
      - reset: Reset counter to zero
    required: true

  total:
    type: num
    description: |
      Expected total iterations (for progress calculation).
      Optional for unbounded iterations.
    required: false
    default: 0

  cap:
    type: num
    description: Maximum iterations allowed (safety limit).
    required: false
    default: 100

  checkpoint_data:
    type: str
    description: JSON data to save with checkpoint.
    required: false
    default: ""

blocks:
  # ==========================================================================
  # Execute iteration operation
  # ==========================================================================
  - id: execute
    type: Shell
    description: Execute the iteration operation.
    inputs:
      command: |
        python3 << 'EOF'
        import os
        import json
        from datetime import datetime, timezone
        from pathlib import Path

        # Load inputs
        state_path = os.environ['STATE_PATH']
        task_id = os.environ['TASK_ID']
        op = os.environ['OP']
        total = int(os.environ.get('TOTAL', '0'))
        cap = int(os.environ.get('CAP', '100'))
        checkpoint_json = os.environ.get('CHECKPOINT_DATA', '')

        # Parse checkpoint data
        checkpoint_data = None
        if checkpoint_json:
            try:
                checkpoint_data = json.loads(checkpoint_json)
            except json.JSONDecodeError:
                checkpoint_data = {"raw": checkpoint_json}

        now = datetime.now(timezone.utc).isoformat()

        def load_state(path: str) -> dict:
            """Load state file or create empty structure."""
            if os.path.isfile(path):
                with open(path) as f:
                    return json.load(f)
            return {
                'created_at': now,
                'updated_at': now,
                'tasks': {},
                'iterations': {}
            }

        def save_state(path: str, state: dict) -> None:
            """Save state file."""
            state['updated_at'] = now
            Path(path).parent.mkdir(parents=True, exist_ok=True)
            with open(path, 'w') as f:
                json.dump(state, f, indent=2)

        def compute_rate(started_at: str, current: int) -> float:
            """Compute iterations per second."""
            if not started_at or current <= 0:
                return 0.0
            try:
                start = datetime.fromisoformat(started_at.replace('Z', '+00:00'))
                elapsed = (datetime.now(timezone.utc) - start).total_seconds()
                return current / elapsed if elapsed > 0 else 0.0
            except (ValueError, TypeError):
                return 0.0

        def compute_progress(current: int, total: int, cap: int) -> dict:
            """Compute progress metrics."""
            is_capped = current >= cap

            if total > 0:
                progress_pct = min(100.0, round((current / total) * 100, 1))
                progress_str = f"{current}/{total} ({progress_pct}%)"
            else:
                progress_pct = 0.0
                progress_str = f"{current} (cap: {cap})"

            return {
                'progress_pct': progress_pct,
                'progress_str': progress_str,
                'is_capped': is_capped
            }

        def compute_eta(current: int, total: int, rate: float) -> float:
            """Compute estimated seconds remaining."""
            if total <= 0 or rate <= 0 or current >= total:
                return 0.0
            remaining = total - current
            return round(remaining / rate, 1)

        # Load state
        state = load_state(state_path)

        # Ensure iterations key exists
        if 'iterations' not in state:
            state['iterations'] = {}

        iterations = state['iterations']

        # Result structure
        result = {
            'current': 0,
            'total': total,
            'cap': cap,
            'progress_pct': 0.0,
            'progress_str': '0',
            'rate': 0.0,
            'eta_seconds': 0.0,
            'is_capped': False,
            'checkpoint': None,
            'started_at': '',
            'updated_at': now,
            'op': op,
            'task_id': task_id
        }

        # Execute operation
        if op == 'init':
            # Initialize new iteration counter
            iterations[task_id] = {
                'current': 0,
                'total': total,
                'cap': cap,
                'started_at': now,
                'updated_at': now,
                'checkpoints': []
            }
            save_state(state_path, state)
            result['started_at'] = now
            result['progress_str'] = f"0/{total} (0%)" if total > 0 else f"0 (cap: {cap})"

        elif op == 'advance':
            if task_id not in iterations:
                raise ValueError(f"No iteration found for task {task_id}. Call init first.")

            iter_data = iterations[task_id]
            iter_data['current'] += 1
            iter_data['updated_at'] = now

            current = iter_data['current']
            iter_total = iter_data.get('total', total) or total
            iter_cap = iter_data.get('cap', cap) or cap

            # Update computed values
            rate = compute_rate(iter_data.get('started_at'), current)
            progress = compute_progress(current, iter_total, iter_cap)
            eta = compute_eta(current, iter_total, rate)

            save_state(state_path, state)

            result.update({
                'current': current,
                'total': iter_total,
                'cap': iter_cap,
                'rate': round(rate, 3),
                'eta_seconds': eta,
                'started_at': iter_data.get('started_at', ''),
                **progress
            })

        elif op == 'checkpoint':
            if task_id not in iterations:
                raise ValueError(f"No iteration found for task {task_id}. Call init first.")

            iter_data = iterations[task_id]
            current = iter_data['current']

            # Add checkpoint
            checkpoint_entry = {
                'at_index': current,
                'created_at': now,
                'data': checkpoint_data
            }
            if 'checkpoints' not in iter_data:
                iter_data['checkpoints'] = []
            iter_data['checkpoints'].append(checkpoint_entry)
            iter_data['updated_at'] = now

            save_state(state_path, state)

            result.update({
                'current': current,
                'total': iter_data.get('total', total),
                'cap': iter_data.get('cap', cap),
                'checkpoint': checkpoint_data,
                'started_at': iter_data.get('started_at', '')
            })
            progress = compute_progress(current, iter_data.get('total', total), iter_data.get('cap', cap))
            result.update(progress)

        elif op == 'complete':
            if task_id not in iterations:
                raise ValueError(f"No iteration found for task {task_id}. Call init first.")

            iter_data = iterations[task_id]
            iter_data['completed_at'] = now
            iter_data['updated_at'] = now

            current = iter_data['current']
            iter_total = iter_data.get('total', total) or total
            iter_cap = iter_data.get('cap', cap) or cap

            # Final stats
            rate = compute_rate(iter_data.get('started_at'), current)
            progress = compute_progress(current, iter_total, iter_cap)

            # Calculate total duration
            duration = 0.0
            if iter_data.get('started_at'):
                try:
                    start = datetime.fromisoformat(iter_data['started_at'].replace('Z', '+00:00'))
                    duration = (datetime.now(timezone.utc) - start).total_seconds()
                except (ValueError, TypeError):
                    pass

            iter_data['duration_seconds'] = round(duration, 2)
            iter_data['final_rate'] = round(rate, 3)

            save_state(state_path, state)

            result.update({
                'current': current,
                'total': iter_total,
                'cap': iter_cap,
                'rate': round(rate, 3),
                'eta_seconds': 0.0,
                'started_at': iter_data.get('started_at', ''),
                **progress
            })

        elif op == 'reset':
            if task_id in iterations:
                iterations[task_id] = {
                    'current': 0,
                    'total': total,
                    'cap': cap,
                    'started_at': now,
                    'updated_at': now,
                    'checkpoints': []
                }
                save_state(state_path, state)

            result['started_at'] = now
            result['progress_str'] = f"0/{total} (0%)" if total > 0 else f"0 (cap: {cap})"

        else:
            raise ValueError(f"Unknown operation: {op}")

        print(json.dumps(result))
        EOF
      env:
        STATE_PATH: "{{inputs.state_path}}"
        TASK_ID: "{{inputs.task_id}}"
        OP: "{{inputs.op}}"
        TOTAL: "{{inputs.total}}"
        CAP: "{{inputs.cap}}"
        CHECKPOINT_DATA: "{{inputs.checkpoint_data}}"

outputs:
  current:
    description: Current iteration index (0-based).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).current}}"

  total:
    description: Expected total iterations (0 if unbounded).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).total}}"

  cap:
    description: Maximum iterations allowed (safety limit).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).cap}}"

  progress_pct:
    description: Percentage complete (0-100).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).progress_pct}}"

  progress_str:
    description: Human-readable progress string (e.g., "5/10 (50%)").
    type: str
    value: "{{(blocks.execute.outputs.stdout | fromjson).progress_str}}"

  rate:
    description: Iterations per second.
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).rate}}"

  eta_seconds:
    description: Estimated seconds remaining (0 if unbounded or complete).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).eta_seconds}}"

  is_capped:
    description: True if current >= cap (safety limit reached).
    type: bool
    value: "{{(blocks.execute.outputs.stdout | fromjson).is_capped}}"

  checkpoint:
    description: Last checkpoint data (for checkpoint operation).
    type: json
    value: "{{(blocks.execute.outputs.stdout | fromjson).checkpoint}}"
