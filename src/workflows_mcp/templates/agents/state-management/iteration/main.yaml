name: agent-iteration
description: |
  Iteration tracking for agentic workflows using SQLite.

  Provides loop tracking with automatic progress computation.
  Stores iteration state in the SQLite iterations table.

  Operations:
  - init: Initialize iteration counter for a task
  - advance: Increment counter and compute rate/progress
  - checkpoint: Save intermediate state for recovery
  - complete: Mark iteration as done, compute final stats
  - reset: Reset iteration counter to zero

  Auto-computed outputs:
  - progress_pct: Percentage complete (if total provided)
  - progress_str: "5/10 (50%)" or "5 (cap: 20)"
  - rate: Iterations per second
  - eta_seconds: Estimated seconds remaining (if total provided)
  - is_capped: True if current >= cap (safety limit reached)

  Example:
    # Initialize iteration
    - id: init_iter
      type: Workflow
      inputs:
        workflow: agent-iteration
        inputs:
          path: "{{state.db_path}}"
          task_id: "{{state.task_id}}"
          op: init
          total: 10
          cap: 20

    # In loop, advance
    - id: advance
      type: Workflow
      inputs:
        workflow: agent-iteration
        inputs:
          path: "{{state.db_path}}"
          task_id: "{{state.task_id}}"
          op: advance

tags: [agent, iteration, state-management, loop-tracking, progress, sqlite]

inputs:
  path:
    type: str
    description: Path to the SQLite database file.
    required: true

  task_id:
    type: str
    description: Task ID this iteration belongs to.
    required: true

  op:
    type: str
    description: |
      Iteration operation to perform:
      - init: Initialize new iteration counter
      - advance: Increment counter and update stats
      - checkpoint: Save checkpoint data
      - complete: Mark iteration as complete
      - reset: Reset counter to zero
    required: true

  total:
    type: num
    description: |
      Expected total iterations (for progress calculation).
      Optional for unbounded iterations.
    required: false
    default: 0

  cap:
    type: num
    description: Maximum iterations allowed (safety limit).
    required: false
    default: 100

  checkpoint_data:
    type: str
    description: JSON data to save with checkpoint.
    required: false
    default: ""

blocks:
  # ==========================================================================
  # Execute iteration operation using SQLite
  # ==========================================================================
  - id: execute
    type: Shell
    description: Execute the iteration operation on SQLite iterations table.
    inputs:
      command: |
        python3 << 'EOF'
        import os, json, sqlite3
        from datetime import datetime, timezone

        # Load inputs
        db_path = os.environ['DB_PATH']
        task_id = os.environ['TASK_ID']
        op = os.environ['OP']
        total = int(os.environ.get('TOTAL', '0'))
        cap = int(os.environ.get('CAP', '100'))
        checkpoint_json = os.environ.get('CHECKPOINT_DATA', '')

        # Parse checkpoint data
        checkpoint_data = None
        if checkpoint_json:
            try:
                checkpoint_data = json.loads(checkpoint_json)
            except json.JSONDecodeError:
                checkpoint_data = {"raw": checkpoint_json}

        now = datetime.now(timezone.utc).isoformat()

        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA busy_timeout=30000")

        def compute_rate(started_at: str, current: int) -> float:
            """Compute iterations per second."""
            if not started_at or current <= 0:
                return 0.0
            try:
                start = datetime.fromisoformat(started_at.replace('Z', '+00:00'))
                elapsed = (datetime.now(timezone.utc) - start).total_seconds()
                return current / elapsed if elapsed > 0 else 0.0
            except (ValueError, TypeError):
                return 0.0

        def compute_progress(current: int, total: int, cap: int) -> dict:
            """Compute progress metrics."""
            is_capped = current >= cap

            if total > 0:
                progress_pct = min(100.0, round((current / total) * 100, 1))
                progress_str = f"{current}/{total} ({progress_pct}%)"
            else:
                progress_pct = 0.0
                progress_str = f"{current} (cap: {cap})"

            return {
                'progress_pct': progress_pct,
                'progress_str': progress_str,
                'is_capped': is_capped
            }

        def compute_eta(current: int, total: int, rate: float) -> float:
            """Compute estimated seconds remaining."""
            if total <= 0 or rate <= 0 or current >= total:
                return 0.0
            remaining = total - current
            return round(remaining / rate, 1)

        # Result structure
        result = {
            'current': 0,
            'total': total,
            'cap': cap,
            'progress_pct': 0.0,
            'progress_str': '0',
            'rate': 0.0,
            'eta_seconds': 0.0,
            'is_capped': False,
            'checkpoint': None,
            'started_at': '',
            'updated_at': now,
            'op': op,
            'task_id': task_id
        }

        # Execute operation
        if op == 'init':
            # Initialize new iteration counter
            conn.execute('''
                INSERT OR REPLACE INTO iterations (task_id, current, total, cap, started_at, checkpoints)
                VALUES (?, 0, ?, ?, ?, '[]')
            ''', (task_id, total, cap, now))
            conn.commit()

            result['started_at'] = now
            result['progress_str'] = f"0/{total} (0%)" if total > 0 else f"0 (cap: {cap})"

        elif op == 'advance':
            # Atomic increment using UPDATE ... RETURNING for race-free operation
            conn.execute("BEGIN IMMEDIATE")  # Acquire write lock immediately
            try:
                # Atomic increment
                conn.execute(
                    "UPDATE iterations SET current = current + 1 WHERE task_id=?",
                    (task_id,)
                )
                # Get updated row
                row = conn.execute(
                    "SELECT * FROM iterations WHERE task_id=?", (task_id,)
                ).fetchone()
                conn.commit()
            except Exception:
                conn.rollback()
                raise

            if not row:
                raise ValueError(f"No iteration found for task {task_id}. Call init first.")

            current = row['current']
            iter_total = row['total'] or total
            iter_cap = row['cap'] or cap
            started_at = row['started_at'] or ''

            # Compute stats
            rate = compute_rate(started_at, current)
            progress = compute_progress(current, iter_total, iter_cap)
            eta = compute_eta(current, iter_total, rate)

            result.update({
                'current': current,
                'total': iter_total,
                'cap': iter_cap,
                'rate': round(rate, 3),
                'eta_seconds': eta,
                'started_at': started_at,
                **progress
            })

        elif op == 'checkpoint':
            # Get current iteration
            row = conn.execute(
                "SELECT * FROM iterations WHERE task_id=?", (task_id,)
            ).fetchone()

            if not row:
                raise ValueError(f"No iteration found for task {task_id}. Call init first.")

            current = row['current']
            iter_total = row['total'] or total
            iter_cap = row['cap'] or cap
            started_at = row['started_at'] or ''

            # Get existing checkpoints
            checkpoints = json.loads(row['checkpoints'] or '[]')

            # Add checkpoint
            checkpoint_entry = {
                'at_index': current,
                'created_at': now,
                'data': checkpoint_data
            }
            checkpoints.append(checkpoint_entry)

            # Update checkpoints
            conn.execute(
                "UPDATE iterations SET checkpoints=? WHERE task_id=?",
                (json.dumps(checkpoints), task_id)
            )
            conn.commit()

            progress = compute_progress(current, iter_total, iter_cap)
            result.update({
                'current': current,
                'total': iter_total,
                'cap': iter_cap,
                'checkpoint': checkpoint_data,
                'started_at': started_at,
                **progress
            })

        elif op == 'complete':
            # Get current iteration
            row = conn.execute(
                "SELECT * FROM iterations WHERE task_id=?", (task_id,)
            ).fetchone()

            if not row:
                raise ValueError(f"No iteration found for task {task_id}. Call init first.")

            current = row['current']
            iter_total = row['total'] or total
            iter_cap = row['cap'] or cap
            started_at = row['started_at'] or ''

            # Update completed_at
            conn.execute(
                "UPDATE iterations SET completed_at=? WHERE task_id=?",
                (now, task_id)
            )
            conn.commit()

            # Final stats
            rate = compute_rate(started_at, current)
            progress = compute_progress(current, iter_total, iter_cap)

            result.update({
                'current': current,
                'total': iter_total,
                'cap': iter_cap,
                'rate': round(rate, 3),
                'eta_seconds': 0.0,
                'started_at': started_at,
                **progress
            })

        elif op == 'reset':
            # Reset iteration (insert or update)
            conn.execute('''
                INSERT OR REPLACE INTO iterations (task_id, current, total, cap, started_at, checkpoints)
                VALUES (?, 0, ?, ?, ?, '[]')
            ''', (task_id, total, cap, now))
            conn.commit()

            result['started_at'] = now
            result['progress_str'] = f"0/{total} (0%)" if total > 0 else f"0 (cap: {cap})"

        else:
            raise ValueError(f"Unknown operation: {op}")

        conn.close()
        print(json.dumps(result))
        EOF
      env:
        DB_PATH: "{{inputs.path}}"
        TASK_ID: "{{inputs.task_id}}"
        OP: "{{inputs.op}}"
        TOTAL: "{{inputs.total}}"
        CAP: "{{inputs.cap}}"
        CHECKPOINT_DATA: "{{inputs.checkpoint_data}}"

outputs:
  current:
    description: Current iteration index (0-based).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).current}}"

  total:
    description: Expected total iterations (0 if unbounded).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).total}}"

  cap:
    description: Maximum iterations allowed (safety limit).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).cap}}"

  progress_pct:
    description: Percentage complete (0-100).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).progress_pct}}"

  progress_str:
    description: Human-readable progress string (e.g., "5/10 (50%)").
    type: str
    value: "{{(blocks.execute.outputs.stdout | fromjson).progress_str}}"

  rate:
    description: Iterations per second.
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).rate}}"

  eta_seconds:
    description: Estimated seconds remaining (0 if unbounded or complete).
    type: num
    value: "{{(blocks.execute.outputs.stdout | fromjson).eta_seconds}}"

  is_capped:
    description: True if current >= cap (safety limit reached).
    type: bool
    value: "{{(blocks.execute.outputs.stdout | fromjson).is_capped}}"

  checkpoint:
    description: Last checkpoint data (for checkpoint operation).
    type: json
    value: "{{(blocks.execute.outputs.stdout | fromjson).checkpoint}}"
