name: agent-actions
description: |
  Action logging for deduplication and recovery.

  Tracks mutations to prevent duplicate operations and enable recovery.
  Uses hash of inputs for deduplication - identical (capability, inputs)
  combinations return cached results instead of re-executing.

  Action statuses:
  - pending: Action logged but not yet executed
  - completed: Successfully executed
  - failed: Execution failed
  - rolled_back: Action was reversed

  Operations:
  - log: Log a new action (returns existing if duplicate)
  - check: Check if action already exists/completed
  - complete: Mark action as completed with result
  - fail: Mark action as failed with error
  - query: Query actions by cell/capability

tags: [agent, memory, actions, deduplication, sqlite, cortex]

inputs:
  path:
    type: str
    description: Path to SQLite database file.
    required: true

  op:
    type: str
    description: |
      Actions operation to perform:
      - log: Log a new action (returns existing if duplicate)
      - check: Check if action already exists/completed
      - complete: Mark action as completed with result
      - fail: Mark action as failed with error
      - query: Query actions by cell/capability
    required: true

  cell_id:
    type: str
    description: Cell ID requesting the action.
    required: false
    default: ""

  capability:
    type: str
    description: Capability workflow name.
    required: false
    default: ""

  inputs_json:
    type: str
    description: Action inputs (JSON string).
    required: false
    default: "{}"

  result_json:
    type: str
    description: Action result (JSON string) for complete/fail operation.
    required: false
    default: ""

  action_id:
    type: str
    description: Action ID for complete/fail/query operations.
    required: false
    default: ""

  status_filter:
    type: str
    description: Filter by status for query op.
    required: false
    default: ""

  limit:
    type: num
    description: Max results for query.
    required: false
    default: 100

blocks:
  - id: execute
    type: Shell
    description: Execute the actions operation on SQLite actions table.
    inputs:
      command: |
        python3 << 'EOF'
        import os, json, sqlite3, uuid, hashlib
        from datetime import datetime, timezone

        db_path = os.environ['DB_PATH']
        op = os.environ['OP']

        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA busy_timeout=30000")

        now = datetime.now(timezone.utc).isoformat()
        result = {'op': op, 'success': False}

        if op == 'log':
            cell_id = os.environ.get('CELL_ID', '')
            capability = os.environ.get('CAPABILITY', '')
            inputs_json = os.environ.get('INPUTS_JSON', '{}')

            # Compute hash for deduplication
            inputs_hash = hashlib.sha256(
                f"{capability}:{inputs_json}".encode()
            ).hexdigest()[:32]

            # Check if already exists
            existing = conn.execute('''
                SELECT * FROM actions WHERE capability = ? AND inputs_hash = ?
            ''', (capability, inputs_hash)).fetchone()

            if existing:
                result = {
                    'op': op,
                    'success': True,
                    'action_id': existing['id'],
                    'status': existing['status'],
                    'already_exists': True,
                    'result': json.loads(existing['result']) if existing['result'] else None
                }
            else:
                action_id = str(uuid.uuid4())
                conn.execute('''
                    INSERT INTO actions (id, cell_id, capability, inputs_hash, inputs,
                                         status, created_at)
                    VALUES (?, ?, ?, ?, ?, 'pending', ?)
                ''', (action_id, cell_id, capability, inputs_hash, inputs_json, now))
                conn.commit()
                result = {
                    'op': op,
                    'success': True,
                    'action_id': action_id,
                    'status': 'pending',
                    'already_exists': False
                }

        elif op == 'check':
            capability = os.environ.get('CAPABILITY', '')
            inputs_json = os.environ.get('INPUTS_JSON', '{}')

            inputs_hash = hashlib.sha256(
                f"{capability}:{inputs_json}".encode()
            ).hexdigest()[:32]

            existing = conn.execute('''
                SELECT * FROM actions WHERE capability = ? AND inputs_hash = ?
            ''', (capability, inputs_hash)).fetchone()

            if existing:
                result = {
                    'op': op,
                    'success': True,
                    'exists': True,
                    'action_id': existing['id'],
                    'status': existing['status'],
                    'result': json.loads(existing['result']) if existing['result'] else None
                }
            else:
                result = {'op': op, 'success': True, 'exists': False}

        elif op == 'complete':
            action_id = os.environ.get('ACTION_ID', '')
            result_json = os.environ.get('RESULT_JSON', '')

            conn.execute('''
                UPDATE actions SET status = 'completed', result = ?, completed_at = ?
                WHERE id = ?
            ''', (result_json, now, action_id))
            conn.commit()
            result = {
                'op': op,
                'success': True,
                'action_id': action_id,
                'status': 'completed'
            }

        elif op == 'fail':
            action_id = os.environ.get('ACTION_ID', '')
            result_json = os.environ.get('RESULT_JSON', '')  # Error info

            conn.execute('''
                UPDATE actions SET status = 'failed', result = ?, completed_at = ?
                WHERE id = ?
            ''', (result_json, now, action_id))
            conn.commit()
            result = {
                'op': op,
                'success': True,
                'action_id': action_id,
                'status': 'failed'
            }

        elif op == 'query':
            cell_id = os.environ.get('CELL_ID', '')
            capability = os.environ.get('CAPABILITY', '')
            status_filter = os.environ.get('STATUS_FILTER', '')
            limit = int(os.environ.get('LIMIT', '100'))

            sql = "SELECT * FROM actions WHERE 1=1"
            params = []
            if cell_id:
                sql += " AND cell_id = ?"
                params.append(cell_id)
            if capability:
                sql += " AND capability = ?"
                params.append(capability)
            if status_filter:
                sql += " AND status = ?"
                params.append(status_filter)
            sql += f" ORDER BY created_at DESC LIMIT {limit}"

            rows = conn.execute(sql, params).fetchall()
            items = []
            for row in rows:
                item = dict(row)
                # Parse result JSON if present
                if item.get('result'):
                    try:
                        item['result'] = json.loads(item['result'])
                    except:
                        pass
                items.append(item)
            result = {'op': op, 'success': True, 'items': items, 'count': len(items)}

        else:
            result = {'op': op, 'success': False, 'error': f'Unknown operation: {op}'}

        conn.close()
        print(json.dumps(result))
        EOF
      env:
        DB_PATH: "{{inputs.path}}"
        OP: "{{inputs.op}}"
        CELL_ID: "{{inputs.cell_id}}"
        CAPABILITY: "{{inputs.capability}}"
        INPUTS_JSON: "{{inputs.inputs_json}}"
        RESULT_JSON: "{{inputs.result_json}}"
        ACTION_ID: "{{inputs.action_id}}"
        STATUS_FILTER: "{{inputs.status_filter}}"
        LIMIT: "{{inputs.limit}}"

outputs:
  result:
    type: dict
    description: Full operation result.
    value: "{{blocks.execute.outputs.stdout | fromjson}}"

  success:
    type: bool
    description: Whether the operation succeeded.
    value: "{{(blocks.execute.outputs.stdout | fromjson).success}}"

  action_id:
    type: str
    description: Action ID (for log/complete/fail ops).
    value: "{{(blocks.execute.outputs.stdout | fromjson).action_id | default('')}}"

  already_exists:
    type: bool
    description: Whether action already existed (for log op).
    value: "{{(blocks.execute.outputs.stdout | fromjson).already_exists | default(false)}}"

  status:
    type: str
    description: Action status.
    value: "{{(blocks.execute.outputs.stdout | fromjson).status | default('')}}"

  exists:
    type: bool
    description: Whether action exists (for check op).
    value: "{{(blocks.execute.outputs.stdout | fromjson).exists | default(false)}}"

  items:
    type: list
    description: Query results (for query op).
    value: "{{(blocks.execute.outputs.stdout | fromjson).items | default([])}}"

  count:
    type: num
    description: Number of items returned.
    value: "{{(blocks.execute.outputs.stdout | fromjson).count | default(0)}}"
