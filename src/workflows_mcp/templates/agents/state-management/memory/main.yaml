name: agent-memory
description: |
  Key-value memory storage using SQLite with composite key support.

  Provides shared memory across recursive workflow calls. Uses composite
  primary key (type, key) for namespace isolation between phases/components.

  Operations:
  - set: Store value at (type, key)
  - get: Retrieve value at (type, key)
  - append: Append to list at (type, key)
  - merge: Deep merge dict at (type, key)
  - delete: Remove entry at (type, key)
  - keys: List keys matching pattern within type

  Example:
    # Store findings for categorize phase
    workflow: agent-memory
    inputs:
      path: "{{state.db_path}}"
      op: append
      type: findings
      key: categorize
      value: {"category": "understanding", "confidence": 0.9}

tags: [agent, memory, state-management, key-value, sqlite, composite-key]

inputs:
  path:
    type: str
    description: Path to SQLite database file.
    required: true

  op:
    type: str
    description: |
      Memory operation to perform:
      - set: Store value at (type, key)
      - get: Retrieve value at (type, key)
      - append: Append value to list at (type, key)
      - merge: Deep merge dict at (type, key)
      - delete: Remove entry at (type, key)
      - keys: List keys matching pattern within type
    required: true

  type:
    type: str
    description: |
      Memory namespace type. Forms composite key with 'key'.
      Examples: "findings", "evidence", "understanding"
    required: false
    default: ""

  key:
    type: str
    description: |
      Key within the type namespace.
      Examples: "categorize", "gather", "synthesize"
    required: true

  value:
    type: str
    description: |
      Value for set/append/merge operations (as JSON string).
      - set: Any JSON-serializable value
      - append: Value to add to list
      - merge: Dict to merge into existing dict
    required: false
    default: ""

  default:
    type: str
    description: |
      Default value for get operation if key doesn't exist (as JSON string).
      Returns null if not specified and key missing.
    required: false
    default: ""

blocks:
  # ==========================================================================
  # Execute memory operation using SQLite with composite key (type, key)
  # ==========================================================================
  - id: execute
    type: Shell
    description: Execute the memory operation on SQLite memory table.
    inputs:
      command: |
        python3 << 'EOF'
        import os, json, sqlite3, fnmatch
        from datetime import datetime, timezone

        db_path = os.environ['DB_PATH']
        op = os.environ['OP']
        mem_type = os.environ.get('TYPE', '')
        key = os.environ['KEY']
        value_json = os.environ.get('VALUE', '')
        default_json = os.environ.get('DEFAULT', '')

        # Parse JSON values
        try:
            value = json.loads(value_json) if value_json else None
        except json.JSONDecodeError:
            value = value_json  # Treat as string if not valid JSON

        try:
            default = json.loads(default_json) if default_json else None
        except json.JSONDecodeError:
            default = default_json

        conn = sqlite3.connect(db_path)
        conn.execute("PRAGMA busy_timeout=30000")
        now = datetime.now(timezone.utc).isoformat()

        result = {
            'value': None,
            'exists': False,
            'previous': None,
            'keys': [],
            'op': op,
            'type': mem_type,
            'key': key
        }

        if op == 'get':
            row = conn.execute(
                "SELECT value FROM memory WHERE type=? AND key=?", (mem_type, key)
            ).fetchone()
            if row:
                result['value'] = json.loads(row[0]) if row[0] else None
                result['exists'] = True
            else:
                result['value'] = default
                result['exists'] = False

        elif op == 'set':
            # Get previous value
            row = conn.execute(
                "SELECT value FROM memory WHERE type=? AND key=?", (mem_type, key)
            ).fetchone()
            result['previous'] = json.loads(row[0]) if row and row[0] else None
            result['exists'] = row is not None

            # Set new value
            conn.execute('''
                INSERT OR REPLACE INTO memory (type, key, value, updated_at)
                VALUES (?, ?, ?, ?)
            ''', (mem_type, key, json.dumps(value), now))
            conn.commit()
            result['value'] = value

        elif op == 'append':
            # Atomic read-modify-write with immediate transaction lock
            conn.execute("BEGIN IMMEDIATE")
            try:
                row = conn.execute(
                    "SELECT value FROM memory WHERE type=? AND key=?", (mem_type, key)
                ).fetchone()

                if row and row[0]:
                    current = json.loads(row[0])
                    if not isinstance(current, list):
                        current = [current]
                    result['exists'] = True
                else:
                    current = []
                    result['exists'] = False

                current.append(value)

                conn.execute('''
                    INSERT OR REPLACE INTO memory (type, key, value, updated_at)
                    VALUES (?, ?, ?, ?)
                ''', (mem_type, key, json.dumps(current), now))
                conn.commit()
            except Exception:
                conn.rollback()
                raise
            result['value'] = current

        elif op == 'merge':
            if not isinstance(value, dict):
                raise ValueError("merge requires dict value")

            # Deep merge function
            def deep_merge(base, update):
                merged = base.copy()
                for k, v in update.items():
                    if k in merged and isinstance(merged[k], dict) and isinstance(v, dict):
                        merged[k] = deep_merge(merged[k], v)
                    else:
                        merged[k] = v
                return merged

            # Atomic read-modify-write with immediate transaction lock
            conn.execute("BEGIN IMMEDIATE")
            try:
                row = conn.execute(
                    "SELECT value FROM memory WHERE type=? AND key=?", (mem_type, key)
                ).fetchone()

                if row and row[0]:
                    current = json.loads(row[0])
                    if not isinstance(current, dict):
                        raise ValueError(f"Cannot merge into non-dict at ({mem_type}, {key})")
                    result['exists'] = True
                else:
                    current = {}
                    result['exists'] = False

                merged = deep_merge(current, value)

                conn.execute('''
                    INSERT OR REPLACE INTO memory (type, key, value, updated_at)
                    VALUES (?, ?, ?, ?)
                ''', (mem_type, key, json.dumps(merged), now))
                conn.commit()
            except Exception:
                conn.rollback()
                raise
            result['value'] = merged

        elif op == 'delete':
            row = conn.execute(
                "SELECT value FROM memory WHERE type=? AND key=?", (mem_type, key)
            ).fetchone()

            if row:
                result['previous'] = json.loads(row[0]) if row[0] else None
                result['value'] = result['previous']
                result['exists'] = True
                conn.execute("DELETE FROM memory WHERE type=? AND key=?", (mem_type, key))
                conn.commit()
            else:
                result['exists'] = False

        elif op == 'keys':
            # List keys within the specified type namespace
            rows = conn.execute(
                "SELECT key FROM memory WHERE type=?", (mem_type,)
            ).fetchall()
            all_keys = [r[0] for r in rows]

            # Filter by pattern
            if '*' in key or '?' in key:
                matched = [k for k in all_keys if fnmatch.fnmatch(k, key)]
            else:
                # Prefix match
                matched = [k for k in all_keys if k.startswith(key) or k == key]

            result['keys'] = sorted(matched)
            result['value'] = result['keys']
            result['exists'] = len(matched) > 0

        else:
            raise ValueError(f"Unknown operation: {op}")

        conn.close()
        print(json.dumps(result))
        EOF
      env:
        DB_PATH: "{{inputs.path}}"
        OP: "{{inputs.op}}"
        TYPE: "{{inputs.type}}"
        KEY: "{{inputs.key}}"
        VALUE: "{{inputs.value}}"
        DEFAULT: "{{inputs.default}}"

outputs:
  value:
    description: |
      Retrieved or resulting value:
      - get: Value at key (or default)
      - set: New value that was set
      - append: Updated list
      - merge: Merged dict
      - delete: Deleted value
      - keys: List of matching keys
    type: json
    value: "{{(blocks.execute.outputs.stdout | fromjson).value}}"

  exists:
    description: Whether the key existed before the operation.
    type: bool
    value: "{{(blocks.execute.outputs.stdout | fromjson).exists}}"

  previous:
    description: Previous value (for set/delete operations).
    type: json
    value: "{{(blocks.execute.outputs.stdout | fromjson).previous}}"

  keys:
    description: List of matching keys (for keys operation).
    type: list
    value: "{{(blocks.execute.outputs.stdout | fromjson)['keys']}}"
