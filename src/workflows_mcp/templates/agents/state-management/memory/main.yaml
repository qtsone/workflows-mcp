name: agent-memory
description: |
  Key-value memory storage using SQLite.

  Provides shared memory across recursive workflow calls with flat key storage
  and multiple operations. Keys are stored as-is (dot-notation is treated as
  a string key, not nested path).

  Operations:
  - set: Store value at key (returns previous value)
  - get: Retrieve value at key (returns default if missing)
  - append: Append to list at key (creates list if needed)
  - merge: Deep merge dict into key (creates dict if needed)
  - delete: Remove key (returns deleted value)
  - keys: List keys matching pattern (glob-style)

  Example:
    # Store a finding
    workflow: agent-memory
    inputs:
      path: "{{state.db_path}}"
      op: append
      key: cells.root.findings
      value: {"file": "auth.py", "issue": "Missing validation"}

tags: [agent, memory, state-management, key-value, sqlite]

inputs:
  path:
    type: str
    description: Path to SQLite database file.
    required: true

  op:
    type: str
    description: |
      Memory operation to perform:
      - set: Store value at key
      - get: Retrieve value at key
      - append: Append value to list at key
      - merge: Deep merge dict into key
      - delete: Remove key
      - keys: List keys matching pattern
    required: true

  key:
    type: str
    description: |
      Key for the memory entry.
      Examples: "context.framework", "findings", "cells.root.evidence"
    required: true

  value:
    type: str
    description: |
      Value for set/append/merge operations (as JSON string).
      - set: Any JSON-serializable value
      - append: Value to add to list
      - merge: Dict to merge into existing dict
    required: false
    default: ""

  default:
    type: str
    description: |
      Default value for get operation if key doesn't exist (as JSON string).
      Returns null if not specified and key missing.
    required: false
    default: ""

blocks:
  # ==========================================================================
  # Execute memory operation using SQLite
  # ==========================================================================
  - id: execute
    type: Shell
    description: Execute the memory operation on SQLite memory table.
    inputs:
      command: |
        python3 << 'EOF'
        import os, json, sqlite3, fnmatch
        from datetime import datetime, timezone

        db_path = os.environ['DB_PATH']
        op = os.environ['OP']
        key = os.environ['KEY']
        value_json = os.environ.get('VALUE', '')
        default_json = os.environ.get('DEFAULT', '')

        # Parse JSON values
        try:
            value = json.loads(value_json) if value_json else None
        except json.JSONDecodeError:
            value = value_json  # Treat as string if not valid JSON

        try:
            default = json.loads(default_json) if default_json else None
        except json.JSONDecodeError:
            default = default_json

        conn = sqlite3.connect(db_path)
        conn.execute("PRAGMA busy_timeout=30000")
        now = datetime.now(timezone.utc).isoformat()

        result = {
            'value': None,
            'exists': False,
            'previous': None,
            'keys': [],
            'op': op,
            'key': key
        }

        if op == 'get':
            row = conn.execute(
                "SELECT value FROM memory WHERE key=?", (key,)
            ).fetchone()
            if row:
                result['value'] = json.loads(row[0]) if row[0] else None
                result['exists'] = True
            else:
                result['value'] = default
                result['exists'] = False

        elif op == 'set':
            # Get previous value
            row = conn.execute(
                "SELECT value FROM memory WHERE key=?", (key,)
            ).fetchone()
            result['previous'] = json.loads(row[0]) if row and row[0] else None
            result['exists'] = row is not None

            # Set new value
            conn.execute('''
                INSERT OR REPLACE INTO memory (key, value, updated_at)
                VALUES (?, ?, ?)
            ''', (key, json.dumps(value), now))
            conn.commit()
            result['value'] = value

        elif op == 'append':
            # Atomic read-modify-write with immediate transaction lock
            conn.execute("BEGIN IMMEDIATE")
            try:
                row = conn.execute(
                    "SELECT value FROM memory WHERE key=?", (key,)
                ).fetchone()

                if row and row[0]:
                    current = json.loads(row[0])
                    if not isinstance(current, list):
                        current = [current]
                    result['exists'] = True
                else:
                    current = []
                    result['exists'] = False

                current.append(value)

                conn.execute('''
                    INSERT OR REPLACE INTO memory (key, value, updated_at)
                    VALUES (?, ?, ?)
                ''', (key, json.dumps(current), now))
                conn.commit()
            except Exception:
                conn.rollback()
                raise
            result['value'] = current

        elif op == 'merge':
            if not isinstance(value, dict):
                raise ValueError("merge requires dict value")

            # Deep merge function
            def deep_merge(base, update):
                merged = base.copy()
                for k, v in update.items():
                    if k in merged and isinstance(merged[k], dict) and isinstance(v, dict):
                        merged[k] = deep_merge(merged[k], v)
                    else:
                        merged[k] = v
                return merged

            # Atomic read-modify-write with immediate transaction lock
            conn.execute("BEGIN IMMEDIATE")
            try:
                row = conn.execute(
                    "SELECT value FROM memory WHERE key=?", (key,)
                ).fetchone()

                if row and row[0]:
                    current = json.loads(row[0])
                    if not isinstance(current, dict):
                        raise ValueError(f"Cannot merge into non-dict at key '{key}'")
                    result['exists'] = True
                else:
                    current = {}
                    result['exists'] = False

                merged = deep_merge(current, value)

                conn.execute('''
                    INSERT OR REPLACE INTO memory (key, value, updated_at)
                    VALUES (?, ?, ?)
                ''', (key, json.dumps(merged), now))
                conn.commit()
            except Exception:
                conn.rollback()
                raise
            result['value'] = merged

        elif op == 'delete':
            row = conn.execute(
                "SELECT value FROM memory WHERE key=?", (key,)
            ).fetchone()

            if row:
                result['previous'] = json.loads(row[0]) if row[0] else None
                result['value'] = result['previous']
                result['exists'] = True
                conn.execute("DELETE FROM memory WHERE key=?", (key,))
                conn.commit()
            else:
                result['exists'] = False

        elif op == 'keys':
            rows = conn.execute("SELECT key FROM memory").fetchall()
            all_keys = [r[0] for r in rows]

            # Filter by pattern
            if '*' in key or '?' in key:
                matched = [k for k in all_keys if fnmatch.fnmatch(k, key)]
            else:
                # Prefix match
                matched = [k for k in all_keys if k.startswith(key) or k == key]

            result['keys'] = sorted(matched)
            result['value'] = result['keys']
            result['exists'] = len(matched) > 0

        else:
            raise ValueError(f"Unknown operation: {op}")

        conn.close()
        print(json.dumps(result))
        EOF
      env:
        DB_PATH: "{{inputs.path}}"
        OP: "{{inputs.op}}"
        KEY: "{{inputs.key}}"
        VALUE: "{{inputs.value}}"
        DEFAULT: "{{inputs.default}}"

outputs:
  value:
    description: |
      Retrieved or resulting value:
      - get: Value at key (or default)
      - set: New value that was set
      - append: Updated list
      - merge: Merged dict
      - delete: Deleted value
      - keys: List of matching keys
    type: json
    value: "{{(blocks.execute.outputs.stdout | fromjson).value}}"

  exists:
    description: Whether the key existed before the operation.
    type: bool
    value: "{{(blocks.execute.outputs.stdout | fromjson).exists}}"

  previous:
    description: Previous value (for set/delete operations).
    type: json
    value: "{{(blocks.execute.outputs.stdout | fromjson).previous}}"

  keys:
    description: List of matching keys (for keys operation).
    type: list
    value: "{{(blocks.execute.outputs.stdout | fromjson)['keys']}}"
