name: agent-facts
description: |
  Semantic memory with FTS5 for validated facts.

  Stores compact, validated knowledge extracted by REASON phase.
  Supports full-text search, conflict detection, and status lifecycle.

  Fact evidence types:
  - direct: Verified by reading specific code (0.9-1.0 confidence)
  - inferred: Derived from patterns/signals (0.7-0.9 confidence)
  - assumed: Reasonable hypothesis (0.5-0.7 confidence)

  Fact statuses:
  - active: Current, valid fact
  - verified: Re-confirmed by new evidence
  - contested: Conflicting fact discovered
  - superseded: Replaced by more accurate fact
  - refuted: Proven false

  Operations:
  - store: Store a new fact
  - query: Query facts (FTS or filter)
  - get: Get single fact by ID
  - conflicts: Detect conflicting facts
  - update_status: Update fact status

tags: [agent, memory, facts, semantic, fts, sqlite, cortex]

inputs:
  path:
    type: str
    description: Path to SQLite database file.
    required: true

  op:
    type: str
    description: |
      Facts operation to perform:
      - store: Store a new fact
      - query: Query facts (FTS or filter)
      - get: Get single fact by ID
      - conflicts: Detect conflicting facts
      - update_status: Update fact status
    required: true

  # Store inputs
  claim:
    type: str
    description: The fact statement.
    required: false
    default: ""

  evidence_type:
    type: str
    description: Epistemic status (direct, inferred, assumed).
    required: false
    default: "inferred"

  confidence:
    type: num
    description: Confidence score (0.0-1.0).
    required: false
    default: 0.7

  grounding:
    type: str
    description: Evidence references as JSON array.
    required: false
    default: "[]"

  scope:
    type: str
    description: Optional scope limitation (e.g., "src/auth/").
    required: false
    default: ""

  source_cell:
    type: str
    description: Cell ID that created this fact.
    required: false
    default: ""

  # Query inputs
  query:
    type: str
    description: FTS query string (for query op).
    required: false
    default: ""

  status_filter:
    type: str
    description: Filter by status (default "active").
    required: false
    default: "active"

  limit:
    type: num
    description: Max results for query.
    required: false
    default: 50

  # Update inputs
  fact_id:
    type: str
    description: Fact ID for get/update operations.
    required: false
    default: ""

  new_status:
    type: str
    description: New status for update_status operation.
    required: false
    default: ""

  # Conflict detection inputs
  new_facts:
    type: str
    description: JSON array of new facts to check for conflicts.
    required: false
    default: "[]"

blocks:
  - id: execute
    type: Shell
    description: Execute the facts operation on SQLite facts table.
    inputs:
      command: |
        python3 << 'EOF'
        import os, json, sqlite3, uuid
        from datetime import datetime, timezone

        db_path = os.environ['DB_PATH']
        op = os.environ['OP']

        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        conn.execute("PRAGMA busy_timeout=30000")

        now = datetime.now(timezone.utc).isoformat()
        result = {'op': op, 'success': False}

        if op == 'store':
            claim = os.environ.get('CLAIM', '')
            evidence_type = os.environ.get('EVIDENCE_TYPE', 'inferred')
            confidence = float(os.environ.get('CONFIDENCE', '0.7'))
            grounding = os.environ.get('GROUNDING', '[]')
            scope = os.environ.get('SCOPE', '') or None
            source_cell = os.environ.get('SOURCE_CELL', '')

            fact_id = str(uuid.uuid4())
            conn.execute('''
                INSERT INTO facts (id, claim, evidence_type, confidence, grounding,
                                   scope, source_cell, source_phase, status, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, 'reason', 'active', ?, ?)
            ''', (fact_id, claim, evidence_type, confidence, grounding,
                  scope, source_cell, now, now))
            conn.commit()
            result = {
                'op': op,
                'success': True,
                'fact_id': fact_id,
                'claim': claim,
                'evidence_type': evidence_type,
                'confidence': confidence
            }

        elif op == 'get':
            fact_id = os.environ.get('FACT_ID', '')
            row = conn.execute("SELECT * FROM facts WHERE id = ?", (fact_id,)).fetchone()
            if row:
                result = {
                    'op': op,
                    'success': True,
                    'exists': True,
                    'fact': dict(row)
                }
            else:
                result = {'op': op, 'success': True, 'exists': False, 'fact_id': fact_id}

        elif op == 'query':
            query = os.environ.get('QUERY', '')
            status_filter = os.environ.get('STATUS_FILTER', 'active')
            limit = int(os.environ.get('LIMIT', '50'))

            if query:
                # FTS search
                # Escape special FTS characters and use prefix matching
                safe_query = query.replace('"', '""')
                rows = conn.execute('''
                    SELECT f.* FROM facts f
                    JOIN facts_fts fts ON f.id = fts.id
                    WHERE facts_fts MATCH ? AND f.status = ?
                    ORDER BY f.confidence DESC
                    LIMIT ?
                ''', (f'"{safe_query}"*', status_filter, limit)).fetchall()
            else:
                # All facts with status filter
                rows = conn.execute('''
                    SELECT * FROM facts WHERE status = ?
                    ORDER BY confidence DESC LIMIT ?
                ''', (status_filter, limit)).fetchall()

            items = [dict(row) for row in rows]
            result = {'op': op, 'success': True, 'items': items, 'count': len(items)}

        elif op == 'conflicts':
            new_facts_json = os.environ.get('NEW_FACTS', '[]')
            new_facts = json.loads(new_facts_json)

            conflicts = []
            for nf in new_facts:
                claim = nf.get('claim', '')
                if not claim:
                    continue
                # Search for similar claims using FTS
                safe_claim = claim.replace('"', '""')
                try:
                    rows = conn.execute('''
                        SELECT f.* FROM facts f
                        JOIN facts_fts fts ON f.id = fts.id
                        WHERE facts_fts MATCH ? AND f.status = 'active'
                    ''', (f'"{safe_claim}"*',)).fetchall()

                    for row in rows:
                        conflicts.append({
                            'new_claim': claim,
                            'existing_id': row['id'],
                            'existing_claim': row['claim'],
                            'existing_confidence': row['confidence'],
                            'existing_evidence_type': row['evidence_type']
                        })
                except sqlite3.OperationalError:
                    # FTS match failed, skip
                    pass

            result = {
                'op': op,
                'success': True,
                'conflicts': conflicts,
                'has_conflicts': len(conflicts) > 0,
                'conflict_count': len(conflicts)
            }

        elif op == 'update_status':
            fact_id = os.environ.get('FACT_ID', '')
            new_status = os.environ.get('NEW_STATUS', '')

            conn.execute('''
                UPDATE facts SET status = ?, updated_at = ? WHERE id = ?
            ''', (new_status, now, fact_id))
            conn.commit()
            result = {
                'op': op,
                'success': True,
                'fact_id': fact_id,
                'new_status': new_status
            }

        else:
            result = {'op': op, 'success': False, 'error': f'Unknown operation: {op}'}

        conn.close()
        print(json.dumps(result))
        EOF
      env:
        DB_PATH: "{{inputs.path}}"
        OP: "{{inputs.op}}"
        CLAIM: "{{inputs.claim}}"
        EVIDENCE_TYPE: "{{inputs.evidence_type}}"
        CONFIDENCE: "{{inputs.confidence}}"
        GROUNDING: "{{inputs.grounding}}"
        SCOPE: "{{inputs.scope}}"
        SOURCE_CELL: "{{inputs.source_cell}}"
        QUERY: "{{inputs.query}}"
        STATUS_FILTER: "{{inputs.status_filter}}"
        LIMIT: "{{inputs.limit}}"
        FACT_ID: "{{inputs.fact_id}}"
        NEW_STATUS: "{{inputs.new_status}}"
        NEW_FACTS: "{{inputs.new_facts}}"

outputs:
  result:
    type: dict
    description: Full operation result.
    value: "{{blocks.execute.outputs.stdout | fromjson}}"

  success:
    type: bool
    description: Whether the operation succeeded.
    value: "{{(blocks.execute.outputs.stdout | fromjson).success}}"

  fact_id:
    type: str
    description: Fact ID (for store/get/update ops).
    value: "{{(blocks.execute.outputs.stdout | fromjson).fact_id | default('')}}"

  items:
    type: list
    description: Query results (for query op).
    value: "{{ get(blocks.execute.outputs.stdout | fromjson, 'items', []) }}"

  count:
    type: num
    description: Number of items returned.
    value: "{{(blocks.execute.outputs.stdout | fromjson).count | default(0)}}"

  conflicts:
    type: list
    description: Detected conflicts (for conflicts op).
    value: "{{(blocks.execute.outputs.stdout | fromjson).conflicts | default([])}}"

  has_conflicts:
    type: bool
    description: Whether conflicts were found (for conflicts op).
    value: "{{(blocks.execute.outputs.stdout | fromjson).has_conflicts | default(false)}}"
