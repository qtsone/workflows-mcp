name: workflow-creator-generate-workflow
description: Generate workflow from design
version: "1.0"
tags: [agents, recursive, interactive, internal]

inputs:
  user_requests:
    type: str
    description: "(Required) Path to structured requests JSON file"
    required: true

  executor_docs_path:
    type: str
    description: "(Required) Path to compressed executor reference documentation"
    required: true

  examples:
    type: str
    description: "(Required) Example workflows for reference"
    required: true

  workflow_path:
    type: str
    description: "(Optional) Path to previous workflow definition (for refinement iterations)"
    default: ""
    required: false

  feedback:
    type: str
    description: "(Optional) User feedback from previous iteration"
    default: ""
    required: false

  workspace:
    type: str
    description: "(Optional) Workspace path for temporary files"
    default: "{{tmp}}"
    required: false

  index:
    type: num
    description: "(Optional) Index of the current iteration"
    default: 1
    required: false

blocks:
  - id: system_prompt
    description: "Log the current iteration"
    type: CreateFile
    inputs:
      create_parents: true
      overwrite: true
      path: "{{inputs.workspace}}/system-prompt-v{{inputs.index}}.md"
      content: |
        You are an expert workflow architect for DAG-based automation workflows.

        # Design Principles
        - Single responsibility per block
        - Parallelism via depends_on for concurrent operations
        - Use conditions for control flow, not circular dependencies

        # CRITICAL: DAG Rules (depends_on)
        - depends_on creates an ACYCLIC dependency graph - NO CYCLES ALLOWED
        - A block can ONLY depend on blocks that execute BEFORE it
        - depends_on: [] (empty array) means no dependencies - block can run immediately
        - NEVER create mutual dependencies (A depends on B, B depends on A) - this is INVALID

        # User Approval Pattern (CORRECT)
        Use SEQUENTIAL dependencies with CONDITIONS, not cycles:
        ```
        1. generate_content (no deps)     -> creates content
        2. prompt_approval (deps: [generate_content]) -> asks user yes/no
        3. next_step (deps: [prompt_approval], condition: response == 'yes')
        ```
        The workflow engine handles re-execution through resume_workflow, NOT circular deps.

        # CRITICAL: LLMCall and ImageGen Configuration
        LLMCall and ImageGen blocks REQUIRE configuration. Always include:
        ```yaml
        inputs:
          profile: default  # Load from ~/.workflows/llm-config.yml
          prompt: "..."
        ```
        OR specify provider directly:
        ```yaml
        inputs:
          provider: openai
          model: gpt-4o
          prompt: "..."
        ```
        Without profile or provider, the block WILL FAIL at runtime.

        # Output Format
        JSON: {workflow: {name, description, inputs: [...], blocks: [...], outputs: [...]}, explanation, clarifications}
        Note: In this representation, inputs, blocks, and outputs are arrays (lists), not objects.

  - id: user_prompt
    description: "Log the LLM prompt"
    type: CreateFile
    inputs:
      create_parents: true
      overwrite: true
      path: "{{inputs.workspace}}/user-prompt-v{{inputs.index}}.md"
      content: |
        # Reference Material
        <executor_docs>
        {{ read_file(inputs.executor_docs_path) | replace('# ', '## ') }}
        </executor_docs>

        ## Example Workflow structures
        ```tree
        {{inputs.examples}}
        ```

        ## User's initial requests
        ```json
        {{read_file(inputs.user_requests) | fromjson | prettyjson}}
        ```

        {%- if inputs.index == 1 %}
        # Design New Workflow
        Create a workflow based on the user's requirements:

        ## Instructions
        Design the architecture with:
        1. **Inputs**: All workflow input parameters
        2. **Blocks**: Compute/Processing steps (following DAG rules - no cycles)
        3. **Outputs**: Workflow outputs

        Generate the initial workflow design now.
        {% else %}
        # Refine Workflow Design (iteration {{ inputs.index }})

        ## Current Workflow
        ```json
        {{read_file(inputs.workflow_path) | fromjson | prettyjson}}
        ```

        ## User Feedback
        ```
        {{inputs.feedback}}
        ```

        ## Instructions
        Refine the diagram based on the feedback above.
        - Address all user concerns
        - Maintain valid output JSON syntax
        - Explain what you changed and why

        Generate the refined design now.
        {% endif %}

  - id: generate_workflow
    description: "Generate or refine workflow diagram"
    depends_on: [system_prompt, user_prompt]
    type: LLMCall
    inputs:
      profile: default
      timeout: 600
      response_schema:
        type: object
        properties:
          workflow:
            type: object
            properties:
              name:
                type: string
                description: "Workflow name (lowercase, hyphens)"
              description:
                type: string
                description: "Brief description of what the workflow does"
              inputs:
                type: array
                description: "Workflow inputs with types and descriptions"
                items:
                  type: object
                  properties:
                    name:
                      type: string
                      description: "Input parameter name"
                    type:
                      type: string
                      description: "Parameter type (str, int, bool, etc.)"
                    description:
                      type: string
                      description: "What this input is for"
                    required:
                      type: boolean
                      description: "Whether this input is required"
                    default:
                      type: string
                      description: "Default value if not provided (omit if none)"
                  required:
                    - name
                    - type
                    - description
                    - required
                  additionalProperties: false
              blocks:
                type: array
                items:
                  type: object
                  properties:
                    id:
                      type: string
                      description: "Block identifier (lowercase_underscored)"
                    type:
                      type: string
                      description: "Block type (Shell, LLMCall, Prompt, CreateFile, etc.)"
                    description:
                      type: string
                      description: "What this block does"
                    depends_on:
                      type: array
                      items:
                        type: string
                      description: "IDs of blocks this depends on. MUST be empty [] or reference only blocks EARLIER in the list. NO CYCLES - if A depends on B, B cannot depend on A."
                    condition:
                      type: string
                      description: "{% raw %}Condition for execution (e.g., '{{blocks.X.succeeded}}'){% endraw %}"
                    for_each:
                      type: string
                      description: "{% raw %}List expression for iteration (e.g., '{{inputs.items}}'){% endraw %}"
                    for_each_mode:
                      type: string
                      description: "Iteration mode: 'parallel' or 'sequential'"
                    inputs:
                      type: array
                      description: "Block inputs as key-value pairs. Use dot notation for nesting (e.g., 'inputs.param1' for Workflow blocks)."
                      items:
                        type: object
                        properties:
                          key:
                            type: string
                            description: "Input field name from executor docs (e.g., 'prompt', 'command', 'path'). Use dot notation for nesting: 'inputs.X' becomes inputs: {X: ...}"
                          value:
                            type: string
                            description: "{% raw %}Input value. Use {{inputs.X}} for workflow inputs, {{blocks.Y.outputs.Z}} for block outputs.{% endraw %}"
                        required:
                          - key
                          - value
                        additionalProperties: false
                  required:
                    - id
                    - type
                    - description
                  additionalProperties: false
              outputs:
                type: array
                description: "Workflow outputs"
                items:
                  type: object
                  properties:
                    name:
                      type: string
                      description: "Output name"
                    type:
                      type: string
                      description: "Output type"
                    description:
                      type: string
                      description: "What this output contains"
                    value:
                      type: string
                      description: "{% raw %}Value expression (e.g., '{{blocks.block_id.outputs.field}}'){% endraw %}"
                  required:
                    - name
                    - type
                    - description
                    - value
                  additionalProperties: false
            required:
              - name
              - description
              - inputs
              - blocks
              - outputs
            additionalProperties: false
            description: "Full structured workflow definition"
          explanation:
            type: string
            description: "Design choices and rationale"
          clarifications:
            type: array
            items:
              type: string
            description: "Questions or assumptions to validate"
        required:
          - workflow
        additionalProperties: false
      system_instructions: |
        {{ blocks.system_prompt.outputs.content }}
      prompt: |
        {{ blocks.user_prompt.outputs.content }}

  - id: store_response
    description: "Save design to temp file for validation"
    type: CreateFile
    depends_on: [generate_workflow]
    inputs:
      create_parents: true
      overwrite: true
      path: "{{inputs.workspace}}/response-v{{inputs.index}}.json"
      content: |
        {{blocks.generate_workflow.outputs.response | prettyjson}}

  - id: store_workflow
    description: "Save design to temp file for validation"
    type: CreateFile
    depends_on: [generate_workflow]
    inputs:
      create_parents: true
      overwrite: true
      path: "{{inputs.workspace}}/workflow-v{{inputs.index}}.json"
      content: |
        {{blocks.generate_workflow.outputs.response.workflow | prettyjson}}

  - id: validate_design
    description: "Validate the generated design structure"
    type: Workflow
    depends_on: [store_workflow]
    inputs:
      workflow: validate-design
      inputs:
        json_path: "{{blocks.store_workflow.outputs.path}}"

  - id: create_diagram_script
    description: "Create the Mermaid diagram renderer script"
    type: CreateFile
    inputs:
      create_parents: true
      overwrite: true
      path: "{{inputs.workspace}}/render_mermaid.py"
      content: |
        {% raw %}
        #!/usr/bin/env python3
        """Render workflow JSON as Mermaid DAG diagram showing inputs, blocks, and outputs."""

        import json
        import re
        import sys

        BLOCK_SHAPES = {
            "Prompt": ("{{", "}}"),
            "LLMCall": ("([", "])"),
            "ImageGen": ("([", "])"),
            "Workflow": ("[[", "]]"),
            "CreateFile": ("[(", ")]"),
            "ReadFiles": ("[(", ")]"),
            "Shell": ("[/", "/]"),
            "WriteJSONState": ("[(", ")]"),
        }
        DEFAULT_BLOCK_SHAPE = ("[", "]")


        def extract_refs(text: str) -> tuple[set[str], set[str]]:
            """Extract {{inputs.X}} and {{blocks.Y}} references from text."""
            if not isinstance(text, str):
                return set(), set()
            input_refs = set(re.findall(r"\{\{inputs\.(\w+)", text))
            block_refs = set(re.findall(r"\{\{blocks\.(\w+)", text))
            return input_refs, block_refs


        def extract_for_each_source(for_each: str) -> str:
            """Extract the source collection name from for_each expression."""
            if not for_each:
                return ""
            # {{inputs.items}} -> "items"
            match = re.search(r"\{\{inputs\.(\w+)", for_each)
            if match:
                return match.group(1)
            # {{blocks.X.outputs.Y}} -> "X.Y"
            match = re.search(r"\{\{blocks\.(\w+)\.(?:outputs\.)?(\w+)", for_each)
            if match:
                return f"{match.group(1)}.{match.group(2)}"
            # {{blocks.X}} -> "X"
            match = re.search(r"\{\{blocks\.(\w+)", for_each)
            if match:
                return match.group(1)
            return "items"


        def semantic_condition_label(condition: str) -> str:
            """Convert condition expressions to human-readable labels."""
            if not condition:
                return ""

            # {{blocks.X.succeeded}} -> "" (no label, success is default)
            if re.match(r"^\{\{blocks\.\w+\.succeeded\}\}$", condition):
                return ""

            # {{blocks.X.failed}} -> "✗"
            if re.match(r"^\{\{blocks\.\w+\.failed\}\}$", condition):
                return "✗"

            # {{blocks.X.skipped}} -> "skipped"
            if re.match(r"^\{\{blocks\.\w+\.skipped\}\}$", condition):
                return "skipped"

            # response == 'yes' or response == 'approve' patterns
            match = re.search(r"\.response\s*==\s*['\"](\w+)['\"]", condition)
            if match:
                return match.group(1)

            # all([response == 'yes' ...]) -> "all yes"
            if "all(" in condition:
                match = re.search(r"==\s*['\"](\w+)['\"]", condition)
                if match:
                    return f"all {match.group(1)}"
                return "all ✓"

            # any([...]) -> "any ✓"
            if "any(" in condition:
                return "any ✓"

            # Boolean checks: X == True, X == False
            if "== True" in condition or "== true" in condition:
                return "true"
            if "== False" in condition or "== false" in condition:
                return "false"

            # Fallback: show "?" to indicate unknown condition
            return "⚡"


        def safe_label(text: str, max_len: int = 40) -> str:
            """Escape quotes and truncate for Mermaid labels."""
            text = text.replace('"', "'").replace("\n", " ")
            if len(text) > max_len:
                return text[: max_len - 1] + "…"
            return text


        def render_mermaid(workflow: dict) -> str:
            lines = ["flowchart TD"]

            inputs = workflow.get("inputs", [])
            blocks = workflow.get("blocks", [])
            outputs = workflow.get("outputs", [])

            # Input nodes (stadium shape)
            if inputs:
                lines.append("")
                lines.append("    subgraph Inputs")
                for inp in inputs:
                    name = inp.get("name", "unknown")
                    inp_type = inp.get("type", "str")
                    lines.append(f'        in_{name}(["{name}: {inp_type}"])')
                lines.append("    end")

            # Block nodes (semantic shapes, with for_each subgraphs)
            if blocks:
                lines.append("")
                lines.append("    subgraph Blocks")

                for block in blocks:
                    block_id = block.get("id", "unknown")
                    block_type = block.get("type", "Unknown")
                    desc = block.get("description", block_type)
                    for_each = block.get("for_each")
                    for_each_mode = block.get("for_each_mode", "sequential")
                    left, right = BLOCK_SHAPES.get(block_type, DEFAULT_BLOCK_SHAPE)

                    # Format: BlockType on first line, description below (more room)
                    desc_label = safe_label(desc, max_len=50)
                    block_label = f"<b>{block_type}</b><br/>{desc_label}"

                    if for_each:
                        # Wrap for_each blocks in a subgraph
                        source = extract_for_each_source(for_each)
                        mode_icon = "⇉" if for_each_mode == "parallel" else "→"
                        lines.append(f'        subgraph loop_{block_id}["{mode_icon} for each: {source}"]')
                        lines.append(f'            {block_id}{left}"{block_label}"{right}')
                        lines.append("        end")
                    else:
                        lines.append(f'        {block_id}{left}"{block_label}"{right}')

                lines.append("    end")

            # Output nodes (asymmetric shape)
            if outputs:
                lines.append("")
                lines.append("    subgraph Outputs")
                for out in outputs:
                    name = out.get("name", "unknown")
                    out_type = out.get("type", "str")
                    lines.append(f"        out_{name}>{name}: {out_type}]")
                lines.append("    end")

            # Edges
            lines.append("")

            # Input → Block edges (from {{inputs.X}} references in block inputs)
            for block in blocks:
                block_id = block.get("id", "unknown")
                block_inputs = block.get("inputs", [])
                all_input_refs = set()
                for inp in block_inputs:
                    value = inp.get("value", "")
                    input_refs, _ = extract_refs(value)
                    all_input_refs.update(input_refs)
                for inp_name in sorted(all_input_refs):
                    lines.append(f"    in_{inp_name} --> {block_id}")

            # Block → Block edges (from depends_on with semantic condition labels)
            for block in blocks:
                block_id = block.get("id", "unknown")
                for dep in block.get("depends_on", []):
                    dep_id = dep if isinstance(dep, str) else dep.get("block", dep)
                    condition = block.get("condition", "") or ""
                    cond_label = semantic_condition_label(condition)

                    if cond_label:
                        lines.append(f'    {dep_id} -->|"{cond_label}"| {block_id}')
                    else:
                        lines.append(f"    {dep_id} --> {block_id}")

            # Block → Output edges (from {{blocks.X}} references in output values)
            for out in outputs:
                out_name = out.get("name", "unknown")
                value = out.get("value", "")
                _, block_refs = extract_refs(value)
                for block_id in sorted(block_refs):
                    lines.append(f"    {block_id} --> out_{out_name}")

            return "\n".join(lines)


        if __name__ == "__main__":
            if len(sys.argv) != 3:
                print(f"Usage: {sys.argv[0]} <json_path> <output_path>", file=sys.stderr)
                sys.exit(1)

            json_path, output_path = sys.argv[1], sys.argv[2]
            with open(json_path) as f:
                workflow = json.load(f)
            diagram = render_mermaid(workflow)
            with open(output_path, "w") as f:
                f.write(diagram)
            print(output_path)

        {% endraw %}

  - id: render_diagram
    description: "Render Mermaid diagram from JSON workflow"
    type: Shell
    depends_on: [store_workflow, create_diagram_script]
    inputs:
      command: >-
        python3 "{{blocks.create_diagram_script.outputs.path}}"
        "{{blocks.store_workflow.outputs.path}}"
        "{{inputs.workspace}}/diagram-v{{inputs.index}}.mermaid"

  - id: store_diagram_html
    description: "Create HTML viewer for the diagram"
    type: CreateFile
    depends_on: [render_diagram]
    inputs:
      create_parents: true
      overwrite: true
      path: "{{inputs.workspace}}/diagram-v{{inputs.index}}.html"
      content: |
        <!DOCTYPE html>
        <html>
        <head>
          <title>Workflow Diagram - Iteration {{inputs.index}}</title>
          <script type="module">
            import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
            mermaid.initialize({ startOnLoad: true, theme: 'default' });
          </script>
          <style>
            body { font-family: system-ui, -apple-system, sans-serif; padding: 2rem; max-width: 1200px; margin: 0 auto; background: #f5f5f5; }
            h1 { color: #333; margin-bottom: 0.5rem; }
            .subtitle { color: #666; margin-bottom: 2rem; }
            .mermaid { background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
          </style>
        </head>
        <body>
          <h1>Workflow Diagram</h1>
          <p class="subtitle">Generated from JSON - Iteration {{inputs.index}}</p>
          <div class="mermaid">
        {{ read_file(inputs.workspace ~ '/diagram-v' ~ inputs.index ~ '.mermaid') }}
          </div>
        </body>
        </html>

  - id: request_approval
    description: "Present diagram to user for approval"
    depends_on:
      - block: validate_design
        required: false
      - block: store_diagram_html
        required: false
    type: Prompt
    inputs:
      prompt: |
        # WORKFLOW DESIGN - ITERATION {{inputs.index}}
        {% if inputs.index > 10 %}
        ⚠️ You've made {{inputs.index}} refinements. This is getting expensive. Max depth is 50.
        {% endif %}

        ## Visual Diagram
        Open this HTML file to see the workflow diagram: {{blocks.store_diagram_html.outputs.path}}

        ## Block Summary
        | Block ID | Type | Description |
        |----------|------|---------|
        {% for item in blocks.generate_workflow.outputs.response.workflow.blocks %}
        | `{{ item.id }}` | {{ item.type }} | {{ item.description }} |
        {% endfor %}

        {% if blocks.generate_workflow.outputs.response.explanation %}
        ## Design Explanation
        {{blocks.generate_workflow.outputs.response.explanation}}
        {% endif %}

        {% if blocks.generate_workflow.outputs.response.clarifications %}
        ## Clarifications Needed
        {% for clarification in blocks.generate_workflow.outputs.response.clarifications %}
        • {{ clarification }}
        {% endfor %}
        {% endif %}

        {% if not blocks.validate_design.outputs.success %}
        ## Workflow Validation Errors
        {{blocks.validate_design.outputs.message}}
        {% endif %}

        ## Generated Workflow JSON
        Full workflow definition: {{blocks.store_workflow.outputs.path}}
        ---
        Please review the workflow design and diagram.
        To approve - respond with "approve"
        To refine - respond with your feedback directly, describing what needs to change.
        Your response:

  - id: recurse_refinement
    description: "Recursive call for refinement"
    depends_on: [request_approval]
    condition: >-
      {{blocks.request_approval.outputs.response | trim != '' and
        blocks.request_approval.outputs.response | lower | trim != 'approve'}}
    type: Workflow
    inputs:
      workflow: workflow-creator-generate-workflow
      inputs:
        user_requests: "{{inputs.user_requests}}"
        executor_docs_path: "{{inputs.executor_docs_path}}"
        examples: "{{inputs.examples}}"
        workflow_path: "{{blocks.store_workflow.outputs.path}}"
        feedback: "{{blocks.request_approval.outputs.response}}"
        workspace: "{{inputs.workspace}}"
        index: "{{inputs.index + 1}}"

outputs:
  diagram_path:
    value: >-
      {{blocks.recurse_refinement.outputs.diagram_path
      if blocks.recurse_refinement.succeeded
      else blocks.store_diagram_html.outputs.path}}
    type: str
    description: "Path to the rendered Mermaid diagram HTML"

  workflow_path:
    value: >-
      {{blocks.recurse_refinement.outputs.workflow_path
      if blocks.recurse_refinement.succeeded
      else blocks.store_workflow.outputs.path}}
    type: str
    description: "Path to the final JSON workflow definition"

  approved:
    value: >-
      {{blocks.recurse_refinement.outputs.approved
      if blocks.recurse_refinement.succeeded
      else (blocks.request_approval.outputs.response | lower | trim == 'approve')}}
    type: bool
    description: "Whether design was approved"
