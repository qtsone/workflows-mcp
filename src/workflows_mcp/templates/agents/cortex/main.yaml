name: cortex-cell
description: |
  CORTEX: Cognitive Operations for Reasoning and Task EXecution

  A fractal cognitive architecture where every cognitive operation follows
  the same pattern. The fundamental unit that can operate in different modes:

  - mode=null: Full cognitive cycle (categorize → understand → formulate → gather → analyze → synthesize → act)
  - mode="categorize": Query classification only
  - mode="understand": Build understanding only
  - mode="formulate": Query refinement only
  - mode="gather": Evidence collection only
  - mode="analyze": Evidence analysis only
  - mode="synthesize": Finding synthesis only
  - mode="act": Action execution only

  The same cell structure handles ALL cognitive operations at every scale.

  Termination conditions:
  - Depth exhausted (depth >= max_depth)
  - Atomic capability resolves the query
  - Cycle detected (query hash in ancestor chain)
  - Goal achieved (confidence >= threshold)
  - No sub-queries needed
  - Cost/time exceeded

tags: [agent, cortex, cognitive, fractal, recursive]

inputs:
  # The Query (determines what to do)
  query:
    type: str
    description: The question, task, or goal for this cell.
    required: true

  # Mode (determines how to do it)
  mode:
    type: str
    description: |
      Cognitive mode for this cell:
      - null/empty: Full cycle (categorize → act)
      - "categorize": Query classification only
      - "understand": Build understanding only
      - "formulate": Query refinement only
      - "gather": Evidence collection only
      - "analyze": Evidence analysis only
      - "synthesize": Finding synthesis only
      - "act": Action execution only
    required: false
    default: ""

  # Accumulated Context
  context:
    type: dict
    description: |
      Shared context passed through the cell tree:
      - repo_path: Working directory
      - accumulated_knowledge: Facts from ancestor cells
      - constraints: Permissions and limitations
      - focus: Priority area (security, performance, etc.)
    required: true

  # Evidence (for analyze/synthesize modes)
  evidence:
    type: list
    description: Evidence collected for analysis (used in analyze mode).
    required: false
    default: []

  # Findings (for synthesize mode)
  findings:
    type: list
    description: Findings to synthesize (used in synthesize mode).
    required: false
    default: []

  # Synthesis (for act mode)
  synthesis:
    type: dict
    description: Synthesis results (used in act mode).
    required: false
    default: {}

  # Recursion Control
  depth:
    type: num
    description: Current depth in cell tree (0 = root).
    required: false
    default: 0

  max_depth:
    type: num
    description: Maximum recursion depth.
    required: false
    default: 5

  # Confidence threshold
  confidence_threshold:
    type: num
    description: Minimum confidence to skip understanding phase (0.0-1.0).
    required: false
    default: 0.7

  # History (for cycle detection)
  query_history:
    type: list
    description: Hashes of ancestor queries (for cycle detection).
    required: false
    default: []

  # State Management
  state:
    type: str
    description: |
      Path to SQLite state database. If empty, a new state is auto-created
      at ~/.workflows/tasks/<trace_id>.db
    required: false
    default: ""

  parent_task_id:
    type: str
    description: Parent cell's task ID.
    required: false
    default: ""

  # LLM Profile configuration
  profile:
    type: str
    description: LLM profile to use (from ~/.workflows/llm-config.yml).
    required: false
    default: "default"

  # Capabilities registry - embedded default with all available capabilities
  capabilities:
    type: dict
    description: |
      Capability registry defining available atomic and cognitive capabilities.
      Passed to phases for LLM-driven capability selection.
    required: false
    default:
      atomic:
        gather-files:
          description: "Read files matching patterns (structure or content)"
          workflow: "cortex-gather-files"
          inputs: ["patterns", "base_path", "mode", "max_files"]
        gather-search:
          description: "Search for patterns in codebase using ripgrep"
          workflow: "cortex-gather-search"
          inputs: ["pattern", "path", "file_type"]
        gather-command:
          description: "Execute shell command for read-only info gathering"
          workflow: "cortex-gather-command"
          inputs: ["command", "working_dir", "timeout"]
        reason-llm:
          description: "Call LLM for reasoning, analysis, or decision-making"
          workflow: "cortex-reason-llm"
          inputs: ["prompt", "system_instructions", "response_schema"]
        action-write:
          description: "Create a new file"
          workflow: "cortex-action-write"
          inputs: ["path", "content", "overwrite"]
        action-edit:
          description: "Modify an existing file"
          workflow: "cortex-action-edit"
          inputs: ["path", "operations", "backup"]
        action-execute:
          description: "Execute command with side effects"
          workflow: "cortex-action-execute"
          inputs: ["command", "working_dir", "timeout"]
        memory-set:
          description: "Store value in memory"
          workflow: "cortex-memory-set"
          inputs: ["state", "key", "value"]
        memory-get:
          description: "Retrieve value from memory"
          workflow: "cortex-memory-get"
          inputs: ["state", "key", "default"]
        memory-append:
          description: "Append to list in memory"
          workflow: "cortex-memory-append"
          inputs: ["state", "key", "value"]
      cognitive:
        cortex-categorize:
          description: "Categorize a query/task to determine processing strategy"
          workflow: "cortex-categorize"
          mode: "categorize"
        cortex-understand:
          description: "Build understanding of a topic, identify knowledge gaps"
          workflow: "cortex-understand"
          mode: "understand"
        cortex-formulate:
          description: "Refine and clarify a query into actionable form"
          workflow: "cortex-formulate"
          mode: "formulate"
        cortex-gather:
          description: "Collect evidence for a query"
          workflow: "cortex-gather"
          mode: "gather"
        cortex-analyze:
          description: "Analyze evidence and draw conclusions"
          workflow: "cortex-analyze"
          mode: "analyze"
        cortex-synthesize:
          description: "Synthesize findings into conclusions"
          workflow: "cortex-synthesize"
          mode: "synthesize"
        cortex-act:
          description: "Plan and execute actions based on synthesis"
          workflow: "cortex-act"
          mode: "act"
        cortex-full:
          description: "Complete cognitive cycle (all phases)"
          workflow: "cortex-full"
          mode: null

blocks:
  # ==========================================================================
  # STEP 1: Initialize cell - register task, check termination conditions
  # ==========================================================================
  - id: init
    type: Shell
    description: Initialize cell, compute query hash, check for cycles.
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import hashlib
        import os

        query = os.environ.get('QUERY', '')
        mode = os.environ.get('MODE', '')
        depth = int(os.environ.get('DEPTH', '0'))
        max_depth = int(os.environ.get('MAX_DEPTH', '5'))
        history_json = os.environ.get('QUERY_HISTORY', '[]')

        try:
            query_history = json.loads(history_json) if history_json else []
        except json.JSONDecodeError:
            query_history = []

        # Compute query hash for cycle detection
        query_hash = hashlib.sha256(query.encode()).hexdigest()[:16]

        # Check termination conditions
        depth_exceeded = depth >= max_depth
        cycle_detected = query_hash in query_history

        # Determine if this is a full cycle or single phase
        is_full_cycle = mode == '' or mode == 'null'

        # Add current query to history for children
        new_history = query_history + [query_hash]

        result = {
            'query_hash': query_hash,
            'depth': depth,
            'max_depth': max_depth,
            'mode': mode if mode else 'full_cycle',
            'is_full_cycle': is_full_cycle,
            'depth_exceeded': depth_exceeded,
            'cycle_detected': cycle_detected,
            'should_terminate_early': depth_exceeded or cycle_detected,
            'termination_reason': (
                'depth_exceeded' if depth_exceeded else
                'cycle_detected' if cycle_detected else
                None
            ),
            'query_history': new_history
        }

        print(json.dumps(result))
        EOF
      env:
        QUERY: "{{ inputs.query }}"
        MODE: "{{ inputs.mode }}"
        DEPTH: "{{ inputs.depth }}"
        MAX_DEPTH: "{{ inputs.max_depth }}"
        QUERY_HISTORY: "{{ inputs.query_history | tojson }}"

  # ==========================================================================
  # STEP 2: Register task in state tree
  # ==========================================================================
  - id: register_task
    type: Workflow
    description: Create task in state tree for this cell.
    depends_on: [init]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        parent_id: "{{ inputs.parent_task_id }}"
        task: "CORTEX Cell ({{ (blocks.init.outputs.stdout | fromjson).mode }}, depth={{ inputs.depth }})"
        task_type: "cortex-cell"
        status: "in-progress"
        caller: "cortex-cell"
        data:
          query_hash: "{{ (blocks.init.outputs.stdout | fromjson).query_hash }}"
          mode: "{{ (blocks.init.outputs.stdout | fromjson).mode }}"
          depth: "{{ inputs.depth }}"
          query_preview: "{{ inputs.query[:100] }}"

  # ==========================================================================
  # STEP 3: Early termination check
  # ==========================================================================
  - id: early_termination
    type: Shell
    description: Return early if termination conditions met.
    depends_on: [init, register_task]
    condition: "{{ (blocks.init.outputs.stdout | fromjson).should_terminate_early }}"
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        reason = os.environ.get('TERMINATION_REASON', 'unknown')
        query_hash = os.environ.get('QUERY_HASH', '')
        depth = int(os.environ.get('DEPTH', '0'))

        result = {
            'terminated_early': True,
            'reason': reason,
            'synthesis': {
                'findings': [],
                'summary': f'Cell terminated early: {reason}',
                'risk_level': 'info',
                'recommendations': [],
                'confidence': 0.0,
                'actions_taken': []
            },
            'stats': {
                'phases_executed': [],
                'children_spawned': 0,
                'capabilities_used': [],
                'depth': depth
            }
        }

        print(json.dumps(result))
        EOF
      env:
        TERMINATION_REASON: "{{ (blocks.init.outputs.stdout | fromjson).termination_reason }}"
        QUERY_HASH: "{{ (blocks.init.outputs.stdout | fromjson).query_hash }}"
        DEPTH: "{{ inputs.depth }}"

  # ==========================================================================
  # ROUTING: Determine which phase(s) to execute
  # ==========================================================================
  - id: route_phase
    type: Shell
    description: Determine execution path based on mode.
    depends_on: [init]
    condition: "{{ not (blocks.init.outputs.stdout | fromjson).should_terminate_early }}"
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        mode = os.environ.get('MODE', '')
        is_full_cycle = mode == '' or mode == 'null'

        # Map mode to phase execution
        phases = {
            '': ['categorize', 'understand', 'formulate', 'gather', 'analyze', 'synthesize', 'act'],
            'null': ['categorize', 'understand', 'formulate', 'gather', 'analyze', 'synthesize', 'act'],
            'full_cycle': ['categorize', 'understand', 'formulate', 'gather', 'analyze', 'synthesize', 'act'],
            'categorize': ['categorize'],
            'understand': ['understand'],
            'formulate': ['formulate'],
            'gather': ['gather'],
            'analyze': ['analyze'],
            'synthesize': ['synthesize'],
            'act': ['act']
        }

        active_phases = phases.get(mode, [mode] if mode else phases[''])

        result = {
            'mode': mode if mode else 'full_cycle',
            'is_full_cycle': is_full_cycle,
            'active_phases': active_phases,
            'run_categorize': 'categorize' in active_phases,
            'run_understand': 'understand' in active_phases,
            'run_formulate': 'formulate' in active_phases,
            'run_gather': 'gather' in active_phases,
            'run_analyze': 'analyze' in active_phases,
            'run_synthesize': 'synthesize' in active_phases,
            'run_act': 'act' in active_phases
        }

        print(json.dumps(result))
        EOF
      env:
        MODE: "{{ inputs.mode }}"

  # ==========================================================================
  # PHASE 1: CATEGORIZE - Classify the query
  # ==========================================================================
  - id: phase_categorize
    type: Workflow
    description: Categorize the query to determine processing strategy.
    depends_on: [route_phase, register_task]
    condition: "{{ (blocks.route_phase.outputs.stdout | fromjson).run_categorize }}"
    inputs:
      workflow: cortex-phase-categorize
      inputs:
        query: "{{ inputs.query }}"
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 2: UNDERSTAND - Build understanding (if needed)
  # ==========================================================================
  - id: phase_understand
    type: Workflow
    description: Build understanding of the topic, identify knowledge gaps.
    depends_on:
      - route_phase
      - register_task
      - block: phase_categorize
        required: false
    condition: |
      {{
        (blocks.route_phase.outputs.stdout | fromjson).run_understand and
        (
          not (blocks.route_phase.outputs.stdout | fromjson).is_full_cycle or
          (blocks.phase_categorize.succeeded and blocks.phase_categorize.outputs.confidence < inputs.confidence_threshold)
        )
      }}
    inputs:
      workflow: cortex-phase-understand
      inputs:
        query: "{{ inputs.query }}"
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        category: "{{ blocks.phase_categorize.outputs.category if blocks.phase_categorize.succeeded else 'unknown' }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        depth: "{{ inputs.depth }}"
        max_depth: "{{ inputs.max_depth }}"
        query_history: "{{ (blocks.init.outputs.stdout | fromjson).query_history }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 3: FORMULATE - Refine the query
  # ==========================================================================
  - id: phase_formulate
    type: Workflow
    description: Refine and clarify the query into actionable form.
    depends_on:
      - route_phase
      - register_task
      - block: phase_understand
        required: false
    condition: "{{ (blocks.route_phase.outputs.stdout | fromjson).run_formulate }}"
    inputs:
      workflow: cortex-phase-formulate
      inputs:
        query: "{{ inputs.query }}"
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        understanding: "{{ blocks.phase_understand.outputs.understanding if blocks.phase_understand.succeeded else {} }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 4: GATHER - Collect evidence
  # ==========================================================================
  - id: phase_gather
    type: Workflow
    description: Collect evidence relevant to the query.
    depends_on:
      - route_phase
      - register_task
      - block: phase_formulate
        required: false
    condition: "{{ (blocks.route_phase.outputs.stdout | fromjson).run_gather }}"
    inputs:
      workflow: cortex-phase-gather
      inputs:
        query: "{{ blocks.phase_formulate.outputs.refined_query if blocks.phase_formulate.succeeded else inputs.query }}"
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        category: "{{ blocks.phase_categorize.outputs.category if blocks.phase_categorize.succeeded else 'unknown' }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 5: ANALYZE - Analyze evidence
  # ==========================================================================
  - id: phase_analyze
    type: Workflow
    description: Analyze collected evidence and draw conclusions.
    depends_on:
      - route_phase
      - register_task
      - block: phase_gather
        required: false
    condition: "{{ (blocks.route_phase.outputs.stdout | fromjson).run_analyze }}"
    inputs:
      workflow: cortex-phase-analyze
      inputs:
        query: "{{ blocks.phase_formulate.outputs.refined_query if blocks.phase_formulate.succeeded else inputs.query }}"
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        evidence: "{{ blocks.phase_gather.outputs.evidence if blocks.phase_gather.succeeded else inputs.evidence }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        depth: "{{ inputs.depth }}"
        max_depth: "{{ inputs.max_depth }}"
        query_history: "{{ (blocks.init.outputs.stdout | fromjson).query_history }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 5.5: RECURSIVE INVESTIGATION (if sub-queries exist)
  # ==========================================================================
  - id: phase_investigate
    type: Workflow
    description: Spawn child cells for sub-queries identified during analysis.
    depends_on: [phase_analyze]
    condition: |
      {{
        blocks.phase_analyze.succeeded and
        blocks.phase_analyze.outputs.needs_deeper and
        blocks.phase_analyze.outputs.sub_queries | length > 0 and
        inputs.depth < inputs.max_depth
      }}
    for_each: "{{ blocks.phase_analyze.outputs.sub_queries }}"
    for_each_mode: parallel
    inputs:
      workflow: cortex-cell
      inputs:
        query: "{{ each.value.query }}"
        mode: ""
        context:
          repo_path: "{{ inputs.context.repo_path }}"
          accumulated_knowledge: "{{ blocks.phase_analyze.outputs.findings }}"
          constraints: "{{ inputs.context.constraints | default({}) }}"
          focus: "{{ each.value.focus | default(inputs.context.focus) | default('general') }}"
        capabilities: "{{ inputs.capabilities }}"
        depth: "{{ inputs.depth + 1 }}"
        max_depth: "{{ inputs.max_depth }}"
        query_history: "{{ (blocks.init.outputs.stdout | fromjson).query_history }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 6: SYNTHESIZE - Merge findings
  # ==========================================================================
  - id: phase_synthesize
    type: Workflow
    description: Synthesize all findings into unified conclusions.
    depends_on:
      - route_phase
      - register_task
      - block: phase_analyze
        required: false
      - block: phase_investigate
        required: false
    condition: "{{ (blocks.route_phase.outputs.stdout | fromjson).run_synthesize }}"
    inputs:
      workflow: cortex-phase-synthesize
      inputs:
        query: "{{ inputs.query }}"
        findings: |
          {{
            (blocks.phase_analyze.outputs.findings if blocks.phase_analyze.succeeded else []) +
            (inputs.findings if inputs.findings else [])
          }}
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # PHASE 7: ACT - Execute actions
  # ==========================================================================
  - id: phase_act
    type: Workflow
    description: Plan and execute actions based on synthesis.
    depends_on:
      - route_phase
      - register_task
      - block: phase_synthesize
        required: false
    condition: "{{ (blocks.route_phase.outputs.stdout | fromjson).run_act }}"
    inputs:
      workflow: cortex-phase-act
      inputs:
        query: "{{ inputs.query }}"
        synthesis: "{{ blocks.phase_synthesize.outputs.synthesis if blocks.phase_synthesize.succeeded else inputs.synthesis }}"
        context: "{{ inputs.context }}"
        capabilities: "{{ inputs.capabilities }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        depth: "{{ inputs.depth }}"
        max_depth: "{{ inputs.max_depth }}"
        query_history: "{{ (blocks.init.outputs.stdout | fromjson).query_history }}"
        profile: "{{ inputs.profile }}"

  # ==========================================================================
  # FINALIZE: Collect stats and mark complete
  # ==========================================================================
  - id: finalize
    type: Shell
    description: Collect execution statistics.
    depends_on:
      - init
      - block: early_termination
        required: false
      - block: phase_categorize
        required: false
      - block: phase_understand
        required: false
      - block: phase_formulate
        required: false
      - block: phase_gather
        required: false
      - block: phase_analyze
        required: false
      - block: phase_investigate
        required: false
      - block: phase_synthesize
        required: false
      - block: phase_act
        required: false
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        # Collect phase execution status
        phases_executed = []

        for phase in ['categorize', 'understand', 'formulate', 'gather', 'analyze', 'investigate', 'synthesize', 'act']:
            status = os.environ.get(f'PHASE_{phase.upper()}_STATUS', 'skipped')
            if status == 'succeeded':
                phases_executed.append(phase)

        depth = int(os.environ.get('DEPTH', '0'))
        mode = os.environ.get('MODE', 'full_cycle')

        result = {
            'phases_executed': phases_executed,
            'depth': depth,
            'mode': mode,
            'children_spawned': int(os.environ.get('CHILDREN_COUNT', '0'))
        }

        print(json.dumps(result))
        EOF
      env:
        DEPTH: "{{ inputs.depth }}"
        MODE: "{{ (blocks.init.outputs.stdout | fromjson).mode }}"
        PHASE_CATEGORIZE_STATUS: "{{ 'succeeded' if blocks.phase_categorize.succeeded else 'skipped' }}"
        PHASE_UNDERSTAND_STATUS: "{{ 'succeeded' if blocks.phase_understand.succeeded else 'skipped' }}"
        PHASE_FORMULATE_STATUS: "{{ 'succeeded' if blocks.phase_formulate.succeeded else 'skipped' }}"
        PHASE_GATHER_STATUS: "{{ 'succeeded' if blocks.phase_gather.succeeded else 'skipped' }}"
        PHASE_ANALYZE_STATUS: "{{ 'succeeded' if blocks.phase_analyze.succeeded else 'skipped' }}"
        PHASE_INVESTIGATE_STATUS: "{{ 'succeeded' if blocks.phase_investigate.succeeded else 'skipped' }}"
        PHASE_SYNTHESIZE_STATUS: "{{ 'succeeded' if blocks.phase_synthesize.succeeded else 'skipped' }}"
        PHASE_ACT_STATUS: "{{ 'succeeded' if blocks.phase_act.succeeded else 'skipped' }}"
        CHILDREN_COUNT: "{{ blocks.phase_investigate.metadata.count if blocks.phase_investigate.succeeded else 0 }}"

  # ==========================================================================
  # Mark task complete
  # ==========================================================================
  - id: track_done
    type: Workflow
    description: Mark cell task as complete.
    depends_on: [finalize, register_task]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        status: "done"
        caller: "cortex-cell"
        data:
          phases_executed: "{{ (blocks.finalize.outputs.stdout | fromjson).phases_executed }}"
          children_spawned: "{{ (blocks.finalize.outputs.stdout | fromjson).children_spawned }}"

outputs:
  # Primary output - synthesis from the cell
  synthesis:
    value: |
      {{
        (blocks.early_termination.outputs.stdout | fromjson).synthesis if blocks.early_termination.succeeded else
        blocks.phase_synthesize.outputs.synthesis if blocks.phase_synthesize.succeeded else
        blocks.phase_act.outputs.synthesis if blocks.phase_act.succeeded else
        {
          'findings': blocks.phase_analyze.outputs.findings if blocks.phase_analyze.succeeded else [],
          'summary': 'No synthesis performed',
          'confidence': blocks.phase_categorize.outputs.confidence if blocks.phase_categorize.succeeded else 0.5
        }
      }}
    type: dict
    description: Unified synthesis from this cell.

  # Phase-specific outputs (for single-phase modes)
  category:
    value: "{{ blocks.phase_categorize.outputs.category if blocks.phase_categorize.succeeded else 'unknown' }}"
    type: str
    description: Query category (from categorize phase).

  confidence:
    value: "{{ blocks.phase_categorize.outputs.confidence if blocks.phase_categorize.succeeded else 0.5 }}"
    type: num
    description: Confidence in categorization (0.0-1.0).

  understanding:
    value: "{{ blocks.phase_understand.outputs.understanding if blocks.phase_understand.succeeded else {} }}"
    type: dict
    description: Understanding built (from understand phase).

  refined_query:
    value: "{{ blocks.phase_formulate.outputs.refined_query if blocks.phase_formulate.succeeded else inputs.query }}"
    type: str
    description: Refined query (from formulate phase).

  evidence:
    value: "{{ blocks.phase_gather.outputs.evidence if blocks.phase_gather.succeeded else [] }}"
    type: list
    description: Evidence collected (from gather phase).

  findings:
    value: "{{ blocks.phase_analyze.outputs.findings if blocks.phase_analyze.succeeded else [] }}"
    type: list
    description: Findings from analysis (from analyze phase).

  needs_deeper:
    value: "{{ blocks.phase_analyze.outputs.needs_deeper if blocks.phase_analyze.succeeded else false }}"
    type: bool
    description: Whether deeper investigation is needed.

  actions_taken:
    value: "{{ blocks.phase_act.outputs.actions_taken if blocks.phase_act.succeeded else [] }}"
    type: list
    description: Actions executed (from act phase).

  # Cell metadata
  cell_id:
    value: "{{ blocks.register_task.outputs.task.task_id }}"
    type: str
    description: This cell's identifier.

  depth:
    value: "{{ inputs.depth }}"
    type: num
    description: Depth at which this cell operated.

  mode:
    value: "{{ (blocks.init.outputs.stdout | fromjson).mode }}"
    type: str
    description: Mode this cell operated in.

  stats:
    value: "{{ blocks.finalize.outputs.stdout | fromjson }}"
    type: dict
    description: Execution statistics.
