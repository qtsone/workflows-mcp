# CORTEX Atomic Capability: Execute Command
#
# Pure command execution capability for the EXECUTE and VERIFY phases.
# Returns structured output with exit_code, stdout, stderr, duration.

name: cortex-execute-command
description: "Execute a shell command and capture structured output"

tags: [cortex, capability, execute, atomic]

inputs:
  command:
    type: str
    description: Shell command to execute.
    required: true

  working_dir:
    type: str
    description: Working directory for command execution.
    default: "."

  timeout:
    type: num
    description: Timeout in seconds.
    default: 300

  state:
    type: str
    description: Path to SQLite state database.
    default: ""

  models:
    type: dict
    description: Model definitions.
    default: {}

  task_id:
    type: str
    description: Parent task ID for storing execution record.
    default: ""

  phase:
    type: str
    description: Which phase is calling (execute, verify).
    default: "execute"

  iteration:
    type: num
    description: Current iteration number.
    default: 0

blocks:
  - id: run_command
    type: Shell
    description: Execute the command.
    inputs:
      timeout: "{{ inputs.timeout }}"
      working_dir: "{{ inputs.working_dir }}"
      command: |
        # Capture start time
        START_MS=$(python3 -c "import time; print(int(time.time() * 1000))")

        # Run command, capturing both stdout and stderr
        {{ inputs.command }} 2>&1
        EXIT_CODE=$?

        # Capture end time
        END_MS=$(python3 -c "import time; print(int(time.time() * 1000))")
        DURATION_MS=$((END_MS - START_MS))

        echo "___EXIT_CODE___:$EXIT_CODE"
        echo "___DURATION_MS___:$DURATION_MS"

  - id: parse_output
    type: Shell
    description: Parse command output into structured format.
    depends_on: [run_command]
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        raw_output = os.environ.get('RAW_OUTPUT', '')
        command = os.environ.get('COMMAND', '')
        working_dir = os.environ.get('WORKING_DIR', '.')

        lines = raw_output.split('\n')
        exit_code = 1
        duration_ms = 0
        output_lines = []

        for line in lines:
            if line.startswith('___EXIT_CODE___:'):
                try:
                    exit_code = int(line.split(':')[1])
                except:
                    pass
            elif line.startswith('___DURATION_MS___:'):
                try:
                    duration_ms = int(line.split(':')[1])
                except:
                    pass
            else:
                output_lines.append(line)

        stdout = '\n'.join(output_lines)
        success = exit_code == 0

        result = {
            'executed': True,
            'success': success,
            'command': command,
            'working_dir': working_dir,
            'exit_code': exit_code,
            'stdout': stdout[:50000],
            'stderr': '',
            'duration_ms': duration_ms
        }

        print(json.dumps(result))
        EOF
      env:
        RAW_OUTPUT: "{{ blocks.run_command.outputs.stdout | default('') }}"
        COMMAND: "{{ inputs.command }}"
        WORKING_DIR: "{{ inputs.working_dir }}"

  - id: store_execution
    type: Sql
    description: Store execution record in database.
    depends_on: [parse_output]
    condition: "{{ inputs.state | trim != '' and inputs.task_id | trim != '' }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.execution }}"
      op: insert
      data:
        task_id: "{{ inputs.task_id }}"
        command: "{{ inputs.command }}"
        working_dir: "{{ inputs.working_dir }}"
        exit_code: "{{ get(blocks.parse_output.outputs.stdout, 'exit_code', 1) }}"
        stdout: "{{ get(blocks.parse_output.outputs.stdout, 'stdout', '') }}"
        stderr: ""
        duration_ms: "{{ get(blocks.parse_output.outputs.stdout, 'duration_ms', 0) }}"
        phase: "{{ inputs.phase }}"
        iteration: "{{ inputs.iteration }}"

outputs:
  result:
    type: dict
    description: "Execution result with exit_code, stdout, duration."
    value: "{{ blocks.parse_output.outputs.stdout }}"

  success:
    type: bool
    description: "Whether command succeeded (exit_code == 0)."
    value: "{{ get(blocks.parse_output.outputs.stdout, 'success', false) }}"

  exit_code:
    type: num
    description: "Command exit code."
    value: "{{ get(blocks.parse_output.outputs.stdout, 'exit_code', 1) }}"
