# =============================================================================
# CORTEX Embed File Capability
# =============================================================================
#
# Generates and caches an embedding for a single file. Uses lazy generation:
# embeddings are only generated if not already cached with the same content_hash.
#
# Cache invalidation is based on content_hash (SHA256 of file content):
# - If file content changes, hash changes, and embedding is regenerated
# - If file is unchanged, cached embedding is returned immediately
#
# This capability is designed for use with semantic-search.yaml which calls
# it in parallel for multiple files.
#
# =============================================================================

name: cortex-embed-file
description: "Generate and cache embedding for a single file (lazy generation)"

tags: [cortex, capability, embedding, cache]

inputs:
  path:
    type: str
    description: Absolute path to file to embed.
    required: true

  content_hash:
    type: str
    description: SHA256 hash of file content (first 16 chars).
    required: true

  profile:
    type: str
    description: LLM profile name for embedding model.
    default: "embedding"

  state:
    type: str
    description: Path to SQLite state database.
    required: true

  models:
    type: dict
    description: Model definitions for CRUD operations.
    default: {}

  parent_id:
    type: str
    description: Parent task ID for task tree.
    default: ""

  max_file_size:
    type: num
    description: Maximum file size to embed (bytes).
    default: 50000

blocks:
  # ===========================================================================
  # STEP 1: Check if already cached with same hash
  # ===========================================================================
  - id: check_cache
    type: Sql
    description: Check if embedding is already cached for this file+hash.
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      sql: |
        SELECT id, embedding, dimensions, model
        FROM file_embeddings
        WHERE path = ? AND content_hash = ?
      params:
        - "{{ inputs.path }}"
        - "{{ inputs.content_hash }}"

  # ===========================================================================
  # STEP 2: Read file content if not cached
  # ===========================================================================
  - id: read_file
    type: Shell
    description: Read file content for embedding (only if not cached).
    condition: "{{ (blocks.check_cache.outputs.rows | default([])) | length == 0 }}"
    depends_on: [check_cache]
    inputs:
      command: |
        head -c {{ inputs.max_file_size }} '{{ inputs.path }}' 2>/dev/null || echo ''

  # ===========================================================================
  # STEP 3: Generate embedding if not cached
  # ===========================================================================
  - id: generate
    type: Workflow
    description: Generate embedding for file content.
    condition: "{{ blocks.read_file.succeeded and (blocks.read_file.outputs.stdout | trim) != '' }}"
    depends_on: [read_file]
    inputs:
      workflow: cortex-generate-embedding
      inputs:
        text: "{{ blocks.read_file.outputs.stdout[:10000] }}"
        profile: "{{ inputs.profile }}"
        state: "{{ inputs.state }}"
        models: "{{ inputs.models }}"
        parent_id: "{{ inputs.parent_id }}"

  # ===========================================================================
  # STEP 4: Store embedding in cache (upsert)
  # ===========================================================================
  - id: store_cache
    type: Sql
    description: Store generated embedding in cache.
    condition: "{{ blocks.generate.succeeded and blocks.generate.outputs.success }}"
    depends_on: [generate]
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      sql: |
        INSERT INTO file_embeddings (id, path, content_hash, embedding, dimensions, model, token_count, created_at)
        VALUES (
          lower(hex(randomblob(16))),
          ?,
          ?,
          ?,
          ?,
          ?,
          ?,
          datetime('now')
        )
        ON CONFLICT(path) DO UPDATE SET
          content_hash = excluded.content_hash,
          embedding = excluded.embedding,
          dimensions = excluded.dimensions,
          model = excluded.model,
          token_count = excluded.token_count,
          created_at = excluded.created_at
      params:
        - "{{ inputs.path }}"
        - "{{ inputs.content_hash }}"
        - "{{ blocks.generate.outputs.embedding | tojson }}"
        - "{{ blocks.generate.outputs.dimensions }}"
        - "{{ (blocks.generate.outputs.metadata | default({})).model | default('') }}"
        - "{{ (blocks.read_file.outputs.stdout | length) // 4 }}"

# =============================================================================
# OUTPUTS
# =============================================================================
outputs:
  embedding:
    type: list
    description: "Vector embedding (from cache or newly generated)."
    value: >-
      {{
        blocks.generate.outputs.embedding
        if blocks.generate.succeeded and blocks.generate.outputs.success
        else (blocks.check_cache.outputs.rows[0].embedding | fromjson)
        if (blocks.check_cache.outputs.rows | default([])) | length > 0
        else []
      }}

  dimensions:
    type: num
    description: "Embedding dimensions."
    value: >-
      {{
        blocks.generate.outputs.dimensions
        if blocks.generate.succeeded and blocks.generate.outputs.success
        else blocks.check_cache.outputs.rows[0].dimensions
        if (blocks.check_cache.outputs.rows | default([])) | length > 0
        else 0
      }}

  cached:
    type: bool
    description: "Whether embedding was retrieved from cache."
    value: "{{ (blocks.check_cache.outputs.rows | default([])) | length > 0 }}"

  success:
    type: bool
    description: "Whether embedding is available (cached or generated)."
    value: >-
      {{
        (blocks.check_cache.outputs.rows | default([])) | length > 0
        or (blocks.generate.succeeded and blocks.generate.outputs.success)
      }}

  path:
    type: str
    description: "File path (passthrough)."
    value: "{{ inputs.path }}"
