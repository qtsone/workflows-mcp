name: cortex-action-dispatch
description: |
  Atomic capability: Dispatch action with deduplication.

  This is a wrapper that provides transparent action deduplication:
  1. Logs the action (checks for existing action with same capability+inputs)
  2. If action already completed, returns cached result (skip execution)
  3. If new or pending, executes the capability workflow
  4. Marks action complete/failed with result
  5. Returns result (cached or fresh)

  Use this wrapper instead of calling capability workflows directly
  to prevent duplicate mutations (idempotency).

  The wrapper handles these statuses:
  - pending: Execute (new action logged)
  - completed: Skip (return cached result)
  - failed: Re-execute (retry failed action)
  - rolled_back: Re-execute (action was undone)

  v2 enhancements:
  - backup_enabled: When true, backs up files before modification

tags: [cortex, capability, atomic, actions, deduplication, wrapper, v2]

inputs:
  state:
    type: str
    description: Path to SQLite state database.
    required: true

  cell_id:
    type: str
    description: Cell ID requesting the action.
    required: true

  capability:
    type: str
    description: Capability workflow name to execute.
    required: true

  inputs:
    type: dict
    description: Inputs to pass to the capability workflow.
    required: true

  reason:
    type: str
    description: Why this action is being executed (for audit).
    required: false
    default: ""

  base_path:
    type: str
    description: Base path for file operations.
    required: false
    default: "."

  permissions:
    type: dict
    description: Available permissions.
    required: false
    default: { "read": true, "write": false, "execute": false }

  models:
    type: dict
    description: Model definitions for CRUD operations.
    required: false
    default: {}

  parent_id:
    type: str
    description: Parent task ID for task tree registration.
    required: false
    default: ""

  backup_enabled:
    type: bool
    description: Whether to backup files before modification (v2 feature).
    required: false
    default: false

blocks:
  - id: register
    type: Sql
    description: Register this capability in the task tree.
    condition: "{{ inputs.state | trim != '' }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: insert
      data:
        parent_id: "{{ inputs.parent_id if inputs.parent_id else none }}"
        kind: capability
        name: cortex-action-dispatch
        metadata: "{'labels': {'capability_type': 'action', 'side_effects': 'true', 'backup_enabled': {{inputs.backup_enabled}}}}"
        inputs: "{{ inputs }}"
        status: running
        depth: "{{ inputs.depth }}"

  - id: log_action
    type: Workflow
    description: Log action and check for duplicates.
    depends_on:
      - block: register
        required: false
    inputs:
      workflow: cortex-action-log
      inputs:
        state: "{{ inputs.state }}"
        models: "{{ inputs.models }}"
        cell_id: "{{ inputs.cell_id }}"
        capability: "{{ inputs.capability }}"
        inputs_json: "{{ inputs.inputs | tojson }}"

  - id: check_execute
    type: Shell
    description: Determine if action should be executed or use cached result.
    depends_on: [log_action]
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        status = os.environ.get('STATUS', 'pending')
        cached_result = os.environ.get('CACHED_RESULT', '')
        action_id = os.environ.get('ACTION_ID', '')

        should_execute = True
        result = None
        reason = 'new_action'

        if status == 'completed':
            should_execute = False
            reason = 'cached_completed'
            try:
                result = json.loads(cached_result) if cached_result else {}
            except json.JSONDecodeError:
                result = {'raw': cached_result}
        elif status == 'failed':
            should_execute = True
            reason = 'retry_failed'
        elif status == 'pending':
            should_execute = True
            reason = 'pending'
        elif status == 'rolled_back':
            should_execute = True
            reason = 'retry_rolled_back'
        else:
            should_execute = True
            reason = f'unknown_status:{status}'

        print(json.dumps({
            'should_execute': should_execute,
            'reason': reason,
            'action_id': action_id,
            'cached_result': result,
            'status': status
        }))
        EOF
      env:
        STATUS: "{{ blocks.log_action.outputs.status | default('pending') }}"
        CACHED_RESULT: "{{ blocks.log_action.outputs.cached_result | default({}) | tojson }}"
        ACTION_ID: "{{ blocks.log_action.outputs.action_id | default('') }}"

  - id: backup_files
    type: Workflow
    description: Backup files before modification.
    depends_on: [check_execute]
    condition: |
      {{ inputs.backup_enabled
         and get(blocks.check_execute.outputs.stdout, 'should_execute', false)
         and inputs.inputs.path is defined }}
    inputs:
      workflow: cortex-backup-files
      inputs:
        state: "{{ inputs.state }}"
        models: "{{ inputs.models }}"
        task_id: "{{ inputs.cell_id }}"
        files: "{{ [inputs.inputs.path] if inputs.inputs.path is string else inputs.inputs.path | default([]) }}"
        base_path: "{{ inputs.base_path }}"

  - id: execute_capability
    type: Workflow
    description: Execute the actual capability workflow.
    depends_on:
      - block: check_execute
        required: true
      - block: backup_files
        required: false
    condition: "{{ get(blocks.check_execute.outputs.stdout, 'should_execute', false) }}"
    continue_on_error: true
    inputs:
      workflow: "{{ inputs.capability }}"
      inputs: "{{ {'state': inputs.state, 'models': inputs.models, 'parent_id': get(blocks.register.outputs, 'rows.0.id', ''), 'base_path': inputs.base_path, 'permissions': inputs.permissions} | combine(inputs.inputs) }}"

  - id: complete_action
    type: Sql
    description: Mark action as completed with result.
    depends_on: [execute_capability]
    condition: "{{ blocks.execute_capability.succeeded }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.action }}"
      op: update
      where:
        id: "{{ get(blocks.check_execute.outputs.stdout, 'action_id', '') }}"
      data:
        status: completed
        result: "{{ blocks.execute_capability.outputs }}"

  - id: fail_action
    type: Sql
    description: Mark action as failed.
    depends_on: [execute_capability]
    condition: "{{ blocks.execute_capability.failed and get(blocks.check_execute.outputs.stdout, 'should_execute', false) }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.action }}"
      op: update
      where:
        id: "{{ get(blocks.check_execute.outputs.stdout, 'action_id', '') }}"
      data:
        status: failed
        result: "{'error': {{ get(blocks.execute_capability.metadata, 'error_message', 'Unknown error') }} }"

  - id: track_done
    type: Sql
    description: Mark capability complete in task tree.
    condition: "{{ blocks.register.succeeded }}"
    depends_on:
      - block: register
        required: true
      - block: complete_action
        required: false
      - block: fail_action
        required: false
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: update
      where:
        id: "{{ get(blocks.register.outputs, 'rows.0.id', '') }}"
      data:
        status: done
        outputs: "{'action_id': {{ get(blocks.check_execute.outputs.stdout, 'action_id', ''), 'executed': get(blocks.check_execute.outputs.stdout, 'should_execute', false) }}, 'cached': {{ (not get(blocks.check_execute.outputs.stdout, 'should_execute', false)) }}, 'success': {{ (blocks.execute_capability.succeeded or (not get(blocks.check_execute.outputs.stdout, 'should_execute', false)))}}, 'backup_created': {{ blocks.backup_files.succeeded | default(false) }}}"

outputs:
  success:
    value: |
      {{ blocks.execute_capability.succeeded
         or (not get(blocks.check_execute.outputs.stdout, 'should_execute', false)) }}
    type: bool
    description: Whether action succeeded (executed or cached).

  executed:
    value: "{{ get(blocks.check_execute.outputs.stdout, 'should_execute', false) }}"
    type: bool
    description: Whether action was actually executed (vs cached).

  cached:
    value: "{{ not get(blocks.check_execute.outputs.stdout, 'should_execute', false) }}"
    type: bool
    description: Whether cached result was used.

  action_id:
    value: "{{ get(blocks.check_execute.outputs.stdout, 'action_id', '') }}"
    type: str
    description: ID of the logged action.

  reason:
    value: "{{ get(blocks.check_execute.outputs.stdout, 'reason', '') }}"
    type: str
    description: Why execution decision was made.

  result:
    value: |
      {{ blocks.execute_capability.outputs if blocks.execute_capability.succeeded
         else get(blocks.check_execute.outputs.stdout, 'cached_result', {}) }}
    type: dict
    description: Action result (fresh or cached).

  error:
    value: "{{ blocks.execute_capability.metadata.error_message | default('') if blocks.execute_capability.failed else '' }}"
    type: str
    description: Error message if action failed.

  task_id:
    value: "{{ get(blocks.register.outputs, 'rows.0.id', '') }}"
    type: str
    description: Task ID of this capability invocation.

  backup_created:
    value: "{{ blocks.backup_files.succeeded | default(false) }}"
    type: bool
    description: Whether backup was created before execution.
