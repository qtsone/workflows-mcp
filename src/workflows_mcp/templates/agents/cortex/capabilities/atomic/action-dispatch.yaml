name: cortex-action-dispatch
description: |
  Atomic capability: Dispatch action with deduplication.

  This is a wrapper that provides transparent action deduplication:
  1. Logs the action (checks for existing action with same capability+inputs)
  2. If action already completed, returns cached result (skip execution)
  3. If new or pending, executes the capability workflow
  4. Marks action complete/failed with result
  5. Returns result (cached or fresh)

  Use this wrapper instead of calling capability workflows directly
  to prevent duplicate mutations (idempotency).

  The wrapper handles these statuses:
  - pending: Execute (new action logged)
  - completed: Skip (return cached result)
  - failed: Re-execute (retry failed action)
  - rolled_back: Re-execute (action was undone)

tags: [cortex, capability, atomic, actions, deduplication, wrapper]

inputs:
  state:
    type: str
    description: Path to SQLite state database.
    required: true

  cell_id:
    type: str
    description: Cell ID requesting the action.
    required: true

  capability:
    type: str
    description: Capability workflow name to execute.
    required: true

  inputs:
    type: dict
    description: Inputs to pass to the capability workflow.
    required: true

  reason:
    type: str
    description: Why this action is being executed (for audit).
    required: false
    default: ""

  base_path:
    type: str
    description: Base path for file operations.
    required: false
    default: "."

  permissions:
    type: dict
    description: Available permissions.
    required: false
    default: { "read": true, "write": false, "execute": false }

  models:
    type: dict
    description: Model definitions for CRUD operations.
    required: false
    default: {}

  parent_id:
    type: str
    description: Parent task ID for task tree registration.
    required: false
    default: ""

blocks:
  # ===========================================================================
  # STEP 1: Register capability in task tree
  # ===========================================================================
  - id: register
    type: Sql
    description: Register this capability in the task tree.
    condition: "{{ inputs.state | trim != '' }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: insert
      data:
        parent_id: "{{ inputs.parent_id if inputs.parent_id else none }}"
        kind: capability
        name: cortex-action-dispatch
        metadata: "{{ {'labels': {'capability_type': 'action', 'side_effects': 'true'}} }}"
        inputs: "{{ {'capability': inputs.capability, 'cell_id': inputs.cell_id, 'reason': inputs.reason} }}"
        status: running
        depth: 2

  # ===========================================================================
  # STEP 2: Log action for deduplication
  # ===========================================================================
  - id: log_action
    type: Workflow
    description: Log action and check for duplicates.
    depends_on:
      - block: register
        required: false
    inputs:
      workflow: cortex-action-log
      inputs:
        state: "{{ inputs.state }}"
        models: "{{ inputs.models }}"
        cell_id: "{{ inputs.cell_id }}"
        capability: "{{ inputs.capability }}"
        inputs_json: "{{ inputs.inputs | tojson }}"

  # ===========================================================================
  # STEP 3: Check if should execute (based on action status)
  # ===========================================================================
  - id: check_execute
    type: Shell
    description: Determine if action should be executed or use cached result.
    depends_on: [log_action]
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        status = os.environ.get('STATUS', 'pending')
        cached_result = os.environ.get('CACHED_RESULT', '')
        action_id = os.environ.get('ACTION_ID', '')

        should_execute = True
        result = None
        reason = 'new_action'

        if status == 'completed':
            # Action already completed - use cached result
            should_execute = False
            reason = 'cached_completed'
            try:
                result = json.loads(cached_result) if cached_result else {}
            except json.JSONDecodeError:
                result = {'raw': cached_result}
        elif status == 'failed':
            # Previous attempt failed - retry
            should_execute = True
            reason = 'retry_failed'
        elif status == 'pending':
            # Action logged but not completed - execute
            should_execute = True
            reason = 'pending'
        elif status == 'rolled_back':
            # Action was rolled back - re-execute
            should_execute = True
            reason = 'retry_rolled_back'
        else:
            # Unknown status - execute to be safe
            should_execute = True
            reason = f'unknown_status:{status}'

        print(json.dumps({
            'should_execute': should_execute,
            'reason': reason,
            'action_id': action_id,
            'cached_result': result,
            'status': status
        }))
        EOF
      env:
        STATUS: "{{ blocks.log_action.outputs.status | default('pending') }}"
        CACHED_RESULT: "{{ blocks.log_action.outputs.cached_result | default({}) | tojson }}"
        ACTION_ID: "{{ blocks.log_action.outputs.action_id | default('') }}"

  # ===========================================================================
  # STEP 4: Execute capability (if not cached)
  # ===========================================================================
  - id: execute_capability
    type: Workflow
    description: Execute the actual capability workflow.
    depends_on: [check_execute]
    condition: "{{ (blocks.check_execute.outputs.stdout | fromjson).should_execute }}"
    continue_on_error: true
    inputs:
      workflow: "{{ inputs.capability }}"
      inputs: "{{ {'state': inputs.state, 'models': inputs.models, 'base_path': inputs.base_path, 'permissions': inputs.permissions} | combine(inputs.inputs) }}"

  # ===========================================================================
  # STEP 5: Mark action complete (on success) - inlined from action-complete
  # ===========================================================================
  - id: complete_action
    type: Sql
    description: Mark action as completed with result.
    depends_on: [execute_capability]
    condition: "{{ blocks.execute_capability.succeeded }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.action }}"
      op: update
      where:
        id: "{{ (blocks.check_execute.outputs.stdout | fromjson).action_id }}"
      data:
        status: completed
        result: "{{ blocks.execute_capability.outputs }}"

  # ===========================================================================
  # STEP 6: Mark action failed (on failure)
  # ===========================================================================
  - id: fail_action
    type: Sql
    description: Mark action as failed.
    depends_on: [execute_capability]
    condition: "{{ blocks.execute_capability.failed and (blocks.check_execute.outputs.stdout | fromjson).should_execute }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.action }}"
      op: update
      where:
        id: "{{ (blocks.check_execute.outputs.stdout | fromjson).action_id }}"
      data:
        status: failed
        result: "{{ {'error': blocks.execute_capability.metadata.error_message | default('Unknown error')} }}"

  # ===========================================================================
  # STEP 7: Track completion
  # ===========================================================================
  - id: track_done
    type: Sql
    description: Mark capability complete in task tree.
    condition: "{{ inputs.state | trim != '' }}"
    depends_on:
      - block: complete_action
        required: false
      - block: fail_action
        required: false
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: update
      where:
        id: "{{ blocks.register.outputs.rows[0].id }}"
      data:
        status: done
        outputs: "{{ {'action_id': (blocks.check_execute.outputs.stdout | fromjson).action_id, 'executed': (blocks.check_execute.outputs.stdout | fromjson).should_execute, 'cached': (not (blocks.check_execute.outputs.stdout | fromjson).should_execute), 'success': (blocks.execute_capability.succeeded or (not (blocks.check_execute.outputs.stdout | fromjson).should_execute))} }}"

outputs:
  success:
    value: |
      {{ blocks.execute_capability.succeeded
         or (not (blocks.check_execute.outputs.stdout | fromjson).should_execute) }}
    type: bool
    description: Whether action succeeded (executed or cached).

  executed:
    value: "{{ (blocks.check_execute.outputs.stdout | fromjson).should_execute }}"
    type: bool
    description: Whether action was actually executed (vs cached).

  cached:
    value: "{{ not (blocks.check_execute.outputs.stdout | fromjson).should_execute }}"
    type: bool
    description: Whether cached result was used.

  action_id:
    value: "{{ (blocks.check_execute.outputs.stdout | fromjson).action_id }}"
    type: str
    description: ID of the logged action.

  reason:
    value: "{{ (blocks.check_execute.outputs.stdout | fromjson).reason }}"
    type: str
    description: Why execution decision was made.

  result:
    value: |
      {{ blocks.execute_capability.outputs if blocks.execute_capability.succeeded
         else ((blocks.check_execute.outputs.stdout | fromjson).cached_result | default({})) }}
    type: dict
    description: Action result (fresh or cached).

  error:
    value: "{{ blocks.execute_capability.metadata.error_message | default('') if blocks.execute_capability.failed else '' }}"
    type: str
    description: Error message if action failed.

  task_id:
    value: "{{ blocks.register.outputs.rows[0].id | default('') }}"
    type: str
    description: Task ID of this capability invocation.
