# =============================================================================
# CORTEX v2 Atomic Capability: Rollback Files
# =============================================================================
#
# Restores files from backups when verification fails.
# Retrieves content from backups table and overwrites current files.
#
# =============================================================================

name: cortex-rollback-files
description: "Restore files from backups when verification fails"

tags: [cortex, capability, rollback, atomic, v2]

inputs:
  state:
    type: str
    description: Path to SQLite state database.
    required: true

  models:
    type: dict
    description: Model definitions.
    default: {}

  task_id:
    type: str
    description: Task ID to rollback backups for.
    required: true

  base_path:
    type: str
    description: Base path for relative file paths.
    default: "."

blocks:
  - id: get_backups
    type: Sql
    description: Retrieve backups for this task.
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      sql: |
        SELECT id, file_path, content, hash
        FROM backups
        WHERE task_id = ?
        ORDER BY created_at DESC
      params:
        - "{{ inputs.task_id }}"

  - id: restore_files
    type: Shell
    description: Restore files from backups.
    depends_on: [get_backups]
    condition: "{{ blocks.get_backups.succeeded and blocks.get_backups.outputs.row_count > 0 }}"
    for_each: "{{ blocks.get_backups.outputs.rows }}"
    for_each_mode: sequential
    continue_on_error: true
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        file_path = os.environ.get('FILE_PATH', '')
        content = os.environ.get('CONTENT', '')
        backup_hash = os.environ.get('BACKUP_HASH', '')
        base_path = os.environ.get('BASE_PATH', '.')

        # Resolve full path
        if not os.path.isabs(file_path):
            full_path = os.path.join(base_path, file_path)
        else:
            full_path = file_path

        result = {
            'file_path': file_path,
            'full_path': full_path,
            'restored': False,
            'error': None
        }

        try:
            if content:
                # Ensure directory exists
                os.makedirs(os.path.dirname(full_path), exist_ok=True)

                # Write backup content
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                result['restored'] = True
            else:
                # Content was empty - file didn't exist before, remove it
                if os.path.exists(full_path):
                    os.remove(full_path)
                result['restored'] = True
                result['removed'] = True
        except Exception as e:
            result['error'] = str(e)

        print(json.dumps(result))
        EOF
      env:
        FILE_PATH: "{{ each.value.file_path }}"
        CONTENT: "{{ each.value.content | default('') }}"
        BACKUP_HASH: "{{ each.value.hash | default('') }}"
        BASE_PATH: "{{ inputs.base_path }}"

  - id: mark_backups_used
    type: Sql
    description: Mark backups as used for rollback.
    depends_on: [restore_files]
    condition: "{{ blocks.restore_files.succeeded }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      sql: |
        UPDATE backups
        SET hash = hash || ':rolled_back'
        WHERE task_id = ?
      params:
        - "{{ inputs.task_id }}"

outputs:
  restored:
    type: num
    description: "Number of files restored."
    value: "{{ blocks.restore_files.metadata.count | default(0) }}"

  success:
    type: bool
    description: "Whether rollback succeeded."
    value: "{{ blocks.restore_files.succeeded and blocks.restore_files.metadata.count_failed == 0 }}"
