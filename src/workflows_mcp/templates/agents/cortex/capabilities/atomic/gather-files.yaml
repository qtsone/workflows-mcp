name: cortex-gather-files
description: |
  Atomic capability: Read files matching patterns and store as evidence.
  Wraps ReadFiles block with cortex-compatible interface.
  Automatically stores gathered content in episodic memory (evidence table).

tags: [cortex, capability, atomic, gather, evidence]

inputs:
  patterns:
    type: list
    description: Glob patterns for files to read.
    required: true

  base_path:
    type: str
    description: Base directory to search from.
    required: false
    default: "."

  mode:
    type: str
    description: Output mode (outline, full, summary).
    required: false
    default: "outline"

  max_files:
    type: num
    description: Maximum files to read.
    required: false
    default: 20

  max_file_size_kb:
    type: num
    description: Maximum file size in KB.
    required: false
    default: 100

  state:
    type: str
    description: Path to SQLite state database (for evidence storage and task tracking).
    required: false
    default: ""

  models:
    type: dict
    description: Model definitions for CRUD operations.
    required: false
    default: {}

  parent_id:
    type: str
    description: Parent task ID for task tree registration.
    required: false
    default: ""

  task_id:
    type: str
    description: Task ID for evidence tracking.
    required: false
    default: ""

blocks:
  # ===========================================================================
  # STEP 1: Register capability in task tree
  # ===========================================================================
  - id: register
    type: Sql
    description: Register this capability in the task tree.
    condition: "{{ inputs.state | trim != '' }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: insert
      data:
        parent_id: "{{ inputs.parent_id if inputs.parent_id else none }}"
        kind: capability
        name: cortex-gather-files
        metadata: "{{ {'labels': {'capability_type': 'gather', 'side_effects': 'false'}} }}"
        inputs: "{{ {'patterns': inputs.patterns, 'base_path': inputs.base_path, 'mode': inputs.mode, 'max_files': inputs.max_files} }}"
        status: running
        depth: 2

  # ===========================================================================
  # STEP 2: Read files
  # ===========================================================================
  - id: read
    type: ReadFiles
    depends_on:
      - block: register
        required: false
    inputs:
      patterns: "{{ inputs.patterns }}"
      base_path: "{{ inputs.base_path }}"
      mode: "{{ inputs.mode }}"
      max_files: "{{ inputs.max_files }}"
      max_file_size_kb: "{{ inputs.max_file_size_kb }}"

  # ===========================================================================
  # STEP 3: Store each file as evidence in memory table
  # ===========================================================================
  - id: store_evidence
    type: Sql
    description: Store gathered files as evidence in memory.
    depends_on: [read]
    condition: "{{ inputs.state | trim != '' and blocks.read.outputs.files | length > 0 }}"
    for_each: "{{ blocks.read.outputs.files }}"
    for_each_mode: parallel
    max_parallel: 10
    continue_on_error: true
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.memory }}"
      op: upsert
      data:
        namespace: "{{ 'outline' if inputs.mode == 'outline' else 'content' }}"
        key: "{{ each.value.path }}"
        value: "{{ each.value.content | default('') }}"
        metadata: "{{ {'path': each.value.path, 'size_bytes': each.value.size_bytes | default(0), 'type': inputs.mode} }}"
        task_id: "{{ inputs.task_id if inputs.task_id else (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
      conflict: [namespace, key]

  # ===========================================================================
  # STEP 4: Track completion
  # ===========================================================================
  - id: track_done
    type: Sql
    description: Mark capability complete in task tree.
    depends_on:
      - block: register
        required: true
      - block: read
        required: false
      - block: store_evidence
        required: false
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: update
      where:
        id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
      data:
        status: "{{ 'done' if blocks.read.succeeded else 'failed' }}"
        outputs: "{{ {'total_files': blocks.read.outputs.total_files | default(0), 'total_size_kb': blocks.read.outputs.total_size_kb | default(0), 'evidence_stored': blocks.store_evidence.metadata.count | default(0), 'error': blocks.read.metadata.message | default('')} }}"

outputs:
  files:
    value: "{{ blocks.read.outputs.files }}"
    type: list
    description: List of files with content.

  total_files:
    value: "{{ blocks.read.outputs.total_files }}"
    type: num
    description: Number of files read.

  total_size_kb:
    value: "{{ blocks.read.outputs.total_size_kb }}"
    type: num
    description: Total size in KB.

  evidence:
    value: |
      {{
        blocks.read.outputs.files | map(attribute='path') | list
      }}
    type: list
    description: Evidence references for findings (file paths).

  evidence_stored:
    value: "{{ blocks.store_evidence.metadata.count | default(0) }}"
    type: num
    description: Number of files stored as evidence.

  task_id:
    value: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
    type: str
    description: Task ID of this capability invocation.

  state:
    value: "{{ inputs.state }}"
    type: str
    description: Path to state database (passthrough).
