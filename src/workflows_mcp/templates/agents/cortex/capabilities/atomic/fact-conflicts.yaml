name: cortex-fact-conflicts
description: |
  Atomic capability: Detect conflicting facts in semantic memory.
  Used by REASON phase before storing new facts to identify contradictions.

  Conflict detection uses FTS5 to find similar claims,
  then returns potential conflicts for human review or automatic resolution.

tags: [cortex, capability, atomic, facts, memory]

inputs:
  state:
    type: str
    description: Path to SQLite state database.
    required: true

  new_facts:
    type: str
    description: JSON array of new facts to check for conflicts.
    required: true

  models:
    type: dict
    description: Model definitions for CRUD operations.
    required: false
    default: {}

  parent_id:
    type: str
    description: Parent task ID for task tree registration.
    required: false
    default: ""

blocks:
  # ===========================================================================
  # STEP 1: Register capability in task tree
  # ===========================================================================
  - id: register
    type: Sql
    description: Register this capability in the task tree.
    condition: "{{ inputs.state | trim != '' }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: insert
      data:
        parent_id: "{{ inputs.parent_id if inputs.parent_id else none }}"
        kind: capability
        name: cortex-fact-conflicts
        metadata: "{{ {'labels': {'capability_type': 'fact', 'side_effects': 'false'}} }}"
        inputs: "{{ {'new_facts_count': (inputs.new_facts | fromjson | default([])) | length} }}"
        status: running
        depth: 2

  # ===========================================================================
  # STEP 2: Detect conflicts (FTS5 search for similar claims)
  # ===========================================================================
  - id: detect
    type: Shell
    depends_on:
      - block: register
        required: false
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os
        import sqlite3

        state = os.environ.get('STATE', '')
        new_facts_json = os.environ.get('NEW_FACTS', '[]')

        try:
            new_facts = json.loads(new_facts_json)
        except json.JSONDecodeError:
            new_facts = []

        conflicts = []

        if state and new_facts:
            conn = sqlite3.connect(state)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()

            for fact in new_facts:
                claim = fact.get('claim', '')
                if claim:
                    # Search for similar claims using FTS5
                    try:
                        cursor.execute('''
                            SELECT f.id, f.claim, f.confidence, f.evidence_type
                            FROM facts f
                            JOIN facts_fts fts ON f.id = fts.id
                            WHERE facts_fts MATCH ? AND f.status = 'active'
                            LIMIT 5
                        ''', (claim[:50],))  # Use first 50 chars for FTS match
                        rows = cursor.fetchall()
                        for row in rows:
                            conflicts.append({
                                'new_claim': claim,
                                'existing_id': row['id'],
                                'existing_claim': row['claim'],
                                'existing_confidence': row['confidence']
                            })
                    except sqlite3.OperationalError:
                        # FTS table might not exist yet
                        pass

            conn.close()

        print(json.dumps({
            'success': True,
            'conflicts': conflicts,
            'has_conflicts': len(conflicts) > 0
        }))
        EOF
      env:
        STATE: "{{ inputs.state }}"
        NEW_FACTS: "{{ inputs.new_facts }}"

  # ===========================================================================
  # STEP 3: Track completion
  # ===========================================================================
  - id: track_done
    type: Sql
    description: Mark capability complete in task tree.
    depends_on:
      - block: register
        required: true
      - block: detect
        required: false
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: update
      where:
        id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
      data:
        status: "{{ 'done' if blocks.detect.succeeded else 'failed' }}"
        outputs: "{{ {'has_conflicts': (blocks.detect.outputs.stdout | fromjson).has_conflicts | default(false) if blocks.detect.succeeded else false, 'conflict_count': (blocks.detect.outputs.stdout | fromjson).conflicts | default([]) | length if blocks.detect.succeeded else 0, 'success': blocks.detect.succeeded, 'error': blocks.detect.metadata.message | default('')} }}"

outputs:
  success:
    value: "{{ (blocks.detect.outputs.stdout | fromjson).success | default(false) }}"
    type: bool
    description: Whether operation succeeded.

  conflicts:
    value: "{{ (blocks.detect.outputs.stdout | fromjson).conflicts | default([]) }}"
    type: list
    description: List of detected conflicts.

  has_conflicts:
    value: "{{ (blocks.detect.outputs.stdout | fromjson).has_conflicts | default(false) }}"
    type: bool
    description: Whether any conflicts were found.

  conflict_count:
    value: "{{ (blocks.detect.outputs.stdout | fromjson).conflicts | default([]) | length }}"
    type: num
    description: Number of conflicts detected.

  task_id:
    value: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
    type: str
    description: Task ID of this capability invocation.
