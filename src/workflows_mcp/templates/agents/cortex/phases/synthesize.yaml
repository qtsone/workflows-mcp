name: cortex-phase-synthesize
description: |
  CORTEX Synthesis Phase

  Merges all findings into unified conclusions.
  Deduplicates, resolves contradictions, and produces actionable summary.

tags: [cortex, phase, synthesize]

inputs:
  query:
    type: str
    description: The original query.
    required: true

  findings:
    type: list
    description: Findings from analysis phase(s).
    required: true

  child_syntheses:
    type: list
    description: Synthesis results from child cells.
    required: false
    default: []

  context:
    type: dict
    description: Shared context from parent cell.
    required: true

  capabilities:
    type: dict
    description: Available capabilities registry.
    required: false
    default: {}

  state:
    type: str
    description: Path to SQLite state database (auto-created if empty).
    required: false
    default: ""

  parent_task_id:
    type: str
    description: Parent cell's task ID.
    required: false
    default: ""

  profile:
    type: str
    description: LLM profile to use.
    required: false
    default: "default"

blocks:
  - id: register_task
    type: Workflow
    description: Register this phase in the task tree.
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        parent_id: "{{ inputs.parent_task_id }}"
        task: "Phase: Synthesize"
        task_type: "cortex-synthesize"
        status: "in-progress"
        caller: "cortex-phase-synthesize"

  # Retrieve all findings from memory
  - id: retrieve_all_findings
    type: Workflow
    description: Retrieve accumulated findings from memory.
    depends_on: [register_task]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        op: memory
        memory_op: get
        memory_key: "findings"
        memory_default: "[]"
        caller: "cortex-phase-synthesize"

  # Merge all findings
  - id: merge_findings
    type: Shell
    description: Merge local findings with memory and child syntheses.
    depends_on: [retrieve_all_findings]
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os
        from collections import defaultdict

        local_findings = json.loads(os.environ.get('LOCAL_FINDINGS', '[]'))
        memory_findings = json.loads(os.environ.get('MEMORY_FINDINGS', '[]'))
        child_syntheses = json.loads(os.environ.get('CHILD_SYNTHESES', '[]'))

        all_findings = []

        # Add local findings
        for f in local_findings:
            f['source'] = 'local'
            all_findings.append(f)

        # Add memory findings (from recursive analysis)
        if isinstance(memory_findings, list):
            for batch in memory_findings:
                if isinstance(batch, dict) and 'findings' in batch:
                    for f in batch['findings']:
                        f['source'] = f'depth_{batch.get("depth", "?")}'
                        all_findings.append(f)

        # Add child synthesis findings
        for cs in child_syntheses:
            if isinstance(cs, dict):
                # Handle for_each iteration results
                outputs = cs.get('outputs', cs)
                if 'synthesis' in outputs:
                    child_findings = outputs['synthesis'].get('findings', [])
                    for f in child_findings:
                        f['source'] = 'child'
                        all_findings.append(f)

        # Deduplicate by claim
        seen_claims = set()
        unique_findings = []
        for f in all_findings:
            claim = f.get('claim', '')
            claim_key = claim.lower().strip()[:100]
            if claim_key not in seen_claims:
                seen_claims.add(claim_key)
                unique_findings.append(f)

        # Count by severity
        severity_counts = defaultdict(int)
        for f in unique_findings:
            severity_counts[f.get('severity', 'info')] += 1

        result = {
            'all_findings': unique_findings,
            'total_count': len(unique_findings),
            'duplicates_removed': len(all_findings) - len(unique_findings),
            'severity_counts': dict(severity_counts),
            'sources': {
                'local': len([f for f in unique_findings if f.get('source') == 'local']),
                'memory': len([f for f in unique_findings if f.get('source', '').startswith('depth')]),
                'child': len([f for f in unique_findings if f.get('source') == 'child'])
            }
        }

        print(json.dumps(result))
        EOF
      env:
        LOCAL_FINDINGS: "{{ inputs.findings | tojson }}"
        MEMORY_FINDINGS: "{{ blocks.retrieve_all_findings.outputs.memory.value | default([]) | tojson }}"
        CHILD_SYNTHESES: "{{ inputs.child_syntheses | tojson }}"

  - id: synthesize
    type: LLMCall
    description: Create unified synthesis from all findings.
    depends_on: [merge_findings]
    inputs:
      profile: "{{ inputs.profile }}"
      timeout: 120
      prompt: |
        # Synthesis Phase

        You are the synthesis module of a recursive cognitive system (CORTEX).
        Merge all findings into unified, actionable conclusions.

        ## Original Query
        {{ inputs.query }}

        ## Context
        - Repository Path: {{ inputs.context.repo_path | default('Not specified') }}
        - Focus Area: {{ inputs.context.focus | default('general') }}

        ## Findings Summary
        - Total Findings: {{ (blocks.merge_findings.outputs.stdout | fromjson).total_count }}
        - Duplicates Removed: {{ (blocks.merge_findings.outputs.stdout | fromjson).duplicates_removed }}
        - Severity Distribution: {{ (blocks.merge_findings.outputs.stdout | fromjson).severity_counts | tojson }}

        ## All Findings

        {% for finding in (blocks.merge_findings.outputs.stdout | fromjson).all_findings %}
        ### Finding {{ loop.index }} [{{ finding.severity | upper }}] ({{ finding.source }})
        - **Claim:** {{ finding.claim }}
        - **Evidence:** {{ finding.evidence_refs | default([]) | join(', ') }}
        - **Confidence:** {{ finding.confidence | default(0.5) }}
        - **Verified:** {{ finding.verified | default(false) }}
        {% if get(finding, 'code_snippet') %}
        ```
        {{ get(finding, 'code_snippet')[:500] }}
        ```
        {% endif %}
        {% endfor %}

        ## Synthesis Rules

        1. **Deduplicate**: Same finding from multiple sources → one entry
        2. **Resolve**: Contradictions → prefer higher-evidence source
        3. **Aggregate**: Child findings may escalate/de-escalate severity
        4. **Chain**: Maintain evidence trails to original sources
        5. **Conclude**: Actionable summary, not just finding list

        ## Instructions

        Create a unified synthesis that directly answers the original query.

      response_schema:
        type: object
        properties:
          synthesis:
            type: object
            properties:
              findings:
                type: array
                items:
                  type: object
                  properties:
                    claim:
                      type: string
                    severity:
                      type: string
                      enum: [critical, high, medium, low, info]
                    confidence:
                      type: number
                    evidence_chain:
                      type: array
                      items:
                        type: string
                    action_required:
                      type: boolean
                  required: [claim, severity, confidence]
                description: "Synthesized findings"
              summary:
                type: string
                description: "Human-readable summary answering the query"
              risk_level:
                type: string
                enum: [critical, high, medium, low, info]
                description: "Overall risk level"
              recommendations:
                type: array
                items:
                  type: string
                description: "Suggested next steps"
              confidence:
                type: number
                minimum: 0
                maximum: 1
                description: "Overall confidence in synthesis"
              actions_needed:
                type: boolean
                description: "Whether actions are recommended"
            required: [findings, summary, risk_level, confidence]
          answer:
            type: string
            description: "Direct answer to the original query"
          completeness:
            type: string
            enum: [complete, partial, insufficient]
            description: "How completely the query was answered"
        required: [synthesis, answer, completeness]

  - id: store_synthesis
    type: Workflow
    description: Store synthesis in memory.
    depends_on: [synthesize]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        op: memory
        memory_op: set
        memory_key: "synthesis"
        memory_value: |
          {
            "synthesis": {{ blocks.synthesize.outputs.response.synthesis | tojson }},
            "answer": {{ blocks.synthesize.outputs.response.answer | tojson }},
            "completeness": "{{ blocks.synthesize.outputs.response.completeness }}"
          }
        caller: "cortex-phase-synthesize"

  - id: track_done
    type: Workflow
    description: Mark phase complete.
    depends_on: [synthesize, store_synthesis]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        status: "done"
        caller: "cortex-phase-synthesize"
        data:
          risk_level: "{{ blocks.synthesize.outputs.response.synthesis.risk_level }}"
          completeness: "{{ blocks.synthesize.outputs.response.completeness }}"
          findings_count: "{{ blocks.synthesize.outputs.response.synthesis.findings | length }}"

outputs:
  synthesis:
    value: "{{ blocks.synthesize.outputs.response.synthesis }}"
    type: dict
    description: Unified synthesis object.

  answer:
    value: "{{ blocks.synthesize.outputs.response.answer }}"
    type: str
    description: Direct answer to the query.

  completeness:
    value: "{{ blocks.synthesize.outputs.response.completeness }}"
    type: str
    description: How completely the query was answered.

  risk_level:
    value: "{{ blocks.synthesize.outputs.response.synthesis.risk_level }}"
    type: str
    description: Overall risk level.

  recommendations:
    value: "{{ get(blocks.synthesize.outputs.response.synthesis, 'recommendations', []) }}"
    type: list
    description: Recommended next steps.

  actions_needed:
    value: "{{ get(blocks.synthesize.outputs.response.synthesis, 'actions_needed', false) }}"
    type: bool
    description: Whether actions are recommended.
