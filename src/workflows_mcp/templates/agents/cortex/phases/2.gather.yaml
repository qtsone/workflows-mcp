name: cortex-phase-gather
description: |
  CORTEX Gather Phase (ReAct Pattern) - collects evidence with recursive spawning.

  Industry Standard: ReAct (Reason + Act) + Reflexion Hybrid
  - RECALL = THINK (query existing evidence + facts from DB)
  - PLAN   = REASON (LLM plans operations and investigations)
  - ACT    = dispatch + investigations (execute and store evidence)
  - Loop via recursion when investigations produce new knowledge

  Quality emerges from recursion - each level adds more evidence to shared DB.
  No explicit sufficiency check - REASON phase is the true gatekeeper.

tags: [cortex, phase, gather, react]

inputs:
  prompt:
    type: str
    description: The prompt to gather evidence for.
    required: true

  system:
    type: str
    description: System prompt override.
    default: |
      You are the evidence gathering module of a recursive cognitive system (CORTEX).
      Your role is to plan and execute data collection to answer queries.

      Be efficient - gather only what's needed based on the configured depth level.
      Store important files to memory for use by later phases.

      If you discover something that requires different analysis than expected,
      you can output config_override to adjust REASON/ACT behavior.

      Express ALL sub-questions via investigations, not uncertainty fields.

  context:
    type: dict
    description: Context including repo_path, category, etc.
    default: {}

  pipeline_config:
    type: dict
    description: Pipeline configuration from CATEGORIZE.
    default: {}

  synthesis:
    type: list
    description: Accumulated synthesis from previous investigations.
    default: []

  depth:
    type: num
    description: Current recursion depth.
    default: 0

  max_depth:
    type: num
    description: Maximum recursion depth.
    default: 5

  iterations:
    type: num
    description: Current task completion iteration.
    default: 0

  max_iterations:
    type: num
    description: Maximum continuation attempts.
    default: 3

  confidence_threshold:
    type: num
    description: Minimum confidence to skip investigation.
    default: 0.9

  state:
    type: str
    description: Path to SQLite state database.
    default: ""

  parent_id:
    type: str
    description: Parent task ID for task tree.
    default: ""

  profile:
    type: str
    description: LLM profile to use.
    default: "default"

  capabilities:
    type: list
    description: Available capabilities registry (filtered by permissions).
    default: []

  permissions:
    type: dict
    description: Permission flags for capability filtering.
    default: { "read": true, "write": false, "execute": false }

blocks:
  - id: register
    description: Register this phase in the task tree.
    type: Workflow
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        parent_id: "{{ inputs.parent_id }}"
        kind: "phase"
        name: "gather"
        metadata:
          labels:
            phase_order: 2
            strategy: "{{ get(inputs.pipeline_config.gather, 'depth', 'focused') }}"
        inputs_data: "{{ inputs }}"
        depth: "{{ inputs.depth }}"
        status: "running"
        caller: "cortex-phase-gather"

  - id: recall
    type: Workflow
    description: THINK - Query existing evidence and facts from memory.
    depends_on: [register]
    inputs:
      workflow: cortex-evidence-query
      inputs:
        state: "{{ blocks.register.outputs.state }}"
        evidence_type: ""
        limit: 200

  - id: plan
    type: LLMCall
    description: PLAN - Decide what evidence to gather based on query + existing knowledge.
    depends_on:
      - block: register
        required: true
      - block: recall
        required: false
    inputs:
      profile: "{{ inputs.profile }}"
      timeout: 600
      system_instructions: "{{ inputs.system }}"
      prompt: |
        # Evidence Gathering Planning (ReAct Pattern)

        ## Query
        {{ inputs.prompt }}

        ## Gather Depth: {{ get(inputs.pipeline_config, 'gather', {}).depth | default('focused') | upper }}

        {% if inputs.context %}
        ## Context
        {{ inputs.context | tojson }}
        {% endif %}

        {% if get(blocks.recall.outputs, 'items', []) | length > 0 %}
        ## Evidence Already Gathered ({{ get(blocks.recall.outputs, 'items', []) | length }} items)
        {% for item in get(blocks.recall.outputs, 'items', []) %}
        - [{{ item.evidence_type }}] {{ item.key }}
        {% endfor %}
        {% endif %}

        {% if inputs.synthesis | length > 0 %}
        ## Previous Investigations (Reflexion)
        {% for c in inputs.synthesis %}
        ### Investigation {{ loop.index }}
        - Prompt: {{ c.prompt }}
        - Response: {{ c.response }}
        {% if c.synthesis %}
        - Key Findings: {{ c.synthesis.summary | default('N/A') }}
        {% endif %}
        {% endfor %}
        {% endif %}

        ## Depth-Specific Instructions

        {% if get(inputs.pipeline_config, 'gather', {}).depth == 'shallow' %}
        **SHALLOW DEPTH**: Minimal gathering for quick verification.
        - 1-2 targeted searches only
        - Focus on existence verification
        - Skip broad exploration
        {% elif get(inputs.pipeline_config, 'gather', {}).depth == 'focused' %}
        **FOCUSED DEPTH**: Targeted gathering in specific area.
        - 3-5 searches in relevant directories
        - Get key files, not everything
        - Follow obvious connections
        {% elif get(inputs.pipeline_config, 'gather', {}).depth == 'broad' %}
        **BROAD DEPTH**: Comprehensive search across codebase.
        - Multiple search patterns
        - Cover all relevant directories
        - Cast a wide net
        {% elif get(inputs.pipeline_config, 'gather', {}).depth == 'deep' %}
        **DEEP DEPTH**: Everything relevant + context.
        - Full file contents, not just outlines
        - Include related/dependent code
        - Get tests, configs, documentation
        {% else %}
        **DEFAULT**: Use focused gathering strategy.
        {% endif %}

        ## Available Capabilities (ATOMIC Operations)

        Use these capability workflows in your `operations` array:
        {% if inputs.capabilities | length > 0 %}
        {% for cap in inputs.capabilities %}
        **{{ cap.name }}** - {{ cap.description }}
        Inputs:
        {% for key, desc in cap.inputs.items() %}
          - {{ key }}: {{ desc }}
        {% endfor %}
        {% endfor %}
        {% else %}
        No capabilities available (check permissions).
        {% endif %}

        ## Investigations (Sub-Questions or Directives)

        For tasks requiring full cognitive actions (CATEGORIZE→GATHER→REASON→ACT):
        ```yaml
        investigations:
          - prompt: "How does the authentication middleware validate tokens?"
            reason: "Need deep understanding of auth flow"
        ```

        **DO NOT** use investigations for simple file reads - use operations instead.
        **DO** use investigations for tasks requiring analysis, synthesis, or complex actions.

        Investigation policy: {{ get(inputs.pipeline_config, 'gather', {}).spawn | default('complex_only') }}
        Current depth: {{ inputs.depth }} / {{ inputs.max_depth }}

        ## Config Override

        If you discover something unexpected that should change how REASON or ACT
        behaves, output config_override. For example:
        - Found security issues → reason.goal: evaluate, act.trigger: findings_require
        - Found complex architecture → reason.spawn: uncertain_only

      response_schema:
        type: object
        properties:
          result:
            type: object
            description: "Gathering plan (OUTPUT)"
            properties:
              strategy:
                type: string
                description: "High-level gathering strategy description"
              operations:
                type: array
                description: "Capability workflows to execute (ATOMIC dispatch)"
                items:
                  type: object
                  properties:
                    capability:
                      type: string
                      description: "Capability workflow name: cortex-gather-files, cortex-gather-search"
                    inputs:
                      type: object
                      description: "Capability-specific inputs. For cortex-gather-files: patterns (array), mode (outline|full|summary). For cortex-gather-search: pattern (regex string), path (directory), file_type (extension)."
                      properties:
                        patterns:
                          type: array
                          items:
                            type: string
                          description: "Glob patterns for cortex-gather-files (e.g., ['src/**/*.py', '*.yaml'])"
                        pattern:
                          type: string
                          description: "Regex pattern for cortex-gather-search (e.g., 'async def execute', 'class.*Block')"
                        path:
                          type: string
                          description: "Directory path to search in (e.g., 'src/workflows_mcp')"
                        mode:
                          type: string
                          description: "Read mode for gather-files: outline (structure only), full (complete content), summary"
                        file_type:
                          type: string
                          description: "File extension filter for gather-search (e.g., 'py', 'yaml')"
                        max_files:
                          type: integer
                          description: "Maximum files to read for gather-files"
                        max_matches:
                          type: integer
                          description: "Maximum matches to return for gather-search"
                    reason:
                      type: string
                      description: "Why this operation is needed"
                  required: [capability, reason]
              investigations:
                type: array
                description: "Sub-questions or directives requiring full cognitive analysis"
                items:
                  type: object
                  properties:
                    prompt:
                      type: string
                      description: "What to investigate (question or directive)"
                    reason:
                      type: string
                      description: "Why this investigation is needed"
                  required: [prompt, reason]
            required: [strategy, operations]
          config_override:
            type: object
            description: "Override config for REASON/ACT based on discoveries (OUTPUT)"
            properties:
              reason:
                type: object
                properties:
                  goal:
                    type: string
                    enum: [verify, explain, evaluate, plan, diagnose, enumerate]
                  spawn:
                    type: string
                    enum: [never, uncertain_only, always]
              act:
                type: object
                properties:
                  trigger:
                    type: string
                    enum: [never, findings_require, always]
                  mode:
                    type: string
                    enum: [none, report, implement, fix, verify]
          confidence:
            type: number
            minimum: 0
            maximum: 1
            description: "Confidence in gathering plan (INTERNAL)"
        required: [result, confidence]

  - id: dispatch
    type: Workflow
    description: ACT - Execute capability workflows in parallel via for_each.
    depends_on: [plan]
    condition: |
      {{ get(blocks.plan.outputs.response.result, 'operations', []) | length > 0 }}
    for_each: "{{ get(blocks.plan.outputs.response.result, 'operations', []) }}"
    for_each_mode: parallel
    max_parallel: 5
    continue_on_error: true
    inputs:
      workflow: "{{ each.value.capability }}"
      inputs:
        state: "{{ blocks.register.outputs.state }}"
        source_cell: "{{ blocks.register.outputs.task.task_id }}"
        base_path: "{{ get(inputs.context, 'repo_path', '.') }}"
        patterns: "{{ get(each.value.inputs, 'patterns', []) }}"
        pattern: "{{ get(each.value.inputs, 'pattern', '') }}"
        query: "{{ get(each.value.inputs, 'query', '') }}"
        mode: "{{ get(each.value.inputs, 'mode', '') }}"
        path: "{{ get(each.value.inputs, 'path', '') }}"

  - id: investigations
    type: Workflow
    description: ACT - Spawn child cortex-cells for complex investigations.
    depends_on: [dispatch]
    condition: |
      {{ get(blocks.plan.outputs.response.result, 'investigations', []) | length > 0
         and get(inputs.pipeline_config.gather, 'spawn', 'complex_only') != 'never'
         and inputs.depth < inputs.max_depth }}
    for_each: "{{ get(blocks.plan.outputs.response.result, 'investigations', []) }}"
    for_each_mode: parallel
    max_parallel: 3
    continue_on_error: true
    inputs:
      workflow: cortex-cell
      inputs:
        prompt: "{{ each.value.prompt }}"
        context: "{{ inputs.context | combine({'parent_prompt': inputs.prompt, 'spawn_reason': each.value.reason}) }}"
        depth: "{{ inputs.depth + 1 }}"
        max_depth: "{{ inputs.max_depth }}"
        iterations: "{{ inputs.iterations }}"
        max_iterations: "{{ inputs.max_iterations }}"
        state: "{{ blocks.register.outputs.state }}"
        parent_id: "{{ blocks.register.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"
        confidence_threshold: "{{ inputs.confidence_threshold }}"
        capabilities: "{{ inputs.capabilities }}"
        permissions: "{{ inputs.permissions }}"

  - id: combine_results
    type: Shell
    description: Combine investigation prompts with their results for Reflexion.
    depends_on: [investigations]
    condition: |
      {{ blocks.investigations.succeeded
         and get(blocks.investigations.metadata, 'count', 0) > 0 }}
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        # Investigation requests (what we asked)
        requests = json.loads(os.environ.get('REQUESTS', '[]'))
        # Investigation outputs (what we got back)
        outputs = json.loads(os.environ.get('OUTPUTS', '[]'))
        # Previous synthesis (accumulated)
        previous = json.loads(os.environ.get('PREVIOUS', '[]'))

        # Combine requests with outputs into Reflexion-compatible format
        combined = []
        for i, req in enumerate(requests):
            result = outputs[i] if i < len(outputs) else {}
            combined.append({
                'prompt': req.get('prompt', ''),
                'reason': req.get('reason', ''),
                'response': result.get('response', ''),
                'synthesis': result.get('synthesis', {})
            })

        # Merge with previous synthesis
        all_synthesis = previous + combined
        print(json.dumps(all_synthesis))
        EOF
      env:
        REQUESTS: "{{ get(blocks.plan.outputs.response.result, 'investigations', []) | tojson }}"
        OUTPUTS: "{{ blocks.investigations.outputs | default([]) | tojson }}"
        PREVIOUS: "{{ inputs.synthesis | tojson }}"

  - id: recurse
    type: Workflow
    description: LOOP - Recurse with accumulated syntheses from investigations.
    depends_on: [combine_results]
    condition: |
      {{ blocks.combine_results.succeeded
         and inputs.depth < inputs.max_depth }}
    inputs:
      workflow: cortex-phase-gather
      inputs:
        prompt: "{{ inputs.prompt }}"
        system: "{{ inputs.system }}"
        context: "{{ inputs.context }}"
        pipeline_config: "{{ inputs.pipeline_config }}"
        depth: "{{ inputs.depth + 1 }}"
        max_depth: "{{ inputs.max_depth }}"
        iterations: "{{ inputs.iterations }}"
        max_iterations: "{{ inputs.max_iterations }}"
        confidence_threshold: "{{ inputs.confidence_threshold }}"
        state: "{{ blocks.register.outputs.state }}"
        parent_id: "{{ blocks.register.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"
        capabilities: "{{ inputs.capabilities }}"
        permissions: "{{ inputs.permissions }}"
        synthesis: "{{ blocks.combine_results.outputs.stdout | fromjson }}"

  - id: track_done
    type: Workflow
    description: Mark phase complete and compile result.
    depends_on:
      - block: dispatch
        required: false
      - block: investigations
        required: false
      - block: combine_results
        required: false
      - block: recurse
        required: false
    condition: "{{ not blocks.recurse.succeeded }}"
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ blocks.register.outputs.state }}"
        task_id: "{{ blocks.register.outputs.task.task_id }}"
        status: "done"
        caller: "cortex-phase-gather"
        outputs_data:
          strategy: "{{ blocks.plan.outputs.response.result.strategy | default('') }}"
          operations_executed: "{{ get(blocks.dispatch.metadata, 'count', 0) }}"
          operations_failed: "{{ get(blocks.dispatch.metadata, 'count_failed', 0) }}"
          investigations_spawned: "{{ get(blocks.investigations.metadata, 'count', 0) }}"
          investigations_failed: "{{ get(blocks.investigations.metadata, 'count_failed', 0) }}"
          confidence: "{{ blocks.plan.outputs.response.confidence | default(0) }}"
          depth: "{{ inputs.depth }}"

outputs:
  result:
    type: dict
    description: "Gathering result. Recursed result passes through unchanged."
    value: |
      {{ blocks.recurse.outputs.result if blocks.recurse.succeeded else {
        'strategy': blocks.plan.outputs.response.result.strategy | default(''),
        'operations_executed': get(blocks.dispatch.metadata, 'count', 0),
        'operations_failed': get(blocks.dispatch.metadata, 'count_failed', 0),
        'investigations_spawned': get(blocks.investigations.metadata, 'count', 0),
        'investigations_failed': get(blocks.investigations.metadata, 'count_failed', 0),
        'confidence': blocks.plan.outputs.response.confidence | default(0),
        'depth': inputs.depth
      } }}

  config_override:
    type: dict
    description: "Config override for REASON/ACT based on discoveries."
    value: |
      {{ blocks.recurse.outputs.config_override if blocks.recurse.succeeded
         else (blocks.plan.outputs.response.config_override | default({})) }}

  state:
    type: str
    description: "Path to state database."
    value: "{{ blocks.register.outputs.state }}"
