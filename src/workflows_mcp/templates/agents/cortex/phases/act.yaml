name: cortex-phase-act
description: |
  CORTEX Action Phase

  Executes actions based on synthesis, or spawns further investigation
  if the action is too complex for direct execution.

  Action Decision Tree:
  1. Is action within permitted scope? → Check constraints
  2. Is confidence high enough? → Threshold check
  3. Is action atomic? → Use atomic capability
  4. Is action complex? → Spawn cortex(mode=null) for planning
  5. Does action need verification? → Plan verification step

tags: [cortex, phase, act]

inputs:
  query:
    type: str
    description: The original query.
    required: true

  synthesis:
    type: dict
    description: Synthesis results from synthesize phase.
    required: true

  context:
    type: dict
    description: Shared context from parent cell.
    required: true

  capabilities:
    type: dict
    description: Available capabilities registry.
    required: false
    default: {}

  state:
    type: str
    description: Path to SQLite state database.
    required: true

  parent_task_id:
    type: str
    description: Parent cell's task ID.
    required: false
    default: ""

  depth:
    type: num
    description: Current recursion depth.
    required: false
    default: 0

  max_depth:
    type: num
    description: Maximum recursion depth.
    required: false
    default: 5

  query_history:
    type: list
    description: Query hashes for cycle detection.
    required: false
    default: []

  profile:
    type: str
    description: LLM profile to use.
    required: false
    default: "default"

  # Action constraints
  allow_write:
    type: bool
    description: Whether file writes are permitted.
    required: false
    default: false

  allow_execute:
    type: bool
    description: Whether command execution is permitted.
    required: false
    default: false

  confidence_threshold:
    type: num
    description: Minimum confidence to take action.
    required: false
    default: 0.7

blocks:
  - id: register_task
    type: Workflow
    description: Register this phase in the task tree.
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        parent_id: "{{ inputs.parent_task_id }}"
        task: "Phase: Act"
        task_type: "cortex-act"
        status: "in-progress"
        caller: "cortex-phase-act"

  # Step 1: Decide what action to take
  - id: decide_action
    type: LLMCall
    description: Decide what action to take based on synthesis.
    depends_on: [register_task]
    inputs:
      profile: "{{ inputs.profile }}"
      timeout: 60
      prompt: |
        # Action Decision Phase

        You are the action module of a recursive cognitive system (CORTEX).
        Decide what action to take based on the synthesis.

        ## Original Query
        {{ inputs.query }}

        ## Synthesis
        - Summary: {{ inputs.synthesis.summary | default('No summary') }}
        - Risk Level: {{ inputs.synthesis.risk_level | default('info') }}
        - Confidence: {{ inputs.synthesis.confidence | default(0.5) }}
        - Actions Needed: {{ inputs.synthesis.actions_needed | default(false) }}

        {% if inputs.synthesis.recommendations %}
        ### Recommendations
        {% for rec in inputs.synthesis.recommendations %}
        - {{ rec }}
        {% endfor %}
        {% endif %}

        {% if inputs.synthesis.findings %}
        ### Key Findings
        {% for f in inputs.synthesis.findings[:5] %}
        - [{{ f.severity | upper }}] {{ f.claim }}
        {% endfor %}
        {% endif %}

        ## Constraints
        - Allow File Writes: {{ inputs.allow_write }}
        - Allow Command Execution: {{ inputs.allow_execute }}
        - Confidence Threshold: {{ inputs.confidence_threshold }}
        - Current Depth: {{ inputs.depth }} / {{ inputs.max_depth }}

        ## Action Decision Tree

        1. **No action needed** - If synthesis answers the query completely
        2. **Report only** - Generate a report/summary (safe, always allowed)
        3. **Atomic action** - Single file write, edit, or command
        4. **Complex action** - Requires full investigation cycle
        5. **Blocked** - Action needed but not permitted by constraints

        ## Instructions

        Decide the appropriate action. Be conservative - prefer reporting
        over direct changes unless explicitly requested.

      response_schema:
        type: object
        properties:
          action_type:
            type: string
            enum: [none, report, atomic_write, atomic_edit, atomic_command, complex, blocked]
            description: "Type of action to take"
          action_reason:
            type: string
            description: "Why this action was chosen"
          action_details:
            type: object
            properties:
              target:
                type: string
                description: "File path or command target"
              content:
                type: string
                description: "Content to write or command to execute"
              operations:
                type: array
                items:
                  type: object
                description: "Edit operations for atomic_edit"
            description: "Details for atomic actions"
          complex_query:
            type: string
            description: "Query for complex action (spawns new cell)"
          requires_confirmation:
            type: boolean
            description: "Whether user confirmation is needed"
          confidence:
            type: number
            minimum: 0
            maximum: 1
            description: "Confidence in this action"
        required: [action_type, action_reason, confidence]

  # Step 2: Execute atomic write action
  - id: execute_write
    type: CreateFile
    description: Execute atomic write action.
    depends_on: [decide_action]
    condition: |
      {{
        blocks.decide_action.outputs.response.action_type == 'atomic_write' and
        inputs.allow_write and
        blocks.decide_action.outputs.response.confidence >= inputs.confidence_threshold
      }}
    inputs:
      path: "{{ blocks.decide_action.outputs.response.action_details.target }}"
      content: "{{ blocks.decide_action.outputs.response.action_details.content }}"
      overwrite: false

  # Step 3: Execute atomic edit action
  - id: execute_edit
    type: EditFile
    description: Execute atomic edit action.
    depends_on: [decide_action]
    condition: |
      {{
        blocks.decide_action.outputs.response.action_type == 'atomic_edit' and
        inputs.allow_write and
        blocks.decide_action.outputs.response.confidence >= inputs.confidence_threshold
      }}
    inputs:
      path: "{{ blocks.decide_action.outputs.response.action_details.target }}"
      operations: "{{ blocks.decide_action.outputs.response.action_details.operations }}"
      backup: true

  # Step 4: Execute atomic command
  - id: execute_command
    type: Shell
    description: Execute atomic command.
    depends_on: [decide_action]
    condition: |
      {{
        blocks.decide_action.outputs.response.action_type == 'atomic_command' and
        inputs.allow_execute and
        blocks.decide_action.outputs.response.confidence >= inputs.confidence_threshold
      }}
    inputs:
      command: "{{ blocks.decide_action.outputs.response.action_details.content }}"
      working_dir: "{{ inputs.context.repo_path | default('.') }}"
      timeout: 60

  # Step 5: Spawn complex action (full cycle)
  - id: spawn_complex
    type: Workflow
    description: Spawn new cell for complex action.
    depends_on: [decide_action]
    condition: |
      {{
        blocks.decide_action.outputs.response.action_type == 'complex' and
        inputs.depth < inputs.max_depth
      }}
    inputs:
      workflow: cortex-cell
      inputs:
        query: "{{ blocks.decide_action.outputs.response.complex_query }}"
        mode: ""
        context: "{{ inputs.context }}"
        depth: "{{ inputs.depth + 1 }}"
        max_depth: "{{ inputs.max_depth }}"
        query_history: "{{ inputs.query_history }}"
        state: "{{ inputs.state }}"
        parent_task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        profile: "{{ inputs.profile }}"

  # Step 6: Generate report
  - id: generate_report
    type: Shell
    description: Generate action report.
    depends_on:
      - decide_action
      - block: execute_write
        required: false
      - block: execute_edit
        required: false
      - block: execute_command
        required: false
      - block: spawn_complex
        required: false
    inputs:
      command: |
        python3 << 'EOF'
        import json
        import os

        action_type = os.environ.get('ACTION_TYPE', 'none')
        action_reason = os.environ.get('ACTION_REASON', '')
        confidence = float(os.environ.get('CONFIDENCE', '0.5'))

        write_succeeded = os.environ.get('WRITE_SUCCEEDED', 'false') == 'true'
        edit_succeeded = os.environ.get('EDIT_SUCCEEDED', 'false') == 'true'
        command_succeeded = os.environ.get('COMMAND_SUCCEEDED', 'false') == 'true'
        complex_succeeded = os.environ.get('COMPLEX_SUCCEEDED', 'false') == 'true'

        actions_taken = []

        if action_type == 'none':
            actions_taken.append({'type': 'none', 'description': 'No action needed'})
        elif action_type == 'report':
            actions_taken.append({'type': 'report', 'description': 'Generated report'})
        elif action_type == 'atomic_write' and write_succeeded:
            actions_taken.append({'type': 'write', 'description': 'Created file', 'success': True})
        elif action_type == 'atomic_edit' and edit_succeeded:
            actions_taken.append({'type': 'edit', 'description': 'Edited file', 'success': True})
        elif action_type == 'atomic_command' and command_succeeded:
            actions_taken.append({'type': 'command', 'description': 'Executed command', 'success': True})
        elif action_type == 'complex' and complex_succeeded:
            actions_taken.append({'type': 'complex', 'description': 'Spawned investigation', 'success': True})
        elif action_type == 'blocked':
            actions_taken.append({'type': 'blocked', 'description': action_reason, 'success': False})
        else:
            actions_taken.append({'type': action_type, 'description': 'Action attempted', 'success': False})

        result = {
            'actions_taken': actions_taken,
            'action_type': action_type,
            'action_reason': action_reason,
            'confidence': confidence,
            'follow_up_needed': action_type == 'complex' or action_type == 'blocked'
        }

        print(json.dumps(result))
        EOF
      env:
        ACTION_TYPE: "{{ blocks.decide_action.outputs.response.action_type }}"
        ACTION_REASON: "{{ blocks.decide_action.outputs.response.action_reason }}"
        CONFIDENCE: "{{ blocks.decide_action.outputs.response.confidence }}"
        WRITE_SUCCEEDED: "{{ 'true' if blocks.execute_write.succeeded else 'false' }}"
        EDIT_SUCCEEDED: "{{ 'true' if blocks.execute_edit.succeeded else 'false' }}"
        COMMAND_SUCCEEDED: "{{ 'true' if blocks.execute_command.succeeded else 'false' }}"
        COMPLEX_SUCCEEDED: "{{ 'true' if blocks.spawn_complex.succeeded else 'false' }}"

  - id: store_actions
    type: Workflow
    description: Store action results in memory.
    depends_on: [generate_report]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        op: memory
        memory_op: set
        memory_key: "actions"
        memory_value: "{{ blocks.generate_report.outputs.stdout }}"
        caller: "cortex-phase-act"

  - id: track_done
    type: Workflow
    description: Mark phase complete.
    depends_on: [generate_report, store_actions]
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state }}"
        task_id: "{{ blocks.register_task.outputs.task.task_id }}"
        status: "done"
        caller: "cortex-phase-act"
        data:
          action_type: "{{ (blocks.generate_report.outputs.stdout | fromjson).action_type }}"
          actions_count: "{{ (blocks.generate_report.outputs.stdout | fromjson).actions_taken | length }}"

outputs:
  actions_taken:
    value: "{{ (blocks.generate_report.outputs.stdout | fromjson).actions_taken }}"
    type: list
    description: Actions executed in this phase.

  action_type:
    value: "{{ (blocks.generate_report.outputs.stdout | fromjson).action_type }}"
    type: str
    description: Type of action taken.

  follow_up_needed:
    value: "{{ (blocks.generate_report.outputs.stdout | fromjson).follow_up_needed }}"
    type: bool
    description: Whether follow-up is needed.

  synthesis:
    value: |
      {{
        {
          'findings': inputs.synthesis.findings | default([]),
          'summary': inputs.synthesis.summary | default(''),
          'risk_level': inputs.synthesis.risk_level | default('info'),
          'recommendations': inputs.synthesis.recommendations | default([]),
          'confidence': inputs.synthesis.confidence | default(0.5),
          'actions_taken': (blocks.generate_report.outputs.stdout | fromjson).actions_taken
        }
      }}
    type: dict
    description: Updated synthesis including actions taken.

  child_synthesis:
    value: "{{ blocks.spawn_complex.outputs.synthesis if blocks.spawn_complex.succeeded else {} }}"
    type: dict
    description: Synthesis from spawned complex action cell.
