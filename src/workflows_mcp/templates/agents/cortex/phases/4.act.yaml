name: cortex-phase-act
description: |
  CORTEX Act Phase (ReAct Pattern) - executes actions based on synthesis and config.

  Industry Standard: ReAct (Reason + Act) + Reflexion Hybrid
  - RECALL = THINK (retrieve memory and context)
  - PLAN   = REASON (decide what actions to take, evaluate completion)
  - ACT    = dispatch + spawn (execute operations sequentially, spawn child cells)
  - Loop via recursion when investigations resolve uncertainty

  Trigger Policy:
    - never: No action (read-only query)
    - findings_require: Only if REASON says actions_needed=true
    - always: Always attempt action

  Action Modes:
    - null: No action
    - report: Generate report/review
    - implement: Create/modify code
    - fix: Apply fix to issue
    - verify: Fix and run verification

tags: [cortex, phase, act, react]

inputs:
  prompt:
    type: str
    description: The original query.
    required: true

  system:
    type: str
    description: System prompt override.
    default: |
      You are the action module of a recursive cognitive system (CORTEX).
      Your role is to execute actions based on synthesis results and configuration.

      Be conservative - prefer reporting over direct changes unless explicitly requested.
      Never execute destructive actions without high confidence.

      Evaluate whether the task is COMPLETE:
      - complete=true: Original request is fully satisfied
      - complete=false + continuation_needed=true: More work needed

      Be honest about your confidence. If you're uncertain about the action,
      set uncertainty.exists = true and provide a specific question.

  context:
    type: dict
    description: Context including synthesis, category, repo_path, original_prompt, etc.
    default: {}

  pipeline_config:
    type: dict
    description: Pipeline configuration from CATEGORIZE (with any overrides).
    default: {}

  memory:
    type: list
    description: List of memory keys to retrieve.
    default: []

  synthesis:
    type: list
    description: Accumulated synthesis from previous investigations.
    default: []

  depth:
    type: num
    description: Current recursion depth (for investigations).
    default: 0

  max_depth:
    type: num
    description: Maximum recursion depth.
    default: 5

  iterations:
    type: num
    description: Current task completion iteration.
    default: 0

  max_iterations:
    type: num
    description: Maximum continuation attempts.
    default: 3

  confidence_threshold:
    type: num
    description: Minimum confidence to skip investigation.
    default: 0.7

  state:
    type: str
    description: Path to SQLite state database.
    default: ""

  models:
    type: dict
    description: Model definitions for CRUD operations.
    default: {}

  parent_id:
    type: str
    description: Parent task ID for task tree.
    default: ""

  profile:
    type: str
    description: LLM profile to use.
    default: "default"

  capabilities:
    type: list
    description: Available capabilities registry (filtered by permissions).
    default: []

  permissions:
    type: dict
    description: Available permissions.
    default: { "read": true, "write": false, "execute": false }

blocks:
  # ===========================================================================
  # STEP 1: Register Phase Task (model-based insert with auto UUID)
  # ===========================================================================
  - id: register
    type: Sql
    description: Register this phase in the task tree.
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.task }}"
      op: insert
      data:
        parent_id: "{{ inputs.parent_id if inputs.parent_id else none }}"
        kind: phase
        name: act
        metadata: "{{ {'labels': {'phase_order': 4, 'trigger': inputs.pipeline_config.act.trigger | default('never'), 'mode': inputs.pipeline_config.act.mode | default('null')}} }}"
        inputs: "{{ {'prompt': inputs.prompt, 'iterations': inputs.iterations} }}"
        status: running
        depth: "{{ inputs.depth }}"

  - id: recall
    type: Sql
    description: THINK - Retrieve memory and context for action planning.
    depends_on: [register]
    condition: "{{ inputs.memory | length > 0 }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      sql: |
        SELECT namespace, key, value, metadata
        FROM memory
        WHERE namespace = 'content'
        ORDER BY key
        LIMIT 100

  - id: build_schema
    type: Workflow
    description: Generate response schema with enforced capability enum.
    depends_on: [register]
    condition: |
      {{ inputs.pipeline_config.act.trigger | default('never') != 'never'
         and inputs.pipeline_config.act.mode | default('null') != 'null'
         and (inputs.pipeline_config.act.trigger == 'always'
              or inputs.context.synthesis.actions_needed | default(false)) }}
    inputs:
      workflow: cortex-internal-schema-operations
      inputs:
        capabilities: "{{ inputs.capabilities }}"
        phase: "act"
        include_spawn: true
        include_completion: true
        include_config_override: false

  - id: plan
    type: LLMCall
    description: PLAN - Decide what action to take and evaluate completion.
    depends_on:
      - block: register
        required: true
      - block: recall
        required: false
      - block: build_schema
        required: true
    condition: "{{ blocks.build_schema.succeeded }}"
    inputs:
      profile: "{{ inputs.profile }}"
      timeout: 600
      system_instructions: "{{ inputs.system }}"
      prompt: |
        # Action Phase

        ## Original Query
        {{ inputs.prompt }}

        {% if inputs.context.original_prompt and inputs.context.original_prompt != inputs.prompt %}
        ## Root Query (if this is a continuation)
        {{ inputs.context.original_prompt }}
        {% endif %}

        ## Action Mode: {{ inputs.pipeline_config.act.mode | default('report') | upper }}

        {% if inputs.context %}
        ## Context
        {{ inputs.context | tojson }}
        {% endif %}

        {% if inputs.context.synthesis %}
        ## Synthesis from REASON Phase
        - Summary: {{ inputs.context.synthesis.summary | default('N/A') }}
        - Risk Level: {{ inputs.context.synthesis.risk_level | default('N/A') }}
        - Actions Needed: {{ inputs.context.synthesis.actions_needed | default(false) }}
        {% if inputs.context.synthesis.recommendations %}
        - Recommendations:
        {% for rec in inputs.context.synthesis.recommendations %}
          - {{ rec }}
        {% endfor %}
        {% endif %}
        {% if inputs.context.synthesis.findings %}
        - Findings Count: {{ inputs.context.synthesis.findings | length }}
        {% endif %}
        {% endif %}

        {% if inputs.synthesis | length > 0 %}
        ## Previous Investigations
        {% for c in inputs.synthesis %}
        ### Investigation {{ loop.index }}
        - Question: {{ c.prompt }}
        - Answer: {{ c.response }}
        {% if c.synthesis %}
        - Key Findings: {{ c.synthesis.summary | default('N/A') }}
        {% endif %}
        {% endfor %}
        {% endif %}

        ## Permissions
        - Read: {{ inputs.permissions.read | default(true) }}
        - Write: {{ inputs.permissions.write | default(false) }}
        - Execute: {{ inputs.permissions.execute | default(false) }}

        ## Mode-Specific Instructions

        {% if inputs.pipeline_config.act.mode == 'report' %}
        **REPORT MODE**: Generate a comprehensive report/review.
        - Summarize all findings
        - Include recommendations
        - No file modifications
        {% elif inputs.pipeline_config.act.mode == 'implement' %}
        **IMPLEMENT MODE**: Create or modify code.
        - Plan implementation steps
        - Create/edit files as needed
        - Verify changes work
        {% elif inputs.pipeline_config.act.mode == 'fix' %}
        **FIX MODE**: Apply fix to the identified issue.
        - Target the root cause
        - Make minimal changes
        - Verify fix works
        {% elif inputs.pipeline_config.act.mode == 'verify' %}
        **VERIFY MODE**: Fix and run verification.
        - Apply the fix
        - Run relevant tests
        - Report verification results
        {% else %}
        **DEFAULT MODE**: Decide appropriate action based on synthesis.
        {% endif %}

        ## Available Capabilities (ATOMIC Operations)

        Use these capability workflows in your `operations` array.
        **IMPORTANT**: Operations are executed SEQUENTIALLY (order matters for mutations).
        **CRITICAL**: Use ONLY the exact capability names listed below - any other names will be rejected.

        {% if inputs.capabilities %}
        {% for cap in inputs.capabilities %}
        **{{ cap.name }}** - {{ cap.description }}
        {% for key, schema in cap.inputs.items() %}
          - {{ key }} ({{ schema.type }}{% if schema.required %}, required{% endif %}): {{ schema.description }}
        {% endfor %}
        {% endfor %}
        {% else %}
        **⚠️ NO WRITE/EXECUTE CAPABILITIES AVAILABLE**

        This task appears to require file modifications or command execution, but:
        - write permission: {{ inputs.permissions.write | default(false) }}
        - execute permission: {{ inputs.permissions.execute | default(false) }}

        If this task requires writing files or executing commands, you cannot proceed.
        Set `complete: true` and explain in your response what permissions would be needed.
        Only gather/read operations are available with current permissions.
        {% endif %}

        ## Edit Operation Examples (cortex-action-edit)

        When using cortex-action-edit, the `operations` input is a list of edit operations.
        Each operation requires a `type` field. Here are examples:

        **Replace text (most common):**
        ```json
        {"capability": "cortex-action-edit", "inputs": {"path": "/path/to/file", "operations": [
          {"type": "replace_text", "old_text": "TODO", "new_text": "DONE"}
        ]}}
        ```

        **Insert at line:**
        ```json
        {"capability": "cortex-action-edit", "inputs": {"path": "/path/to/file", "operations": [
          {"type": "insert_lines", "line_start": 1, "content": "import os\n"}
        ]}}
        ```

        **Delete lines:**
        ```json
        {"capability": "cortex-action-edit", "inputs": {"path": "/path/to/file", "operations": [
          {"type": "delete_lines", "line_start": 10, "line_end": 15}
        ]}}
        ```

        **Replace lines:**
        ```json
        {"capability": "cortex-action-edit", "inputs": {"path": "/path/to/file", "operations": [
          {"type": "replace_lines", "line_start": 5, "line_end": 8, "content": "new content here"}
        ]}}
        ```

        ## Questions (ONLY for genuinely different sub-tasks)

        **Questions = How you express uncertainty or need for parallel work.**

        | Confidence | Expected Action |
        |------------|-----------------|
        | 0.9 - 1.0  | Execute operations directly |
        | 0.7 - 0.9  | Consider questions for complex parts |
        | 0.5 - 0.7  | **SHOULD** ask questions before acting |
        | < 0.5      | **MUST** ask questions, avoid destructive actions |

        **CRITICAL**: Use questions ONLY when you need to:
        1. Implement something in a DIFFERENT domain than your current operations
        2. Handle a sub-task that requires its own GATHER phase (different files/data)
        3. Execute operations that conflict with your current sequential execution

        **DO NOT** use questions to:
        - Re-do what you're already doing
        - "Implement" something you can do directly with operations
        - Break down a simple task into parallel identical tasks

        **Example of CORRECT question** (genuinely different sub-task):
        ```yaml
        # Current task: "Implement user authentication"
        # You're working on backend auth...
        questions:
          - prompt: "Create frontend login form with validation"  # Different domain
            reason: "Frontend requires different files and patterns"
        ```

        ## Completion Evaluation

        After deciding on action, evaluate:
        - Is the ORIGINAL request fully satisfied?
        - If not, what remains to be done?

        Current iteration: {{ inputs.iterations }} of {{ inputs.max_iterations }}

      response_schema: "{{ blocks.build_schema.outputs.schema }}"

  # ===========================================================================
  # STEP 3b: Store LLM call for debugging
  # ===========================================================================
  - id: store_llm_call
    type: Sql
    description: Store LLM call details for debugging and analysis.
    depends_on:
      - block: plan
        required: false
    condition: "{{ inputs.state | trim != '' and blocks.plan.succeeded }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      model: "{{ inputs.models.llm_call }}"
      op: insert
      data:
        task_id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
        phase: act
        system_instructions: "{{ inputs.system | default('') }}"
        prompt: "{{ inputs.prompt }}"
        response: "{{ blocks.plan.outputs.response }}"
        model: "{{ blocks.plan.outputs.metadata.model | default('unknown') }}"
        prompt_tokens: "{{ blocks.plan.outputs.metadata.usage.prompt_tokens | default(0) }}"
        completion_tokens: "{{ blocks.plan.outputs.metadata.usage.completion_tokens | default(0) }}"
        duration_ms: "{{ blocks.plan.metadata.duration_ms | default(0) }}"

  - id: dispatch
    type: Workflow
    description: ACT - Execute capability workflows SEQUENTIALLY with deduplication.
    depends_on: [plan]
    condition: |
      {{ blocks.plan.succeeded
         and get(blocks.plan.outputs.response.result, 'operations', []) | length > 0
         and blocks.plan.outputs.response.confidence >= inputs.confidence_threshold }}
    for_each: "{{ blocks.plan.outputs.response.result.operations }}"
    for_each_mode: sequential
    continue_on_error: true
    inputs:
      workflow: cortex-action-dispatch
      inputs:
        state: "{{ inputs.state }}"
        models: "{{ inputs.models }}"
        parent_id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
        cell_id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
        capability: "{{ each.value.capability }}"
        inputs: "{{ each.value.inputs }}"
        reason: "{{ each.value.reason | default('') }}"
        base_path: "{{ inputs.context.repo_path | default('.') }}"
        permissions: "{{ inputs.permissions }}"

  - id: questions
    type: Workflow
    description: ACT - Spawn child cortex-cells to answer questions.
    depends_on: [plan]
    condition: |
      {{ blocks.plan.succeeded
         and get(blocks.plan.outputs.response.result, 'questions', []) | length > 0
         and blocks.plan.outputs.response.confidence >= inputs.confidence_threshold
         and inputs.depth < inputs.max_depth }}
    for_each: "{{ blocks.plan.outputs.response.result.questions }}"
    for_each_mode: parallel
    max_parallel: 3
    continue_on_error: true
    inputs:
      workflow: cortex-cell
      inputs:
        prompt: "{{ each.value.prompt }}"
        context: "{{ inputs.context | combine({'parent_prompt': inputs.prompt, 'spawn_reason': each.value.reason}) }}"
        depth: "{{ inputs.depth + 1 }}"
        max_depth: "{{ inputs.max_depth }}"
        iterations: 0
        max_iterations: "{{ inputs.max_iterations }}"
        state: "{{ inputs.state }}"
        parent_id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
        profile: "{{ inputs.profile }}"
        confidence_threshold: "{{ inputs.confidence_threshold }}"
        capabilities: "{{ inputs.capabilities }}"
        permissions: "{{ inputs.permissions }}"

  - id: investigate
    type: Workflow
    description: Spawn cortex-cell to investigate uncertainty.
    depends_on: [plan]
    condition: |
      {{ blocks.plan.succeeded
         and blocks.plan.outputs.response.confidence < inputs.confidence_threshold
         and blocks.plan.outputs.response.uncertainty.exists | default(false)
         and blocks.plan.outputs.response.uncertainty.question | default('') | length > 0
         and inputs.depth < inputs.max_depth }}
    inputs:
      workflow: cortex-cell
      inputs:
        prompt: "{{ blocks.plan.outputs.response.uncertainty.question }}"
        context:
          repo_path: "{{ inputs.context.repo_path | default('') }}"
          parent_prompt: "{{ inputs.prompt }}"
        depth: "{{ inputs.depth + 1 }}"
        max_depth: "{{ inputs.max_depth }}"
        iterations: 0
        max_iterations: "{{ inputs.max_iterations }}"
        state: "{{ inputs.state }}"
        parent_id: "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"
        profile: "{{ inputs.profile }}"
        confidence_threshold: "{{ inputs.confidence_threshold }}"
        capabilities: "{{ inputs.capabilities }}"
        permissions: "{{ inputs.permissions }}"

  - id: recurse
    type: Workflow
    description: LOOP - Self-recurse with accumulated synthesis from investigation.
    depends_on: [investigate]
    condition: "{{ blocks.investigate.succeeded }}"
    inputs:
      workflow: cortex-phase-act
      inputs:
        prompt: "{{ inputs.prompt }}"
        system: "{{ inputs.system }}"
        context: "{{ inputs.context }}"
        pipeline_config: "{{ inputs.pipeline_config }}"
        memory: "{{ inputs.memory }}"
        state: "{{ inputs.state }}"
        parent_id: "{{ inputs.parent_id }}"
        profile: "{{ inputs.profile }}"
        confidence_threshold: "{{ inputs.confidence_threshold }}"
        capabilities: "{{ inputs.capabilities }}"
        permissions: "{{ inputs.permissions }}"
        max_depth: "{{ inputs.max_depth }}"
        depth: "{{ inputs.depth + 1 }}"
        iterations: "{{ inputs.iterations }}"
        max_iterations: "{{ inputs.max_iterations }}"
        synthesis: |
          {{ inputs.synthesis + [{
            'prompt': blocks.plan.outputs.response.uncertainty.question,
            'response': blocks.investigate.outputs.response,
            'synthesis': blocks.investigate.outputs.synthesis
          }] }}

  # ===========================================================================
  # Track completion (direct Sql UPDATE)
  # ===========================================================================
  - id: track_done
    type: Sql
    description: Mark phase complete and compile result.
    depends_on:
      - block: register
        required: true
      - block: plan
        required: false
      - block: dispatch
        required: false
      - block: questions
        required: false
      - block: recurse
        required: false
    condition: "{{ blocks.register.succeeded }}"
    inputs:
      engine: sqlite
      path: "{{ inputs.state }}"
      sql: |
        UPDATE tasks
        SET status = 'done',
            outputs = ?,
            updated_at = datetime('now')
        WHERE id = ?
      params:
        - "{{ {'iterations': inputs.iterations, 'recursed': blocks.recurse.succeeded | default(false), 'action_taken': blocks.plan.succeeded, 'operations_dispatched': get(blocks.dispatch.metadata, 'count', 0), 'operations_failed': get(blocks.dispatch.metadata, 'count_failed', 0), 'questions_spawned': get(blocks.questions.metadata, 'count', 0), 'questions_failed': get(blocks.questions.metadata, 'count_failed', 0), 'confidence': blocks.plan.outputs.response.confidence | default(0)} | tojson }}"
        - "{{ (blocks.register.outputs.rows | default([{}]))[0].id | default('') }}"

outputs:
  result:
    type: dict
    description: "Action result. Recursed result passes through unchanged."
    value: |
      {{ blocks.recurse.outputs.result if blocks.recurse.succeeded
         else (blocks.plan.outputs.response.result if blocks.plan.succeeded
         else {'action_type': 'none', 'action_reason': 'trigger_disabled'}) }}

  complete:
    type: bool
    description: "Whether the original request is fully satisfied."
    value: |
      {{ blocks.recurse.outputs.complete if blocks.recurse.succeeded
         else (blocks.plan.outputs.response.complete if blocks.plan.succeeded
         else true) }}

  continuation_needed:
    type: bool
    description: "Whether a continuation cell should be spawned."
    value: |
      {{ blocks.recurse.outputs.continuation_needed if blocks.recurse.succeeded
         else (blocks.plan.outputs.response.continuation_needed | default(false) if blocks.plan.succeeded
         else false) }}

  continuation_prompt:
    type: str
    description: "Prompt for continuation cell if needed."
    value: |
      {{ blocks.recurse.outputs.continuation_prompt if blocks.recurse.succeeded
         else (blocks.plan.outputs.response.continuation_prompt | default('') if blocks.plan.succeeded
         else '') }}

  state:
    type: str
    description: "Path to state database."
    value: "{{ inputs.state }}"
