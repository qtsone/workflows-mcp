name: context-gathering
description: |
  Gather and validate context for PR review with early normalization.

  This workflow normalizes the input source (URL or local path) at the entry point,
  ensuring all downstream workflows receive a consistent local repo path regardless
  of how the PR was specified.

  Outputs:
  - repo_path: Always a valid local path (cloned or provided)
  - platform: 'github' | 'gitlab' | 'local'
  - pr_url: Original URL (empty for local repos)
  - Branches, metadata, diff, and categorized files

tags:
  - pr-review
  - context-validation
  - git
  - repository-management
  - normalization

inputs:
  url:
    type: str
    description: |
      Full PR URL for remote review (GitHub or GitLab).
      Mutually exclusive with repo_path. One of url or repo_path must be provided.
      Examples:
        - https://github.com/owner/repo/pull/123
        - https://gitlab.com/group/project/-/merge_requests/456
    required: false

  repo_path:
    type: str
    description: |
      Path to local git repository for local review.
      Mutually exclusive with url. One of url or repo_path must be provided.
    required: false

  base_branch:
    type: str
    description: |
      Branch to compare against (the target branch).
      If not provided, defaults to 'main'. For remote PRs, this is typically
      extracted from PR metadata but can be overridden.
    required: false
    default: "main"

  head_branch:
    type: str
    description: |
      Branch being reviewed (the source branch).
      If not provided for local repos, uses the current branch.
      For remote PRs, this is extracted from PR metadata.
    required: false

  workspace:
    type: str
    description: |
      Directory where remote repos should be cloned.
      Only used when url is provided. Defaults to {{tmp}}/pr-review-repo.
    required: false
    default: "{{tmp}}/pr-review-repo"

  state_path:
    type: str
    description: |
      Path to state file for task tracking.
      Used by state-management workflow to persist hierarchical task state.
      When provided, enables progress tracking and audit trails.
    required: false
    default: ""

  parent_task_id:
    type: str
    description: |
      Parent task ID for creating sub-tasks in the state tree.
      Used with state_path to create hierarchical task relationships.
    required: false
    default: ""

blocks:
  # ============================================================================
  # STATE TRACKING: Create sub-task at phase start
  # ============================================================================
  - id: track_start
    type: Workflow
    description: Create sub-task for context-gathering phase in state tree.
    condition: "{{ inputs.state_path and inputs.state_path != '' }}"
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state_path }}"
        parent_id: "{{ inputs.parent_task_id }}"
        task: "Phase: Context Gathering"
        task_type: "phase"
        status: "in-progress"
        caller: "pr-review:context-gathering"

  # ============================================================================
  # PHASE 1: DETERMINE SOURCE MODE (using Jinja2 logic)
  # ============================================================================
  # The mode is determined purely by which input is provided.
  # We use Jinja2 conditions throughout to route to appropriate blocks.

  # Helper to check URL is valid (not empty, not None)
  # URL mode: inputs.url is truthy and not 'None'
  # Local mode: inputs.repo_path is truthy and not 'None'

  # ============================================================================
  # PHASE 2A: REMOTE URL MODE - Clone repository and fetch metadata
  # ============================================================================

  - id: clone_remote_repo
    type: Workflow
    description: Clone the remote repository using git-repository-management workflow.
    condition: "{{ (inputs.url | default('', true)) not in ('', 'None') }}"
    inputs:
      workflow: git-repository-management
      inputs:
        url: "{{ inputs.url }}"
        workspace: "{{ inputs.workspace }}"

  - id: fetch_pr_metadata
    type: Workflow
    description: Fetch PR metadata via API for remote PRs.
    condition: "{{ (inputs.url | default('', true)) not in ('', 'None') }}"
    inputs:
      workflow: pr-metadata-fetch
      inputs:
        url: "{{ inputs.url }}"

  # ============================================================================
  # PHASE 2B: LOCAL MODE - Validate repository
  # ============================================================================

  - id: validate_local_repo
    type: Shell
    description: Validate that the local repository path exists and is a git repo.
    condition: "{{ (inputs.repo_path | default('', true)) not in ('', 'None') }}"
    inputs:
      command: |
        if [ ! -d "{{ inputs.repo_path }}/.git" ]; then
          echo "ERROR: Not a valid git repository: {{ inputs.repo_path }}" >&2
          exit 1
        fi
        echo "valid"

  - id: get_local_current_branch
    type: Shell
    description: Get current branch from local repository if head_branch not specified.
    condition: "{{ (inputs.repo_path | default('', true)) not in ('', 'None') and (inputs.head_branch | default('', true)) in ('', 'None') }}"
    depends_on:
      - block: validate_local_repo
        required: false
    inputs:
      working_dir: "{{ inputs.repo_path }}"
      command: git branch --show-current || git rev-parse --short HEAD

  # ============================================================================
  # PHASE 3: GENERATE DIFF (using resolved paths via Jinja2)
  # ============================================================================

  - id: generate_diff
    type: Shell
    description: Generate git diff between base and head branches.
    depends_on:
      - block: clone_remote_repo
        required: false
      - block: validate_local_repo
        required: false
      - block: fetch_pr_metadata
        required: false
      - block: get_local_current_branch
        required: false
    inputs:
      # Resolve working directory using Jinja2:
      # - URL mode: use workspace (where repo was cloned)
      # - Local mode: use repo_path
      working_dir: >-
        {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
          {{ inputs.workspace }}
        {%- else -%}
          {{ inputs.repo_path }}
        {%- endif -%}
      command: |
        # Resolve branches using Jinja2 logic
        {% set is_url_mode = inputs.url and inputs.url != 'None' and inputs.url != '' %}

        # Base branch: PR metadata > input > default
        {% if is_url_mode and blocks.fetch_pr_metadata.outputs.pr_metadata.base_branch %}
        BASE="{{ blocks.fetch_pr_metadata.outputs.pr_metadata.base_branch }}"
        {% else %}
        BASE="{{ inputs.base_branch }}"
        {% endif %}

        # Head branch: PR metadata > input > detected
        {% if is_url_mode and blocks.fetch_pr_metadata.outputs.pr_metadata.head_branch %}
        HEAD="{{ blocks.fetch_pr_metadata.outputs.pr_metadata.head_branch }}"
        {% elif inputs.head_branch and inputs.head_branch != 'None' and inputs.head_branch != '' %}
        HEAD="{{ inputs.head_branch }}"
        {% elif blocks.get_local_current_branch.succeeded %}
        HEAD="{{ blocks.get_local_current_branch.outputs.stdout | trim }}"
        {% else %}
        HEAD=$(git branch --show-current || git rev-parse --short HEAD)
        {% endif %}

        echo "Generating diff: $BASE..$HEAD" >&2

        # Try diff strategies in order of preference
        if git diff "$BASE..$HEAD" 2>/dev/null; then
          echo "✓ Generated diff: $BASE..$HEAD" >&2
        elif git diff "origin/$BASE..$HEAD" 2>/dev/null; then
          echo "✓ Generated diff: origin/$BASE..$HEAD" >&2
        elif MERGE_BASE=$(git merge-base "origin/$BASE" "$HEAD" 2>/dev/null || git merge-base "$BASE" "$HEAD" 2>/dev/null); then
          git diff "$MERGE_BASE..$HEAD"
          echo "✓ Generated diff via merge-base" >&2
        else
          echo "⚠ Falling back to HEAD~1 diff" >&2
          git diff HEAD~1 || echo ""
        fi

  - id: list_changed_files
    type: Shell
    description: Extract list of changed files from the diff.
    depends_on:
      - generate_diff
    inputs:
      working_dir: >-
        {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
          {{ inputs.workspace }}
        {%- else -%}
          {{ inputs.repo_path }}
        {%- endif -%}
      command: |
        {% set is_url_mode = inputs.url and inputs.url != 'None' and inputs.url != '' %}

        {% if is_url_mode and blocks.fetch_pr_metadata.outputs.pr_metadata.base_branch %}
        BASE="{{ blocks.fetch_pr_metadata.outputs.pr_metadata.base_branch }}"
        {% else %}
        BASE="{{ inputs.base_branch }}"
        {% endif %}

        {% if is_url_mode and blocks.fetch_pr_metadata.outputs.pr_metadata.head_branch %}
        HEAD="{{ blocks.fetch_pr_metadata.outputs.pr_metadata.head_branch }}"
        {% elif inputs.head_branch and inputs.head_branch != 'None' and inputs.head_branch != '' %}
        HEAD="{{ inputs.head_branch }}"
        {% elif blocks.get_local_current_branch.succeeded %}
        HEAD="{{ blocks.get_local_current_branch.outputs.stdout | trim }}"
        {% else %}
        HEAD=$(git branch --show-current)
        {% endif %}

        git diff --name-status "$BASE..$HEAD" 2>/dev/null || \
        git diff --name-status "origin/$BASE..$HEAD" 2>/dev/null || \
        git diff --name-status HEAD~1 2>/dev/null || \
        echo ""

  - id: categorize_changes
    type: LLMCall
    description: Categorize changed files by type and analyze the scope of changes.
    depends_on:
      - generate_diff
      - list_changed_files
    inputs:
      profile: default
      prompt: |
        Analyze the following git diff and categorize the changed files.

        Changed files:
        {{ blocks.list_changed_files.outputs.stdout }}

        Diff content (truncated if large):
        {{ blocks.generate_diff.outputs.stdout[:8000] }}

        Provide:
        1. Categories of files changed (source, test, config, docs, etc.)
        2. Files in each category
        3. A brief summary of the overall change scope
      response_schema:
        type: object
        properties:
          categories:
            type: array
            items:
              type: object
              properties:
                category:
                  type: string
                  description: "Category name (e.g., source, test, config, docs, build, ci)"
                files:
                  type: array
                  items:
                    type: string
                description:
                  type: string
                  description: "Brief description of changes in this category"
              required: [category, files]
          total_files:
            type: integer
            description: "Total number of files changed"
          summary:
            type: string
            description: "Overall summary of the change scope and nature"
          primary_languages:
            type: array
            items:
              type: string
            description: "Primary programming languages affected"
        required: [categories, total_files, summary]

  # ============================================================================
  # STATE TRACKING: Mark phase complete with captured data
  # ============================================================================
  - id: track_done
    type: Workflow
    description: Mark context-gathering phase as complete with captured data.
    condition: "{{ inputs.state_path and inputs.state_path != '' and blocks.track_start.succeeded }}"
    depends_on:
      - categorize_changes
    inputs:
      workflow: agent-state-management
      inputs:
        state: "{{ inputs.state_path }}"
        task_id: "{{ blocks.track_start.outputs.task_id }}"
        status: "done"
        caller: "pr-review:context-gathering"
        data:
          platform: >-
            {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
              {%- if 'github.com' in inputs.url -%}github{%- elif 'merge_requests' in inputs.url or 'gitlab' in inputs.url -%}gitlab{%- else -%}unknown{%- endif -%}
            {%- else -%}local{%- endif -%}
          repo_path: >-
            {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}{{ inputs.workspace }}{%- else -%}{{ inputs.repo_path }}{%- endif -%}
          files_changed: "{{ blocks.categorize_changes.outputs.response.total_files | default(0) }}"
          source_mode: >-
            {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}url{%- else -%}local{%- endif -%}

# ============================================================================
# OUTPUTS - Normalized data for downstream workflows
# All outputs use Jinja2 conditionals to provide consistent values
# ============================================================================

outputs:
  # Primary normalized outputs - these eliminate the url/repo_path duality
  repo_path:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
        {{ inputs.workspace }}
      {%- else -%}
        {{ inputs.repo_path }}
      {%- endif -%}
    type: str
    description: |
      Normalized local repository path. Always valid regardless of input source.
      For URL mode: path to cloned repo
      For local mode: the provided repo_path

  platform:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
        {%- if 'github.com' in inputs.url -%}
          github
        {%- elif 'merge_requests' in inputs.url or 'gitlab' in inputs.url -%}
          gitlab
        {%- else -%}
          unknown
        {%- endif -%}
      {%- else -%}
        local
      {%- endif -%}
    type: str
    description: |
      Detected platform: 'github', 'gitlab', 'unknown', or 'local'.
      Used by action phase to determine how to post comments.

  pr_url:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
        {{ inputs.url }}
      {%- else -%}

      {%- endif -%}
    type: str
    description: |
      Original PR URL (empty string for local repos).
      Preserved for action phase to post comments.

  # Branch information - resolved from PR metadata or inputs
  base_branch:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and blocks.fetch_pr_metadata.outputs.pr_metadata.base_branch -%}
        {{ blocks.fetch_pr_metadata.outputs.pr_metadata.base_branch }}
      {%- else -%}
        {{ inputs.base_branch }}
      {%- endif -%}
    type: str
    description: "Resolved base branch (target branch for the PR)."

  head_branch:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and blocks.fetch_pr_metadata.outputs.pr_metadata.head_branch -%}
        {{ blocks.fetch_pr_metadata.outputs.pr_metadata.head_branch }}
      {%- elif inputs.head_branch and inputs.head_branch != 'None' and inputs.head_branch != '' -%}
        {{ inputs.head_branch }}
      {%- elif blocks.get_local_current_branch.succeeded -%}
        {{ blocks.get_local_current_branch.outputs.stdout | trim }}
      {%- else -%}
        HEAD
      {%- endif -%}
    type: str
    description: "Resolved head branch (source branch being reviewed)."

  # PR metadata (empty dict for local repos)
  pr_metadata:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and blocks.fetch_pr_metadata.succeeded -%}
        {{ blocks.fetch_pr_metadata.outputs.pr_metadata | tojson }}
      {%- else -%}
        {}
      {%- endif -%}
    type: dict
    description: |
      PR metadata from API (title, description, author, labels, etc.).
      Empty dict for local repos without remote URL.

  # Diff and file analysis
  diff:
    value: "{{ blocks.generate_diff.outputs.stdout }}"
    type: str
    description: "Git diff output between base and head branches."

  changed_files:
    value: "{{ blocks.categorize_changes.outputs.response | tojson }}"
    type: dict
    description: "Categorized list of changed files with analysis."

  # Source mode indicator
  source_mode:
    value: >-
      {%- if inputs.url and inputs.url != 'None' and inputs.url != '' -%}
        url
      {%- else -%}
        local
      {%- endif -%}
    type: str
    description: "Input source mode: 'url' or 'local'."
