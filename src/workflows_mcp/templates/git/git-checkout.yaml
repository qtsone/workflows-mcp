name: git-checkout
description: |
  Clone or checkout a git repository with comprehensive features similar to GitHub's checkout action.

  Features:
  - Repository cloning with authentication support
  - Branch, tag, or commit SHA checkout
  - Fetch depth control (shallow/full clone)
  - Submodule support (none/true/recursive)
  - Git LFS support
  - Sparse checkout for large repos
  - Clean working directory option

version: "1.0"
author: Workflows MCP Team
tags: [git, checkout, clone, repository, github-action]

inputs:
  repo:
    type: str
    description: "Repository to checkout (format: 'owner/repo' or full URL)"
    required: true

  ref:
    type: str
    description: "Branch, tag, or commit SHA to checkout. Empty defaults to default branch."
    default: ""
    required: false

  path:
    type: str
    description: "Path where to place the repository"
    default: "{{tmp}}/repo"
    required: false

  token:
    type: str
    description: "Personal access token (PAT) for authentication. Leave empty to auto-discover."
    default: ""
    required: false

  ssh_key:
    type: str
    description: "SSH private key for authentication. Leave empty to use SSH agent if available."
    default: ""
    required: false

  fetch_depth:
    type: num
    description: "Number of commits to fetch. 0=full history, 1=shallow clone"
    default: 1
    required: false

  fetch_tags:
    type: bool
    description: "Whether to fetch tags even with limited fetch-depth"
    default: false
    required: false

  submodules:
    type: str
    description: "Submodule checkout mode: 'false', 'true', or 'recursive'"
    default: "false"
    required: false

  lfs:
    type: bool
    description: "Whether to download Git LFS files"
    default: false
    required: false

  clean_mode:
    type: str
    description: |
      How to handle uncommitted changes in existing repos:
      - 'skip': Ignore, let git handle conflicts naturally (default, safest)
      - 'stash': Preserve changes via git stash
      - 'discard': Remove all changes (destructive!)
      - 'prompt': Ask user interactively what to do
    default: "prompt"
    required: false

  sparse_checkout:
    type: str
    description: "Sparse checkout patterns (comma-separated paths). Empty = full checkout."
    default: ""
    required: false

  sparse_checkout_cone_mode:
    type: bool
    description: "Use cone mode for sparse checkout (more efficient)"
    default: true
    required: false


blocks:
  # ============================================================================
  # PHASE 1: PREPARATION & VALIDATION
  # ============================================================================

  - id: validate_inputs
    type: Shell
    inputs:
      command: |
        # Validate mutually exclusive auth methods
        if [ -n "{{inputs.token}}" ] && [ -n "{{inputs.ssh_key}}" ]; then
          echo "Error: Cannot use both token and SSH key authentication"
          exit 1
        fi

        # Validate submodules input
        if [ "{{inputs.submodules}}" != "false" ] && \
           [ "{{inputs.submodules}}" != "true" ] && \
           [ "{{inputs.submodules}}" != "recursive" ]; then
          echo "Error: submodules must be 'false', 'true', or 'recursive'"
          exit 1
        fi

        # Validate fetch_depth
        if [ {{inputs.fetch_depth}} -lt 0 ]; then
          echo "Error: fetch_depth must be >= 0"
          exit 1
        fi

        echo "✓ Input validation passed"

  - id: resolve_repository_url
    type: Shell
    inputs:
      command: |
        # Resolve repository URL (logic handled by Jinja2)
        {% if inputs.repo.startswith('http://') or inputs.repo.startswith('https://') or inputs.repo.startswith('git@') %}
        REPO_URL="{{inputs.repo}}"
        {% elif inputs.ssh_key %}
        REPO_URL="git@github.com:{{inputs.repo}}.git"
        {% else %}
        REPO_URL="https://github.com/{{inputs.repo}}.git"
        {% endif %}

        printf "$REPO_URL" > {{tmp}}/repo_url.txt
        echo "Repository URL: $REPO_URL"
    depends_on: [validate_inputs]
    outputs:
      url:
        type: str
        description: "Resolved repository URL"
        path: "{{tmp}}/repo_url.txt"

  # ============================================================================
  # CREDENTIAL DISCOVERY (Cascading Authentication Methods)
  # ============================================================================
  # Using CreateFile for credentials (better security handling than Shell)
  # Cascading priority: inputs > secrets > gh CLI > env vars > ssh agent

  - id: auth_write_input_token
    type: CreateFile
    condition: "{{inputs.token != ''}}"
    inputs:
      path: "{{tmp}}/auth_token"
      content: "{{inputs.token}}"
      mode: "0600"
    depends_on: [resolve_repository_url, validate_inputs]

  - id: auth_write_input_ssh_key
    type: CreateFile
    condition: "{{inputs.token == '' and inputs.ssh_key != ''}}"
    inputs:
      path: "{{tmp}}/auth_ssh.key"
      content: "{{inputs.ssh_key}}"
      mode: "0600"
    depends_on: [resolve_repository_url, validate_inputs]

  - id: auth_write_github_token_secret
    type: CreateFile
    condition: "{{inputs.token == '' and inputs.ssh_key == '' and secrets.GITHUB_TOKEN != ''}}"
    inputs:
      path: "{{tmp}}/auth_token"
      content: "{{secrets.GITHUB_TOKEN}}"
      mode: "0600"
    depends_on: [resolve_repository_url, validate_inputs]

  - id: auth_write_gh_token_secret
    type: CreateFile
    condition: "{{inputs.token == '' and inputs.ssh_key == '' and secrets.GITHUB_TOKEN == '' and secrets.GH_TOKEN != ''}}"
    inputs:
      path: "{{tmp}}/auth_token"
      content: "{{secrets.GH_TOKEN}}"
      mode: "0600"
    depends_on: [resolve_repository_url, validate_inputs]

  - id: auth_write_gitlab_token_secret
    type: CreateFile
    condition: "{{inputs.token == '' and inputs.ssh_key == '' and secrets.GITHUB_TOKEN == '' and secrets.GH_TOKEN == '' and secrets.GITLAB_TOKEN != ''}}"
    inputs:
      path: "{{tmp}}/auth_token"
      content: "{{secrets.GITLAB_TOKEN}}"
      mode: "0600"
    depends_on: [resolve_repository_url, validate_inputs]

  - id: auth_runtime_detection
    type: Shell
    condition: "{{inputs.token == '' and inputs.ssh_key == '' and secrets.GITHUB_TOKEN == '' and secrets.GH_TOKEN == '' and secrets.GITLAB_TOKEN == ''}}"
    inputs:
      working_dir: "{{tmp}}"
      command: |
        # Runtime detection: gh CLI and environment variables (token values never in template)
        AUTH_FOUND=false

        # Try gh CLI
        if command -v gh &> /dev/null && gh auth status &> /dev/null 2>&1; then
          gh auth token 2>/dev/null > auth_token
          if [ -s auth_token ]; then
            chmod 600 auth_token
            AUTH_FOUND=true
          fi
        fi

        # Try environment variables
        if [ "$AUTH_FOUND" = false ]; then
          for ENV_VAR in GITHUB_TOKEN GH_TOKEN GITLAB_TOKEN; do
            if [ -n "${!ENV_VAR:-}" ]; then
              printf "%s" "${!ENV_VAR}" > auth_token
              chmod 600 auth_token
              AUTH_FOUND=true
              break
            fi
          done
        fi

        # SSH agent (for git@ URLs only)
        {% if blocks.resolve_repository_url.outputs.url.startswith('git@') %}
        if [ "$AUTH_FOUND" = false ] && command -v ssh-add &> /dev/null && ssh-add -L &> /dev/null 2>&1; then
          touch ssh_agent_marker
          AUTH_FOUND=true
        fi
        {% endif %}

        if [ "$AUTH_FOUND" = false ]; then
          touch no_auth_marker
        fi
    depends_on: [resolve_repository_url, validate_inputs]

  - id: auth_determine_method
    type: Shell
    inputs:
      working_dir: "{{tmp}}"
      command: |
        # Determine which auth method was used (based on which files exist)
        if [ -f auth_token ]; then
          {% if inputs.token != '' %}
          printf "token" > auth_method
          echo "✓ Authentication: token (from input)"
          {% elif secrets.GITHUB_TOKEN != '' %}
          printf "token" > auth_method
          echo "✓ Authentication: token (from GITHUB_TOKEN secret)"
          {% elif secrets.GH_TOKEN != '' %}
          printf "token" > auth_method
          echo "✓ Authentication: token (from GH_TOKEN secret)"
          {% elif secrets.GITLAB_TOKEN != '' %}
          printf "token" > auth_method
          echo "✓ Authentication: token (from GITLAB_TOKEN secret)"
          {% else %}
          printf "token" > auth_method
          echo "✓ Authentication: token (from gh CLI or environment)"
          {% endif %}
        elif [ -f auth_ssh.key ]; then
          printf "ssh_key" > auth_method
          echo "✓ Authentication: ssh_key"
        elif [ -f ssh_agent_marker ]; then
          printf "ssh_agent" > auth_method
          echo "✓ Authentication: ssh_agent"
        else
          printf "none" > auth_method
          echo "⚠ No authentication - attempting unauthenticated access"
          echo "  For private repos: set secrets.GITHUB_TOKEN or use 'gh auth login'"
        fi
    depends_on:
      - block: auth_write_input_token
        required: false
      - block: auth_write_input_ssh_key
        required: false
      - block: auth_write_github_token_secret
        required: false
      - block: auth_write_gh_token_secret
        required: false
      - block: auth_write_gitlab_token_secret
        required: false
      - block: auth_runtime_detection
        required: false
    outputs:
      method:
        type: str
        description: "Authentication method used (token, ssh_key, ssh_agent, none)"
        path: "auth_method"

  # ============================================================================
  # AUTHENTICATION SETUP
  # ============================================================================

  - id: build_git_ssh_command
    type: CreateFile
    condition: "{{blocks.auth_determine_method.outputs.method in ['ssh_key', 'ssh_agent']}}"
    inputs:
      path: "{{tmp}}/git_ssh_cmd.txt"
      content: >-
        ssh{% if blocks.auth_determine_method.outputs.method == 'ssh_key' %} -i {{tmp}}/auth_ssh.key{% endif %} -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile={{tmp}}/known_hosts
    depends_on: [auth_determine_method]

  - id: prepare_target_directory
    type: Shell
    inputs:
      working_dir: "{{tmp}}"
      command: |
        TARGET_PATH="{{inputs.path}}"

        # Create parent directory if it doesn't exist
        mkdir -p "$(dirname "$TARGET_PATH")"

        # Check if directory exists and has content
        if [ -d "$TARGET_PATH" ]; then
          if [ -d "$TARGET_PATH/.git" ]; then
            printf "existing_repo" > target_state.txt
            echo "✓ Found existing repository"
          elif [ "$(ls -A "$TARGET_PATH" 2>/dev/null)" ]; then
            printf "non_empty_dir" > target_state.txt
            echo "⚠ Target directory exists and is not empty"
          else
            printf "empty_dir" > target_state.txt
            echo "✓ Target directory is empty"
          fi
        else
          printf "new" > target_state.txt
          echo "✓ Target directory will be created"
        fi
    depends_on: [resolve_repository_url]
    outputs:
      state:
        type: str
        description: "Target directory state: new, empty_dir, non_empty_dir, existing_repo"
        path: "target_state.txt"

  # ============================================================================
  # PHASE 2: CHECK WORKING DIRECTORY STATE
  # ============================================================================

  - id: check_clean_state
    type: Shell
    condition: "{{blocks.prepare_target_directory.outputs.state == 'existing_repo'}}"
    continue_on_error: true
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        # Check for both uncommitted changes and untracked files
        if [ -z "$(git status --porcelain 2>/dev/null)" ]; then
          echo "✓ Working directory is clean"
        else
          echo "⚠ Working directory has uncommitted changes or untracked files:"
          git status --short | head -10
          exit 1
        fi
    depends_on: [prepare_target_directory]

  # ============================================================================
  # PHASE 3: INTERACTIVE PROMPT (if dirty)
  # ============================================================================

  - id: prompt_for_clean_action
    type: Prompt
    condition: "{{inputs.clean_mode == 'prompt' and blocks.check_clean_state.failed}}"
    inputs:
      prompt: |
        ⚠ The working directory has uncommitted changes.

        What would you like to do?

        Options:
          skip     - Continue anyway (git will error if conflicts occur)
          stash    - Save changes to git stash (can restore later)
          discard  - Permanently delete all changes
          abort    - Stop the workflow

        Enter your choice:
    depends_on:
      - block: check_clean_state
        required: false

  # ============================================================================
  # PHASE 4: HANDLE UNCOMMITTED CHANGES
  # ============================================================================

  - id: handle_uncommitted_changes
    type: Shell
    condition: "{{blocks.check_clean_state.failed and inputs.clean_mode != 'skip'}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        # Determine action (from prompt or input)
        {% if inputs.clean_mode == 'prompt' %}
        ACTION="{{blocks.prompt_for_clean_action.response | trim}}"
        {% else %}
        ACTION="{{inputs.clean_mode}}"
        {% endif %}

        echo "Action: $ACTION"

        case "$ACTION" in
          skip)
            echo "Continuing with uncommitted changes..."
            echo "Git will fail if conflicts occur during checkout"
            ;;

          stash)
            echo "Stashing uncommitted changes..."
            STASH_MSG="Workflows git-checkout: $(date -Iseconds)"

            if git stash push -u -m "$STASH_MSG"; then
              echo "✓ Changes stashed successfully"
              echo ""
              echo "To restore your changes later:"
              echo "  cd {{inputs.path}}"
              echo "  git stash list    # Find your stash"
              echo "  git stash pop     # Restore most recent stash"
            else
              echo "⚠ Failed to stash changes"
              exit 1
            fi
            ;;

          discard)
            echo "⚠ DESTRUCTIVE OPERATION"
            echo "Discarding ALL uncommitted changes..."
            git status --short
            echo ""

            git reset --hard HEAD
            git clean -ffdx

            echo "✓ All changes discarded"
            ;;

          abort)
            echo "Workflow aborted by user"
            exit 1
            ;;

          *)
            echo "Error: Unknown action '$ACTION'"
            echo "Valid options: skip, stash, discard, abort"
            exit 1
            ;;
        esac
    depends_on:
      - block: check_clean_state
        required: false
      - block: prompt_for_clean_action
        required: false

  # ============================================================================
  # PHASE 3: CLONE OR FETCH REPOSITORY
  # ============================================================================

  - id: clone_repository
    type: Shell
    condition: "{{blocks.prepare_target_directory.outputs.state != 'existing_repo'}}"
    inputs:
      command: |
        {% set base_url = blocks.resolve_repository_url.outputs.url %}

        # Build authenticated URL (Jinja2 for logic, bash for token values)
        {% if blocks.auth_determine_method.outputs.method == 'token' and base_url.startswith('https://') %}
        AUTH_TOKEN=$(cat {{tmp}}/auth_token 2>/dev/null || echo "")
        if [ -n "$AUTH_TOKEN" ]; then
          REPO_URL="{{ base_url | replace('https://', 'https://x-access-token:${AUTH_TOKEN}@') }}"
        else
          REPO_URL="{{ base_url }}"
        fi
        {% else %}
        REPO_URL="{{ base_url }}"
        {% endif %}

        TARGET_PATH="{{inputs.path}}"

        # Load Git SSH command from isolated SSH setup
        {% if blocks.build_git_ssh_command.succeeded %}
        export GIT_SSH_COMMAND="{{blocks.build_git_ssh_command.outputs.content | trim}}"
        {% endif %}

        # Execute clone (without --branch to avoid failure when branch doesn't exist)
        echo "Cloning repository..."
        git clone \
          {% if inputs.fetch_depth > 0 %}--depth {{inputs.fetch_depth}} {% endif %}\
          --quiet \
          "$REPO_URL" "$TARGET_PATH"

        echo "✓ Repository cloned successfully"
      timeout: 300
    depends_on:
      - block: handle_uncommitted_changes
        required: false
      - block: build_git_ssh_command
        required: false
      - block: auth_determine_method
        required: false

  - id: fetch_updates
    type: Shell
    condition: "{{blocks.prepare_target_directory.outputs.state == 'existing_repo'}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        # Load Git SSH command from isolated SSH setup
        {% if blocks.build_git_ssh_command.succeeded %}
        export GIT_SSH_COMMAND="{{blocks.build_git_ssh_command.content | trim}}"
        {% endif %}

        echo "Fetching updates..."
        git fetch origin \
          {% if inputs.fetch_depth > 0 %}--depth={{inputs.fetch_depth}} {% endif %}\
          --quiet

        echo "✓ Updates fetched successfully"
      timeout: 300
    depends_on:
      - block: handle_uncommitted_changes
        required: false
      - block: build_git_ssh_command
        required: false
      - block: auth_determine_method
        required: false

  # ============================================================================
  # PHASE 4: CHECKOUT SPECIFIC REF
  # ============================================================================

  - id: checkout_ref
    type: Shell
    condition: "{{inputs.ref != ''}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        # Try to checkout existing ref, or create new branch if it doesn't exist
        echo "Checking out ref: {{inputs.ref}}"

        if git checkout {{inputs.ref}} 2>/dev/null; then
          echo "✓ Checked out existing ref: {{inputs.ref}}"

          # If it's a branch and we're in existing repo, pull latest
          {% if blocks.prepare_target_directory.outputs.state == 'existing_repo' %}
          if git show-ref --verify --quiet "refs/heads/{{inputs.ref}}"; then
            echo "Pulling latest changes for branch {{inputs.ref}}..."
            git pull origin {{inputs.ref}} || true
          fi
          {% endif %}
        else
          echo "Branch/ref '{{inputs.ref}}' not found, creating new branch..."
          git checkout -b {{inputs.ref}}
          echo "✓ Created and checked out new branch: {{inputs.ref}}"
        fi
      timeout: 60
    depends_on:
      - block: clone_repository
        required: false
      - block: fetch_updates
        required: false

  # ============================================================================
  # PHASE 5: FETCH TAGS (if requested)
  # ============================================================================

  - id: fetch_tags
    type: Shell
    condition: "{{inputs.fetch_tags}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        echo "Fetching tags..."

        # Load Git SSH command from isolated SSH setup
        {% if blocks.build_git_ssh_command.succeeded %}
        export GIT_SSH_COMMAND="{{blocks.build_git_ssh_command.content | trim}}"
        {% endif %}

        git fetch --tags origin

        echo "✓ Tags fetched successfully"
      timeout: 60
    depends_on:
      - block: checkout_ref
        required: false
      - block: clone_repository
        required: false
      - block: fetch_updates
        required: false

  # ============================================================================
  # PHASE 6: SPARSE CHECKOUT CONFIGURATION
  # ============================================================================

  - id: configure_sparse_checkout
    type: Shell
    condition: "{{inputs.sparse_checkout != ''}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        echo "Configuring sparse checkout..."

        # Enable sparse checkout
        git config core.sparseCheckout true

        # Set cone mode
        {% if inputs.sparse_checkout_cone_mode %}
        git config core.sparseCheckoutCone true
        {% else %}
        git config core.sparseCheckoutCone false
        {% endif %}

        # Write sparse checkout patterns
        SPARSE_FILE=".git/info/sparse-checkout"
        echo "{{inputs.sparse_checkout}}" | tr ',' '\n' > "$SPARSE_FILE"

        # Apply sparse checkout
        git read-tree -mu HEAD

        echo "✓ Sparse checkout configured with patterns:"
        cat "$SPARSE_FILE"
      timeout: 60
    depends_on:
      - block: fetch_tags
        required: false

  # ============================================================================
  # PHASE 7: SUBMODULES
  # ============================================================================

  - id: checkout_submodules
    type: Shell
    condition: "{{inputs.submodules != 'false'}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        echo "Initializing submodules..."

        # Load Git SSH command from isolated SSH setup
        {% if blocks.build_git_ssh_command.succeeded %}
        export GIT_SSH_COMMAND="{{blocks.build_git_ssh_command.content | trim}}"
        {% endif %}

        # Initialize and update submodules
        git submodule init

        git submodule update \
          {% if inputs.submodules == 'recursive' %}--recursive {% endif %}\
          {% if inputs.fetch_depth > 0 %}--depth={{inputs.fetch_depth}} {% endif %}

        echo "✓ Submodules checked out successfully"
      timeout: 300
    depends_on:
      - block: configure_sparse_checkout
        required: false

  # ============================================================================
  # PHASE 8: GIT LFS
  # ============================================================================

  - id: check_lfs_installed
    type: Shell
    condition: "{{inputs.lfs}}"
    inputs:
      command: |
        if ! command -v git-lfs &> /dev/null; then
          echo "Error: Git LFS is not installed but lfs=true was specified"
          echo "Install with: brew install git-lfs (macOS) or apt-get install git-lfs (Linux)"
          exit 1
        fi

        echo "✓ Git LFS is installed"
    depends_on:
      - block: checkout_submodules
        required: false

  - id: fetch_lfs_files
    type: Shell
    condition: "{{inputs.lfs and blocks.check_lfs_installed.succeeded}}"
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        echo "Fetching Git LFS files..."

        # Initialize LFS
        git lfs install

        # Fetch LFS files
        git lfs fetch
        git lfs checkout

        echo "✓ Git LFS files downloaded successfully"
      timeout: 600
    depends_on: [check_lfs_installed]

  # ============================================================================
  # PHASE 9: FINAL STATUS & SUMMARY
  # ============================================================================

  - id: get_commit_sha
    type: Shell
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        git rev-parse HEAD
    depends_on:
      - block: fetch_lfs_files
        required: false

  - id: get_branch
    type: Shell
    inputs:
      working_dir: "{{inputs.path}}"
      command: |
        git branch --show-current || printf "(detached)"
    depends_on:
      - block: fetch_lfs_files
        required: false

  # ============================================================================
  # PHASE 10: CLEANUP
  # ============================================================================

  - id: cleanup_temp_files
    type: Shell
    inputs:
      working_dir: "{{tmp}}"
      command: |
        # Clean up all temporary files
        rm -f repo_url.txt
        rm -f target_state.txt
        rm -f git_ssh_cmd.txt
        rm -f auth_method
        rm -f auth_token
        rm -f auth_ssh.key
        rm -f known_hosts
        echo "✓ Temporary files cleaned up"
    depends_on:
      - block: get_commit_sha
        required: false
      - block: get_branch
        required: false

# ============================================================================
# WORKFLOW OUTPUTS
# ============================================================================

outputs:
  commit_sha:
    value: "{{blocks.get_commit_sha.outputs.stdout}}"
    type: str
    description: "Full SHA of the checked out commit"

  branch:
    value: "{{blocks.get_branch.outputs.stdout}}"
    type: str
    description: "Current branch name (or '(detached)' if detached HEAD)"

  repository_path:
    value: "{{inputs.path}}"
    type: str
    description: "Full path where the repository was checked out"
