name: git-commit
description: |
  Create a semantic commit with an AI-generated message based on staged changes.

  Uses LLM to analyze diffs and determine commit type (feat, fix, docs, refactor, test, chore,
  perf, style), extract scope, and generate a meaningful description following Conventional
  Commits specification.

  Workflow steps:
  1. Optional staging of all modified files
  2. Analyze staged changes (via git-analyze-changes)
  3. Generate semantic commit message using LLM (or use manual override)
  4. Optional interactive confirmation
  5. Create the commit
version: "4.0.0"
author: "workflows-mcp"
tags: [git, commit, semantic, conventional-commits, interactive, composed]
inputs:
  stage_all:
    type: bool
    default: false
    description: "(Optional) Stage all modified files before analyzing (default: use already staged files)"
    required: false
  working_dir:
    type: str
    default: "."
    description: "(Optional) Path to the git repository"
    required: false
  auto_commit:
    type: bool
    default: true
    description: "(Optional) Skip interactive confirmation and commit immediately with generated message"
    required: false
  commit_message:
    type: str
    default: ""
    description: "(Optional) Manually provide commit message (bypasses LLM generation)"
    required: false
blocks:
  - id: stage_files
    type: Shell
    description: "Stage all modified files in git repository"
    inputs:
      command: git add -A
      working_dir: "{{inputs.working_dir}}"
    condition: "{{inputs.stage_all}}"
  - id: analyze_changes
    type: Workflow
    description: "Analyze staged changes in git repository"
    inputs:
      workflow: "git-analyze-changes"
      inputs:
        working_dir: "{{inputs.working_dir}}"
  - id: no_changes_message
    type: Shell
    description: "No changes to commit"
    inputs:
      command: echo "No changes to commit"
    condition: "not {{blocks.analyze_changes.outputs.has_changes}}"
    depends_on:
      - analyze_changes
  - id: llm_generate_message
    type: LLMCall
    description: "Generate semantic commit message using LLM"
    inputs:
      profile: default
      response_schema:
        type: object
        required: [type, summary, body]
        properties:
          type:
            type: string
            enum: [feat, fix, docs, style, refactor, perf, test, chore, ci]
            description: "Commit type following Conventional Commits"
          scope:
            type: string
            description: "Component/module affected (optional)"
          summary:
            type: string
            maxLength: 72
            description: "Brief summary in imperative mood, lowercase, no period"
          body:
            type: string
            description: "Detailed explanation of what and why (optional, can be empty string)"
      prompt: |
        Analyze the following git changes and generate a semantic commit message following the Conventional Commits specification.

        ## Summary
        {{blocks.analyze_changes.outputs.summary}}

        ## Detailed Changes
        {{blocks.analyze_changes.outputs.diff}}

        Generate a structured commit message with the following components:
        - type: Choose the most appropriate type (feat, fix, docs, style, refactor, perf, test, chore, ci)
        - scope: Identify the component/module affected (leave empty if not applicable)
        - summary: Write a concise summary in imperative mood, lowercase, no period, max 72 characters
        - body: Provide detailed explanation of what changed and why (leave empty if summary is self-explanatory). Write as a single paragraph without line breaks. Do NOT use escape sequences like \n or \t.
    condition: "{{blocks.analyze_changes.outputs.has_changes}} and {{inputs.commit_message}} == ''"
    depends_on:
      - analyze_changes

  - id: select_message
    type: Shell
    description: "Select final commit message: manual override or LLM-generated"
    inputs:
      env:
        MANUAL_MESSAGE: "{{inputs.commit_message}}"
        LLM_TYPE: "{{blocks.llm_generate_message.outputs.response.type}}"
        LLM_SCOPE: "{{blocks.llm_generate_message.outputs.response.scope}}"
        LLM_SUMMARY: "{{blocks.llm_generate_message.outputs.response.summary}}"
        LLM_BODY: "{{blocks.llm_generate_message.outputs.response.body}}"
      command: |
        # Use environment variables to safely pass content (GitHub Actions pattern)
        # This prevents shell expansion of special chars (backticks, $, quotes)
        if [ -n "$MANUAL_MESSAGE" ]; then
          cat <<-EOF > "$SCRATCH/message.txt"
        	$MANUAL_MESSAGE
        	EOF
        else
          # Format structured commit message from LLM response
          # Format: <type>(<scope>): <summary>\n\n<body>
          if [ -n "$LLM_SCOPE" ]; then
            HEADER="${LLM_TYPE}(${LLM_SCOPE}): ${LLM_SUMMARY}"
          else
            HEADER="${LLM_TYPE}: ${LLM_SUMMARY}"
          fi

          if [ -n "$LLM_BODY" ]; then
            cat <<-EOF > "$SCRATCH/message.txt"
        	$HEADER

        	$LLM_BODY
        	EOF
          else
            cat <<-EOF > "$SCRATCH/message.txt"
        	$HEADER
        	EOF
          fi
        fi
    condition: "{{blocks.analyze_changes.outputs.has_changes}}"
    depends_on:
      - block: llm_generate_message
        required: false
    outputs:
      message:
        type: str
        path: "$SCRATCH/message.txt"

  - id: confirm_commit
    type: Prompt
    description: "Prompt user for commit confirmation"
    inputs:
      prompt: |
        About to create commit with message:

        {{blocks.select_message.outputs.message}}

        Proceed with commit? Respond with 'yes' or 'no'
    condition: "{{blocks.analyze_changes.outputs.has_changes}} and not {{inputs.auto_commit}}"
    depends_on:
      - select_message
  - id: create_commit
    type: Shell
    description: "Create git commit with semantic message"
    inputs:
      command: |
        set -e  # Exit immediately if any command fails
        # Create commit from message file and get hash
        git commit -F "$SCRATCH/message.txt"
        git rev-parse HEAD
      working_dir: "{{inputs.working_dir}}"
    condition: "{{blocks.analyze_changes.outputs.has_changes}} and ({{inputs.auto_commit}} or {{blocks.confirm_commit.outputs.response}} == 'yes')"
    depends_on:
      - select_message
      - block: confirm_commit
        required: false
outputs:
  has_changes:
    value: "{{blocks.analyze_changes.outputs.has_changes}}"
  commit_succeeded:
    value: "{{blocks.create_commit.succeeded}}"
  commit_failed:
    value: "{{blocks.create_commit.failed}}"
  commit_skipped:
    value: "{{blocks.create_commit.skipped}}"
  commit_hash:
    value: "{{blocks.create_commit.outputs.stdout}}"
