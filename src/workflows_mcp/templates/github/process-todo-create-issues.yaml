name: process-todo-create-issues
description: |
  Process a todo list and create GitHub issues for each item.

  Features:
  - Reads todo items from a Markdown file (supports multiple formats)
  - Creates a GitHub issue for each todo item using for_each
  - Provides summary of created issues

  Requirements:
  - Todo file format: Markdown with one of these formats:
    1. Header format:
       ## Title
       Description here

    2. Checkbox format:
       - [ ] Title
       Description here

    3. Simple list:
       - Title (no description)
  - github-create-issue workflow must be available
  - GitHub CLI authenticated (required by github-create-issue)

tags:
  - github
  - issues
  - batch
  - interactive

inputs:
  todo_path:
    type: str
    required: true
    description: "Path to Markdown file containing todo items (supports ## headers or - [ ] checkboxes)"
  repo_path:
    type: str
    default: "."
    required: false
    description: "Path to git repository for creating issues"
  auto_confirm:
    type: bool
    default: false
    required: false
    description: "Skip confirmation prompts in github-create-issue (set to true for fully automated mode)"

blocks:
  # ============================================================================
  # Phase 1: Create Parser Script
  # ============================================================================
  - id: create_parser_script
    type: CreateFile
    inputs:
      path: "{{tmp}}/parse_todos.py"
      content: |
        #!/usr/bin/env python3
        """Parse markdown todos from various formats."""
        import re
        import json
        import sys
        from pathlib import Path
        from typing import List, Dict, Any


        def parse_header_format(content: str) -> List[Dict[str, str]]:
            """Parse ## Header format with description below."""
            todos = []
            # Split on ## headers, keeping the header text
            sections = re.split(r'^##\s+(.+?)$', content, flags=re.MULTILINE)

            # sections[0] is text before first header (usually empty)
            # sections[1] is first header, sections[2] is its content
            # sections[3] is second header, sections[4] is its content, etc.
            for i in range(1, len(sections), 2):
                if i + 1 < len(sections):
                    title = sections[i].strip()
                    description = sections[i + 1].strip()
                    if title:  # Skip empty headers
                        todos.append({
                            "title": title,
                            "description": description
                        })
            return todos


        def parse_checkbox_format(content: str) -> List[Dict[str, str]]:
            """Parse - [ ] or - [x] checkbox format with optional description."""
            todos = []
            lines = content.split('\n')
            current_item = None
            description_lines = []

            for line in lines:
                # Check for checkbox: - [ ] or - [x] or * [ ] etc.
                checkbox_match = re.match(r'^[-*]\s+\[([ xX])\]\s+(.+)$', line.strip())

                if checkbox_match:
                    # Save previous item if exists
                    if current_item:
                        todos.append({
                            "title": current_item,
                            "description": '\n'.join(description_lines).strip()
                        })

                    # Start new item
                    current_item = checkbox_match.group(2).strip()
                    description_lines = []

                elif current_item:
                    # Continuation line - add to description if not empty and not a new section marker
                    stripped = line.strip()
                    if stripped and not stripped.startswith(('#', '-', '*')):
                        description_lines.append(stripped)
                    elif not stripped:
                        # Empty line - might be end of description
                        pass

            # Save last item
            if current_item:
                todos.append({
                    "title": current_item,
                    "description": '\n'.join(description_lines).strip()
                })

            return todos


        def parse_simple_list(content: str) -> List[Dict[str, str]]:
            """Parse simple - or * list format (no checkboxes)."""
            todos = []
            lines = content.split('\n')

            for line in lines:
                stripped = line.strip()
                # Match - or * at start, but not checkboxes
                if stripped.startswith(('- ', '* ')) and not re.match(r'^[-*]\s+\[', stripped):
                    title = stripped[2:].strip()
                    if title:
                        todos.append({
                            "title": title,
                            "description": ""
                        })

            return todos


        def parse_markdown_todos(file_path: str) -> List[Dict[str, str]]:
            """
            Parse markdown file and extract todo items.

            Tries multiple formats in order:
            1. ## Header format
            2. - [ ] Checkbox format
            3. Simple - list format

            Returns list of dicts with 'title' and 'description' keys.
            """
            path = Path(file_path)
            if not path.exists():
                raise FileNotFoundError(f"Todo file not found: {file_path}")

            content = path.read_text(encoding='utf-8')

            # Try header format first
            todos = parse_header_format(content)
            if todos:
                return todos

            # Try checkbox format
            todos = parse_checkbox_format(content)
            if todos:
                return todos

            # Fall back to simple list
            todos = parse_simple_list(content)
            return todos


        def main():
            if len(sys.argv) != 3:
                print("Usage: parse_todos.py <input_file> <output_json>", file=sys.stderr)
                sys.exit(1)

            input_file = sys.argv[1]
            output_file = sys.argv[2]

            try:
                todos = parse_markdown_todos(input_file)

                if not todos:
                    print("ERROR: No todo items found in markdown file", file=sys.stderr)
                    sys.exit(1)

                # Write to JSON
                with open(output_file, 'w', encoding='utf-8') as f:
                    json.dump(todos, f, indent=2, ensure_ascii=False)

                # Print summary to stdout
                print(f"Found {len(todos)} todo items")
                for i, todo in enumerate(todos, 1):
                    title_preview = todo['title'][:60]
                    if len(todo['title']) > 60:
                        title_preview += "..."
                    print(f"  {i}. {title_preview}")

            except Exception as e:
                print(f"ERROR: {e}", file=sys.stderr)
                sys.exit(1)


        if __name__ == "__main__":
            main()

  # ============================================================================
  # Phase 2: Parse Markdown File
  # ============================================================================
  - id: parse_markdown_todos
    type: Shell
    inputs:
      command: |
        # Validate todo file exists
        if [ ! -f "{{inputs.todo_path}}" ]; then
          echo "ERROR: Todo file not found: {{inputs.todo_path}}"
          exit 1
        fi

        # Run the parser
        python3 "{{tmp}}/parse_todos.py" "{{inputs.todo_path}}" "{{tmp}}/parsed_todos.json"

        echo "Successfully parsed todos"
    outputs:
      parsed_todos:
        type: json
        path: "{{tmp}}/parsed_todos.json"
    depends_on: [create_parser_script]

  # ============================================================================
  # Phase 3: Create GitHub Issues (for_each iteration)
  # ============================================================================
  - id: create_github_issues
    type: Workflow
    for_each: "{{blocks.parse_markdown_todos.outputs.parsed_todos}}"
    for_each_mode: sequential
    continue_on_error: true
    inputs:
      workflow: "github-create-issue"
      inputs:
        repo_path: "{{inputs.repo_path}}"
        title: "{{each.value.title}}"
        body: "{{each.value.description}}"
        auto_confirm: "{{inputs.auto_confirm}}"
    depends_on: [parse_markdown_todos]

  # ============================================================================
  # Phase 4: Generate Summary
  # ============================================================================
  - id: generate_summary
    type: Shell
    inputs:
      command: |
        # Get counts from for_each metadata
        TOTAL={{blocks.create_github_issues.metadata.count}}
        FAILED={{blocks.create_github_issues.metadata.count_failed}}
        SKIPPED={{blocks.create_github_issues.metadata.count_skipped}}
        ALL_SUCCEEDED={{blocks.create_github_issues.metadata.succeeded}}
        SUCCESSFUL=$((TOTAL - FAILED - SKIPPED))

        echo "================================"
        echo "Todo List Processing Complete"
        echo "================================"
        echo "Total items: $TOTAL"
        echo "Successful: $SUCCESSFUL"
        echo "Failed: $FAILED"
        echo "Skipped: $SKIPPED"
        echo "All succeeded: $ALL_SUCCEEDED"

        # Save summary
        cat > "{{tmp}}/summary.txt" <<EOF
        Total: $TOTAL
        Successful: $SUCCESSFUL
        Failed: $FAILED
        Skipped: $SKIPPED
        All Succeeded: $ALL_SUCCEEDED
        EOF
    outputs:
      summary:
        type: str
        path: "{{tmp}}/summary.txt"
    depends_on: [create_github_issues]

outputs:
  total_items:
    value: "{{blocks.create_github_issues.metadata.count}}"
  all_succeeded:
    value: "{{blocks.create_github_issues.metadata.succeeded}}"
  summary:
    value: "{{blocks.generate_summary.outputs.stdout}}"
